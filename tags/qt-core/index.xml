<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Qt Core on 石某人</title><link>https://sfw003.github.io/tags/qt-core/</link><description>Recent content in Qt Core on 石某人</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>石某人</copyright><lastBuildDate>Wed, 02 Apr 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://sfw003.github.io/tags/qt-core/index.xml" rel="self" type="application/rss+xml"/><item><title>【Qt Core 02】容器类和算法</title><link>https://sfw003.github.io/p/qt-core_02_container_and_algorithm/</link><pubDate>Wed, 02 Apr 2025 00:00:00 +0000</pubDate><guid>https://sfw003.github.io/p/qt-core_02_container_and_algorithm/</guid><description>&lt;blockquote>
&lt;p>以下内容基于Qt 5.15 LTS 官方文档整理&lt;/p>&lt;/blockquote>
&lt;p>Qt Core 提供多种容器类，满足不同的数据存储和操作需求。&lt;/p>
&lt;h2 id="字符串">字符串
&lt;/h2>&lt;p>Qt中与字符的核心类&lt;/p>
&lt;ul>
&lt;li>QChar：存放文本数据&lt;/li>
&lt;li>QByteArray：这个用来存放原始数据（图片、文件的二进制）&lt;/li>
&lt;li>QString：&lt;/li>
&lt;/ul>
&lt;p>QString存储一串16 位QChar，其中每个QChar对应一个&lt;strong>UTF-16&lt;/strong> 代码单元。（代码值大于65535的Unicode字符使用代理项对存储，即两个连续的QChar。&lt;/p>
&lt;p>Unicode是一种国际标准，支持当今使用的大多数书写系统。它是US-ASCIl（ANSIX3.4-1986）和Latin-1（IS08859-1）的超集，所有US-
ASCll/Latin-1字符都可以在相同的代码位置使用。&lt;/p>
&lt;p>在幕后，QString 使用隐式共享（写时复制）来减少内存使用并避免不必要的数据复制。这也有助于减少存储16 位字符而不是8 位字符的固有开销。&lt;/p>
&lt;p>除了QString之外，Qt还提供了QByteArray类来存储原始字节和传统的8位以\0&amp;rsquo;结尾的字符串。在大多数情况下，QString 是您要使用的类。它在整个QtAPI 中使用，如果您想在某个时候扩大应用程序的市场，Unicode支持可确保您的应用程序易于翻译。QByteArray适用的两种突出情况是需要存储原始二进制数据时，以及内存节省至关重要时（如在嵌入式系统中），&lt;/p>
&lt;h3 id="初始化">初始化
&lt;/h3>&lt;p>初始化QString的一种方法是将const char *传递给其构造函数。例如，以下代码创建了一个包含数据 “Hello”、大小为 5 的QString：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="n">QString&lt;/span> &lt;span class="n">str&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;Hello&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>QString会使用&lt;code>fromUtf8()&lt;/code>函数将const char * 数据转换为 Unicode。
在所有接受const char * 参数的QString函数中，const char * 被解释为经典的 C 风格以&amp;rsquo;\0&amp;rsquo;结尾的字符串。除非函数名明确表明采用其他编码，否则这类const char *参数都假定为 UTF-8 编码。
你也可以将字符串数据作为QChar数组提供：&lt;/p>
&lt;p>可以将字符串数据作为QChar数组提供：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">static&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="n">QChar&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="mh">0x0055&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0x006e&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0x10e3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0x03a3&lt;/span> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">QString&lt;/span> &lt;span class="nf">str&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>QString会对QChar数据进行深拷贝，所以你之后修改原数据不会产生副作用。如果不想对字符数据进行深拷贝，可以使用QStringView或QString::fromRawData()。&lt;/p>
&lt;p>此时会采用原始数据，如果你仍然修改了数据，它在修改时自动创建副本（深拷贝）&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="n">QRegularExpression&lt;/span> &lt;span class="nf">pattern&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="se">\u00A4&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">static&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="n">QChar&lt;/span> &lt;span class="n">unicode&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mh">0x005A&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0x007F&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0x00A4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0x0060&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mh">0x1009&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0x0020&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0x0020&lt;/span>&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">qsizetype&lt;/span> &lt;span class="n">size&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">unicode&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">QChar&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">QString&lt;/span> &lt;span class="n">str&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">QString&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">fromRawData&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">unicode&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">str&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">contains&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pattern&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>其他访问QString的数据，可以使用 operator&lt;a class="link" href="" >&lt;/a>和at()，这和c++的string使用方式一样。&lt;/p>
&lt;p>QString可以嵌入&amp;rsquo;\0&amp;rsquo;字符（QChar::Null）。size()函数始终返回整个字符串的大小，包括嵌入的&amp;rsquo;\0&amp;rsquo;字符。调用resize()函数后，新分配的字符具有未定义的值。要将字符串中的所有字符设置为特定值，可以使用fill()函数。&lt;/p>
&lt;p>你也可以将字符串字面量传递给接受QString作为参数的函数，这会调用QString(const char * )构造函数。类似地，你可以使用&lt;code>qPrintable()&lt;/code>宏将QString传递给接受const char * 参数的函数，该宏会将给定的QString作为const char *返回，这等效于调用&lt;code>&amp;lt;QString&amp;gt;.toLocal8Bit().constData()&lt;/code>。&lt;/p>
&lt;h3 id="操作字符串数据">操作字符串数据
&lt;/h3>&lt;p>QString 提供了以下用于修改字符数据的基本函数：append()（追加）、prepend()（前置添加）、insert()（插入）、replace()（替换）和remove()（删除）等等
如果你逐步构建一个 QString，并且事先大致知道该 QString 会包含多少字符，可以调用reserve()函数，让 QString 预先分配一定量的内存。你还可以调用capacity()函数来查看 QString 实际分配了多少内存。
replace()和remove()函数的前两个参数分别是开始删除的位置和应删除的字符数。如果你想将某个子字符串的所有出现都替换为另一个子字符串，可以使用带有两个参数的replace()重载函数。&lt;/p>
&lt;p>一个常见的需求是从字符串中删除空白字符（如&amp;rsquo;\n&amp;rsquo;、&amp;rsquo;\t&amp;rsquo;、&amp;rsquo; &amp;lsquo;等）。如果你想删除 QString 两端的空白字符，可以使用trimmed()函数。如果你想删除两端的空白字符，并且将字符串中多个连续的空白字符替换为单个空格字符，可以使用&lt;code>simplified()&lt;/code>函数。&lt;/p>
&lt;p>如果你想在 QString 中查找某个特定字符或子字符串的所有出现位置，可以使用indexOf()或lastIndexOf()函数。前者从给定的索引位置开始向前搜索，后者向后搜索。如果找到字符或子字符串，这两个函数都会返回其索引位置；否则，返回 -1。例如，下面是一个典型的循环，用于查找某个特定子字符串的所有出现位置：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="n">QString&lt;/span> &lt;span class="n">str&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;We must be &amp;lt;b&amp;gt;bold&amp;lt;/b&amp;gt;, very &amp;lt;b&amp;gt;bold&amp;lt;/b&amp;gt;&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">while&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">str&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">indexOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;&amp;lt;b&amp;gt;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">qDebug&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;Found &amp;lt;b&amp;gt; tag at index position&amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">++&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>QString 提供了许多用于将数字转换为字符串以及将字符串转换为数字的函数。例如arg()函数、setNum()函数、number()静态函数，以及toInt()、toDouble()等类似函数。
要获取字符串的大写或小写版本，可以使用toUpper()或toLower()函数。
字符串列表由QStringList类处理。你可以使用split()函数将一个字符串拆分为字符串列表，并使用QStringList::join()函数通过一个可选的分隔符将字符串列表合并为一个字符串。你还可以使用QStringList::filter()函数从字符串列表中获取包含特定子字符串或匹配特定QRegExp（正则表达式）的字符串列表。&lt;/p>
&lt;h3 id="查询字符串数据">查询字符串数据
&lt;/h3>&lt;p>如果你想查看一个QString是否以某个特定子字符串开头或结尾，可以使用&lt;code>startsWith()&lt;/code>或&lt;code>endsWith()&lt;/code>函数。如果你只是想检查一个QString是否包含某个特定字符或子字符串，可以使用&lt;code>contains()&lt;/code>函数。如果你想知道某个特定字符或子字符串在字符串中出现的次数，可以使用&lt;code>count()&lt;/code>函数。&lt;/p>
&lt;p>要获取指向实际字符数据的指针，可以调用&lt;code>data()&lt;/code>或&lt;code>constData()&lt;/code>函数。这些函数返回一个指向QChar数据开头的指针。在对QString调用非const函数之前，该指针保证有效。&lt;/p>
&lt;h3 id="比较字符串">比较字符串
&lt;/h3>&lt;p>QStrings可以使用诸如&lt;code>operator&amp;lt;()&lt;/code>、&lt;code>operator&amp;lt;=()&lt;/code>、&lt;code>operator==()&lt;/code>、&lt;code>operator&amp;gt;=()&lt;/code>等重载运算符进行比较。请注意，这种比较完全基于字符的数字Unicode值。它速度非常快，但不符合人类的预期；在可用的情况下，&lt;code>QString::localeAwareCompare()&lt;/code>函数通常是对用户界面字符串进行排序的更好选择。&lt;/p>
&lt;p>在类Unix平台（包括Linux、macOS和iOS）上，当Qt与ICU库链接时（通常是这样），会使用其区域设置感知排序。否则，在macOS和iOS上，&lt;code>localeAwareCompare()&lt;/code>会根据“国际”偏好面板中的“排序列表顺序”设置进行比较。在没有ICU的其他类Unix系统上，比较会回退到系统库的&lt;code>strcoll()&lt;/code>函数，当&lt;code>strcoll()&lt;/code>认为字符串相等时，再回退到QString的（不区分区域设置的）比较，如上文所述。&lt;/p>
&lt;h3 id="在8位字符串和unicode字符串之间转换">在8位字符串和Unicode字符串之间转换
&lt;/h3>&lt;p>QString提供了以下三个函数，用于将字符串以QByteArray的形式返回为&lt;code>const char *&lt;/code>版本：&lt;code>toUtf8()&lt;/code>、&lt;code>toLatin1()&lt;/code>和&lt;code>toLocal8Bit()&lt;/code>。&lt;/p>
&lt;ul>
&lt;li>&lt;code>toLatin1()&lt;/code>返回一个Latin - 1（ISO 8859 - 1）编码的8位字符串。&lt;/li>
&lt;li>&lt;code>toUtf8()&lt;/code>返回一个UTF - 8编码的8位字符串。UTF - 8是US - ASCII（ANSI X3.4 - 1986）的超集，通过多字节序列支持整个Unicode字符集。&lt;/li>
&lt;li>&lt;code>toLocal8Bit()&lt;/code>返回一个使用系统本地编码的8位字符串。&lt;/li>
&lt;/ul>
&lt;p>为了从这些编码之一进行转换，QString提供了&lt;code>fromLatin1()&lt;/code>、&lt;code>fromUtf8()&lt;/code>和&lt;code>fromLocal8Bit()&lt;/code>函数。其他编码可通过&lt;code>QTextCodec&lt;/code>类支持。&lt;/p>
&lt;p>如上文所述，QString提供了许多函数和运算符，使其与&lt;code>const char *&lt;/code>字符串的互操作变得容易。但这种功能是一把双刃剑：如果所有字符串都是US - ASCII或Latin - 1，它会使QString使用起来更方便，但始终存在从&lt;code>const char *&lt;/code>进行隐式转换或转换为&lt;code>const char *&lt;/code>时使用错误的8位编码的风险。为了最小化这些风险，你可以通过定义以下一些预处理器符号来关闭这些隐式转换：&lt;/p>
&lt;ul>
&lt;li>&lt;code>QT_NO_CAST_FROM_ASCII&lt;/code>禁用从C字符串字面量和指针到Unicode的自动转换。&lt;/li>
&lt;li>&lt;code>QT_RESTRICTED_CAST_FROM_ASCII&lt;/code>允许从C字符和字符数组进行自动转换，但禁用从字符指针到Unicode的自动转换。&lt;/li>
&lt;li>&lt;code>QT_NO_CAST_TO_ASCII&lt;/code>禁用从QString到C字符串的自动转换。&lt;/li>
&lt;/ul>
&lt;p>然后，你需要显式调用&lt;code>fromUtf8()&lt;/code>、&lt;code>fromLatin1()&lt;/code>或&lt;code>fromLocal8Bit()&lt;/code>从8位字符串构造QString，或者使用轻量级的&lt;code>QLatin1String&lt;/code>类，例如：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="n">QString&lt;/span> &lt;span class="n">url&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">QLatin1String&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;http://www.unicode.org/&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>同样，你必须显式调用&lt;code>toLatin1()&lt;/code>、&lt;code>toUtf8()&lt;/code>或&lt;code>toLocal8Bit()&lt;/code>将QString转换为8位字符串。（其他编码可通过&lt;code>QTextCodec&lt;/code>类支持。）&lt;/p>
&lt;h3 id="给c程序员的注意事项">给C程序员的注意事项
&lt;/h3>&lt;p>由于C++的类型系统以及QString是隐式共享的这一事实，QStrings可能会被当作&lt;code>int&lt;/code>或其他基本类型来对待。例如：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="n">QString&lt;/span> &lt;span class="n">Widget&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">boolToString&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">bool&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">QString&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;True&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;False&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>result&lt;/code>变量是一个在栈上分配的普通变量。当调用&lt;code>return&lt;/code>时，由于我们是按值返回，复制构造函数会被调用并返回字符串的一个副本。由于隐式共享，实际上并不会发生复制。&lt;/p>
&lt;h3 id="空字符串和null字符串的区别">空字符串和NULL字符串的区别
&lt;/h3>&lt;p>由于历史原因，QString区分空字符串和NULL字符串。NULL字符串是使用QString的默认构造函数或通过将&lt;code>(const char *)0&lt;/code>传递给构造函数初始化的字符串。空字符串是任何长度为0的字符串。NULL字符串总是空的，但空字符串不一定是NULL：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="n">QString&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="n">isNull&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="c1">// 返回true
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">QString&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="n">isEmpty&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="c1">// 返回true
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">QString&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="n">isNull&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="c1">// 返回false
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">QString&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="n">isEmpty&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="c1">// 返回true
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">QString&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;abc&amp;#34;&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="n">isNull&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="c1">// 返回false
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">QString&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;abc&amp;#34;&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="n">isEmpty&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="c1">// 返回false
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>除了&lt;code>isNull()&lt;/code>函数外，所有函数都将NULL字符串与空字符串同等对待。例如，&lt;code>toUtf8().constData()&lt;/code>会为NULL字符串返回一个指向&lt;code>'\0'&lt;/code>字符的有效指针（不是&lt;code>nullptr&lt;/code> ）。我们建议始终使用&lt;code>isEmpty()&lt;/code>函数并避免使用&lt;code>isNull()&lt;/code>。&lt;/p>
&lt;h3 id="参数格式">参数格式
&lt;/h3>&lt;p>在可以指定参数格式的成员函数（例如&lt;code>arg()&lt;/code>、&lt;code>number()&lt;/code> ）中，参数格式可以是以下之一：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>格式&lt;/th>
&lt;th>含义&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>e&lt;/code>&lt;/td>
&lt;td>格式化为`[-]9.9e[+&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>E&lt;/code>&lt;/td>
&lt;td>格式化为`[-]9.9E[+&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>f&lt;/code>&lt;/td>
&lt;td>格式化为&lt;code>[-]9.9&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>g&lt;/code>&lt;/td>
&lt;td>使用&lt;code>e&lt;/code>或&lt;code>f&lt;/code>格式，以更简洁者为准&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>G&lt;/code>&lt;/td>
&lt;td>使用&lt;code>E&lt;/code>或&lt;code>f&lt;/code>格式，以更简洁者为准&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>参数格式中还会指定精度。对于&lt;code>'e'&lt;/code>、&lt;code>'E'&lt;/code>和&lt;code>'f'&lt;/code>格式，精度表示小数点后的位数。对于&lt;code>'g'&lt;/code>和&lt;code>'G'&lt;/code>格式，精度表示最大有效位数（省略尾随零）。&lt;/p>
&lt;h3 id="更高效的字符串构建">更高效的字符串构建
&lt;/h3>&lt;p>许多字符串在编译时就已知。但是，简单的构造函数&lt;code>QString(&amp;quot;Hello&amp;quot;)&lt;/code>会将字符串内容视为Latin - 1并进行复制。为避免这种情况，可以使用&lt;code>QStringLiteral&lt;/code>宏在编译时直接创建所需的数据。这样，从字面量构造QString在运行时不会产生任何开销。&lt;/p>
&lt;p>一种效率稍低的方法是使用&lt;code>QLatin1String&lt;/code>。这个类包装一个C字符串字面量，在编译时预先计算其长度，因此与普通C字符串字面量相比，它可以更快地与QStrings进行比较并转换为QStrings。&lt;/p>
&lt;p>使用QString的&lt;code>+&lt;/code>运算符，可以轻松地从多个子字符串构造一个复杂的字符串。你可能经常编写这样的代码：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="n">QString&lt;/span> &lt;span class="n">foo&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">QString&lt;/span> &lt;span class="n">type&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;long&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">foo&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">setText&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">QLatin1String&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;vector&amp;lt;&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">type&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">QLatin1String&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;&amp;gt;::iterator&amp;#34;&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">foo&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">startsWith&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;(&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">type&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34;) 0x&amp;#34;&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这些字符串构造方式本身没有问题，但存在一些隐藏的低效之处。从Qt 4.6开始，可以消除这些问题。&lt;/p>
&lt;p>首先，多次使用&lt;code>+&lt;/code>运算符通常意味着多次内存分配。当连接n个子字符串（n &amp;gt; 2）时，可能会调用多达n - 1次内存分配器。&lt;/p>
&lt;p>在Qt 4.6中，添加了一个内部模板类&lt;code>QStringBuilder&lt;/code>以及一些辅助函数。这个类被标记为内部类，不会出现在文档中，因为不应该在代码中实例化它。它的使用是自动的，如下所述。如果你想查看它，可以在&lt;code>src/corelib/tools/qstringbuilder.cpp&lt;/code>中找到这个类。&lt;/p>
&lt;p>&lt;code>QStringBuilder&lt;/code>使用表达式模板并重新实现了&lt;code>%&lt;/code>运算符，因此当使用&lt;code>%&lt;/code>而不是&lt;code>+&lt;/code>进行字符串连接时，多个子字符串的连接将被推迟，直到最终结果即将分配给QString。此时，已知最终结果所需的内存量。然后调用一次内存分配器来获取所需的空间，并将子字符串逐个复制到其中。&lt;/p>
&lt;p>通过内联和减少引用计数（从&lt;code>QStringBuilder&lt;/code>创建的QString通常引用计数为1，而&lt;code>QString::append()&lt;/code>需要额外的测试），可以进一步提高效率。&lt;/p>
&lt;p>有两种方法可以使用这种改进的字符串构建方法。一种直接的方法是在需要使用的地方包含&lt;code>QStringBuilder&lt;/code>，并在连接字符串时使用&lt;code>%&lt;/code>运算符而不是&lt;code>+&lt;/code>运算符：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;QStringBuilder&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">QString&lt;/span> &lt;span class="nf">hello&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;hello&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">QStringRef&lt;/span> &lt;span class="nf">el&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">hello&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">QLatin1String&lt;/span> &lt;span class="nf">world&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;world&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">QString&lt;/span> &lt;span class="n">message&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">hello&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="n">el&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="n">world&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="n">QChar&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sc">&amp;#39;!&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>QStringBuilder类则通过表达式模板和重新实现%操作符来解决这一问题。它推迟子字符串的拼接，直到确定最终结果所需内存量后，再一次性分配内存并完成拼接，同时通过内联和减少引用计数进一步提升效率。&lt;/p>
&lt;p>另一种更全局的方法，也是最方便但并非完全源兼容的方法，是在.pro文件中进行如下定义：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">DEFINES *= QT_USE_QSTRINGBUILDER
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这样，+操作符在任何地方都会自动像QStringBuilder的%操作符一样工作。&lt;/p>
&lt;p>如果采用cmake来管理的话则添加&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">启用 QStringBuilder 优化
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">target_compile_definitions(my_app PRIVATE QT_USE_QSTRINGBUILDER)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="字符串编码问题">字符串编码问题
&lt;/h3>&lt;p>在使用vs运行qt程序遇到这样的问题&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// vs2019 界面显示为乱码
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// vs2022 直接在编译时报错：常量中有换行符
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">ui&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">label&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">setText&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;森林是否是发顺丰砍伐&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>问题的根源：&lt;strong>纯文本文件却不会记录自己采用的编码&lt;/strong>
比如我采用UTF8编码保存文件，用某软件打开时，并不知道该用什么编码方式去打开，只能靠猜。
以 GBK 编码文件在不同软件中的表现为例：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Linux 下的 gedit：
默认仅支持 UTF-8，打开 GBK 文件会显示乱码。需通过修改 gedit 配置，将 GBK 添加到自动检测列表。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Windows 记事本：
会优先尝试 UTF-8，失败后回退到本地编码（GBK），但此行为不稳定，可能误判为其他编码（如 ISO-8859-1）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>疑问：那如果我采用 UTF8 with BOM 呢？
BOM文件确实会通过文件头 EF BB BF 隐式声明编码，但此方式不被所有系统兼容。
VS编译器可以识别BOM文件，但是即使知道文件的编码方式，依然有问题。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span class="line">&lt;span class="cl">&lt;span class="o">//&lt;/span> &lt;span class="err">文件编码：&lt;/span>&lt;span class="n">UTF&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">8&lt;/span> &lt;span class="n">with&lt;/span> &lt;span class="n">BOM&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">const&lt;/span> &lt;span class="n">char&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="nb">str&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;我是汉字&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">//&lt;/span> &lt;span class="err">实际链路：&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">//&lt;/span> &lt;span class="mf">1.&lt;/span> &lt;span class="err">编译器按&lt;/span> &lt;span class="n">UTF&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">8&lt;/span> &lt;span class="err">解析源码&lt;/span> &lt;span class="err">→&lt;/span> &lt;span class="s2">&amp;#34;我是汉字&amp;#34;&lt;/span> &lt;span class="err">的&lt;/span> &lt;span class="n">UTF&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">8&lt;/span> &lt;span class="err">字节为&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mh">0xE6&lt;/span>&lt;span class="o">...&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">//&lt;/span> &lt;span class="mf">2.&lt;/span> &lt;span class="err">编译器将字符串隐式转码为本地编码（&lt;/span>&lt;span class="n">GBK&lt;/span>&lt;span class="err">）→&lt;/span> &lt;span class="err">字节变为&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mh">0xCE&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0xD2&lt;/span>&lt;span class="o">...&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">//&lt;/span> &lt;span class="err">结果：&lt;/span>&lt;span class="nb">str&lt;/span> &lt;span class="err">的内容是&lt;/span> &lt;span class="n">GBK&lt;/span> &lt;span class="err">编码，而非&lt;/span> &lt;span class="n">UTF&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">8&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>字符串常量会经过2次解析，原因在于 cl.exe 的 /execution-charset 默认值为本地代码页（如 GBK），导致 char* 字符串最终被转码为 GBK。&lt;/p>
&lt;p>GBK编码下的 const char * str = &amp;ldquo;我是汉字&amp;rdquo;
等价于
const char * str = &amp;ldquo;\xce\xd2\xca\xc7\xba\xba\xd7\xd6&amp;rdquo;;&lt;/p>
&lt;p>前文提到，QString 默认选择Latin-1，\xce\xd2\xca\xc7\xba\xba\xd7\xd6则会被当作Latin-1编码，再转为unicode，所以最后显示为乱码。&lt;/p>
&lt;p>&lt;strong>解决方式&lt;/strong>：核心是要告诉 QString 你的str是何种编码&lt;/p>
&lt;p>场景：UTF-8 with BOM文件，之前出错的原因是因为字符串常量会经过2次解析，我们可以使用QStringLiteral 跳过第2次解析。（这个适合静态字符串，即已经确定字符串的内容）
&lt;img src="https://sfw003.github.io/p/qt-core_02_container_and_algorithm/image/c2b2ca422f4c496f819f7a7917d1d18c.png"
width="816"
height="183"
srcset="https://sfw003.github.io/p/qt-core_02_container_and_algorithm/image/c2b2ca422f4c496f819f7a7917d1d18c_hu_2f7e5156029d3a2b.png 480w, https://sfw003.github.io/p/qt-core_02_container_and_algorithm/image/c2b2ca422f4c496f819f7a7917d1d18c_hu_da54049174d2bd38.png 1024w"
loading="lazy"
alt="在这里插入图片描述"
class="gallery-image"
data-flex-grow="445"
data-flex-basis="1070px"
>&lt;/p>
&lt;blockquote>
&lt;p>如果文件为UTF-8编码，没有BOM，上面操作则会出问题，因为没有bom，编译器不知道文件的编码方式，只能采用默认的。因此为了统一，可以开启vs编译器的 /utf8选项，此时编译器会默认采用utf-8来解码。
&lt;img src="https://sfw003.github.io/p/qt-core_02_container_and_algorithm/image/f977b34a5c044b1bb1ed9f3902b7e6e5.png"
width="818"
height="549"
srcset="https://sfw003.github.io/p/qt-core_02_container_and_algorithm/image/f977b34a5c044b1bb1ed9f3902b7e6e5_hu_d90e679978986967.png 480w, https://sfw003.github.io/p/qt-core_02_container_and_algorithm/image/f977b34a5c044b1bb1ed9f3902b7e6e5_hu_3806e7e177565f71.png 1024w"
loading="lazy"
alt="在这里插入图片描述"
class="gallery-image"
data-flex-grow="148"
data-flex-basis="357px"
>&lt;/p>&lt;/blockquote>
&lt;p>如果需要动态转换，参考&lt;strong>在8位字符串和Unicode字符串之间转换&lt;/strong>章节&lt;/p>
&lt;h2 id="其他">其他
&lt;/h2>&lt;p>QList， QVector， QMap等等，这些去看一下成员函数，就知道如何使用了。&lt;/p>
&lt;h3 id="qvariant">QVariant
&lt;/h3>&lt;p>Qt 的容器类，我个人认为最重点的就是QString和QVariant。&lt;/p>
&lt;p>QVariant类类似于C++的联合（union）数据类型，它不仅能够保存很多Qt类型的值，包括QColor、QBrush、QFont、QPen、QRect、QString和QSize等，也能够存放Qt的容器类型的值。Qt的很多功能都是建立在QVariant基础上的，如Qt的对象属性及数据库功能等。&lt;/p>
&lt;p>之后再写&lt;/p></description></item><item><title>【Qt Core 03】事件机制</title><link>https://sfw003.github.io/p/qt-core_03_event_mechanism/</link><pubDate>Wed, 02 Apr 2025 00:00:00 +0000</pubDate><guid>https://sfw003.github.io/p/qt-core_03_event_mechanism/</guid><description>&lt;blockquote>
&lt;p>以下内容基于Qt 5.15 LTS 官方文档整理&lt;/p>&lt;/blockquote>
&lt;h2 id="事件驱动">事件驱动
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>事件&lt;/strong>：事件是用户和应用软件间产生的一个交互操作，由用户操作产生或者系统内部产生，通过事件循环对事件进行处理，事件也可以用来在对象间进行信息交互。&lt;/li>
&lt;li>&lt;strong>事件驱动架构&lt;/strong>(Event-Driven Architecture)是一种用于设计应用的软件架构和模型，程序的执行流由外部事件来决定
&lt;ul>
&lt;li>&lt;strong>事件队列&lt;/strong>(event queue)：接收事件的入口，存储待处理事件&lt;/li>
&lt;li>&lt;strong>分发器&lt;/strong>(event mediator)：将不同的事件分发到不同的业务逻辑单元&lt;/li>
&lt;li>&lt;strong>事件通道&lt;/strong>(event channel)：分发器与处理器之间的联系渠道&lt;/li>
&lt;li>&lt;strong>事件处理器&lt;/strong>(event processor)：实现业务逻辑，处理完成后会发出事件，触发下一步操作&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://sfw003.github.io/p/qt-core_03_event_mechanism/image/bd25449331d44030a8f9dff0997be04d.png"
width="832"
height="620"
srcset="https://sfw003.github.io/p/qt-core_03_event_mechanism/image/bd25449331d44030a8f9dff0997be04d_hu_db7c373c7b076c1e.png 480w, https://sfw003.github.io/p/qt-core_03_event_mechanism/image/bd25449331d44030a8f9dff0997be04d_hu_59adb75df97c02c3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="134"
data-flex-basis="322px"
>
事件驱动模型的特点:&lt;/p>
&lt;ul>
&lt;li>可维护性高：事件驱动模型使得应用程序的代码结构更加清晰，并且易于维护和调试。每个事件都有相应的处理函数，使得代码更加模块化&lt;/li>
&lt;li>可扩展性强：采用事件驱动模型可以方便地添加新的事件处理函数，并且可以轻松地扩展应用程序的功能。&lt;/li>
&lt;li>并发性好：事件驱动模型可以方便管理多个事件，并且可以在处理事件时执行异步操作,使得应用程序具有更好的并发性&lt;/li>
&lt;li>可移植性好：采用事件驱动模型可以使应用程序更容易地在不同的操作系统和平台上移植，从而提高了应用程序的可移植性。&lt;/li>
&lt;/ul>
&lt;h2 id="qt事件框架">Qt事件框架
&lt;/h2>&lt;p>&lt;img src="https://sfw003.github.io/p/qt-core_03_event_mechanism/image/ad63b1a1f0f54603aaf7cf9777720e0f.png"
width="1112"
height="339"
srcset="https://sfw003.github.io/p/qt-core_03_event_mechanism/image/ad63b1a1f0f54603aaf7cf9777720e0f_hu_6a54b5e5c5499332.png 480w, https://sfw003.github.io/p/qt-core_03_event_mechanism/image/ad63b1a1f0f54603aaf7cf9777720e0f_hu_df942e58c7580822.png 1024w"
loading="lazy"
alt=" "
class="gallery-image"
data-flex-grow="328"
data-flex-basis="787px"
>&lt;/p>
&lt;ul>
&lt;li>用户操作与 GUI 应用程序交互之后,系统内核获取用户动作，产生 OS 消息&lt;/li>
&lt;li>系统内核会将 OS 消息传递给 Qt 事件处理框架,会转换 事件对象 QEvent,并讲转换后的事件发送给QObject。&lt;/li>
&lt;li>QObject 调用 QObject::event 函数来接收事件，并分发，默认是在当前调用该事件的组件对象接收，若是该组件对象不做任何操作，则可以转给它的父对象来接收。最后会按照事件类型来调用不同的事件处理函数&lt;/li>
&lt;li>调用 事件处理函数,在事件处理函数中可进行信号的发送&lt;/li>
&lt;li>调用 槽函数(信号需要与槽函数进行关联)&lt;/li>
&lt;/ul>
&lt;h2 id="自定义事件处理">自定义事件处理
&lt;/h2>&lt;p>Qt 用户自定义处理事件方式&lt;/p>
&lt;p>按照 Qt 事件处理流程,用户自定义处理事件方式如下:&lt;/p>
&lt;ul>
&lt;li>重写特定事件函数mousePressEvent()，keyPressEvent()，paintEvent()&lt;/li>
&lt;li>重写实现 Q0bject::event0&lt;/li>
&lt;li>安装事件过滤器&lt;/li>
&lt;li>在 QApplication 上安装事件过滤器&lt;/li>
&lt;li>重新实现 QApplication 的 notify()方法&lt;/li>
&lt;/ul>
&lt;p>在实际应用的过程中,采用 重写特定事件函数 和 安装事件过滤器 的方式居多
&lt;img src="https://sfw003.github.io/p/qt-core_03_event_mechanism/image/1866ba96870f4feb84a0b0fecf9beb8b.png"
width="1149"
height="184"
srcset="https://sfw003.github.io/p/qt-core_03_event_mechanism/image/1866ba96870f4feb84a0b0fecf9beb8b_hu_8883731b8f9b4f58.png 480w, https://sfw003.github.io/p/qt-core_03_event_mechanism/image/1866ba96870f4feb84a0b0fecf9beb8b_hu_a7fccc7ba0325f28.png 1024w"
loading="lazy"
alt=" "
class="gallery-image"
data-flex-grow="624"
data-flex-basis="1498px"
>
其实还有一种方式：自定义事件（继承 QEvent 并发送）
原理：应用程序可通过QCoreApplication::sendEvent()和QCoreApplication::postEvent()发送自定义事件。sendEvent()会立即处理事件，返回时事件已被处理；postEvent()将事件放入队列，在 Qt 主事件循环下次运行时进行调度，且会对一些事件（如多个resize事件、paint事件）进行优化。在对象初始化期间常使用postEvent()，因为对象初始化完成后事件通常会很快被调度。创建自定义事件时，需定义大于QEvent::User的事件编号，可能还需子类化QEvent来传递特定信息。&lt;/p>
&lt;h3 id="重写特定事件函数">重写特定事件函数
&lt;/h3>&lt;p>重写特定事件函数是最常用的自定义事件处理方式，下面是案例&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="n">CustomButton&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">mousePressEvent&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">QMouseEvent&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 自定义处理
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">event&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">button&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">Qt&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">LeftButton&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// handle left mouse button here
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">QPushButton&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">mousePressEvent&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="c1">// 调用父类的 mousePressEvent 函数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里有1点注意：&lt;strong>在结束时需要调用父类的事件处理函数，如果是故意不写，也应该加上注释&lt;/strong>&lt;/p>
&lt;p>如果不加，会导致事件传播链中断：
Qt 的事件处理机制中，若子类重写事件函数后未调用父类实现，相当于隐式调用了 event-&amp;gt;accept()，事件将停止传播。这可能导致父组件或上层逻辑无法响应事件。
示例：若按钮被放置在父窗口的特定区域，父窗口可能依赖于事件传播实现拖拽等功能，但事件被截断后这些功能将失效。&lt;/p>
&lt;p>&lt;strong>qt的事件忽略&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="n">QEvent&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">ignore&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">// 表示当前对象忽略事件，该事件会继续传递给父对象
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="n">QEvent&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">accept&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">// 表示事件在当前对象中已经处理，不会继续传递到父对象
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://sfw003.github.io/p/qt-core_03_event_mechanism/image/e218c3f678d04129a71485d7e06e6d49.png"
width="662"
height="318"
srcset="https://sfw003.github.io/p/qt-core_03_event_mechanism/image/e218c3f678d04129a71485d7e06e6d49_hu_45a95566262ea11f.png 480w, https://sfw003.github.io/p/qt-core_03_event_mechanism/image/e218c3f678d04129a71485d7e06e6d49_hu_35e352203f1ece67.png 1024w"
loading="lazy"
alt=" "
class="gallery-image"
data-flex-grow="208"
data-flex-basis="499px"
>&lt;/p>
&lt;h3 id="qt的事件过滤器">Qt的事件过滤器
&lt;/h3>&lt;ul>
&lt;li>Qt事件过滤器是一种机制，用于在Qt应用程序中拦截、处理和转发事件。&lt;/li>
&lt;li>事件过滤器的作用是在 目标对象接收事件之前，对事件进行拦截和处理。&lt;/li>
&lt;li>通过安装事件过滤器，可以对目标对象的事件进行修改、过滤、转发或者记录，这样可以很方便地实现一些自定义的功能。&lt;/li>
&lt;li>事件过滤器的优点是可以在不修改目标对象的代码的情况下，对其进行功能扩充&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://sfw003.github.io/p/qt-core_03_event_mechanism/image/d8a6ddf1d755433ab28f9ec047334b4a.png"
width="767"
height="240"
srcset="https://sfw003.github.io/p/qt-core_03_event_mechanism/image/d8a6ddf1d755433ab28f9ec047334b4a_hu_76da61c1baf04ad3.png 480w, https://sfw003.github.io/p/qt-core_03_event_mechanism/image/d8a6ddf1d755433ab28f9ec047334b4a_hu_abe63253d6f8c452.png 1024w"
loading="lazy"
alt=" "
class="gallery-image"
data-flex-grow="319"
data-flex-basis="767px"
>&lt;/p>
&lt;p>事件过滤器的使用&lt;/p>
&lt;ol>
&lt;li>给目标对象安装过滤器,这里调用 installEventFilter 函数&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="n">ui&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">textEdit&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">installEventFilter&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 在父窗口中监控textEdit的事件[1](@ref)
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol start="3">
&lt;li>在事件过滤器对象中实现事件过滤器逻辑，这里需要重写 eventFilter 函数&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">bool&lt;/span> &lt;span class="n">Widget&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">eventFilter&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">QObject&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">obj&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">QEvent&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">event&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">obj&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">ui&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">textEdit&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">event&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">type&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">QEvent&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">Wheel&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 拦截滚轮事件，阻止传递
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nb">true&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 其他事件交给默认处理
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">QWidget&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">eventFilter&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">obj&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">event&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//return true：事件被拦截，不再传递给目标对象。
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//return false：事件继续传递至目标对象或其父类
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 自定义过滤器类
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">class&lt;/span> &lt;span class="nc">KeyMouseFilter&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="k">public&lt;/span> &lt;span class="n">QObject&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">protected&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">bool&lt;/span> &lt;span class="n">eventFilter&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">QObject&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">obj&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">QEvent&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">event&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">override&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">event&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">type&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">QEvent&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">KeyPress&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">QKeyEvent&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">keyEvent&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">static_cast&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">QKeyEvent&lt;/span>&lt;span class="o">*&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">event&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">qDebug&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;Key pressed:&amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">keyEvent&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nb">true&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 拦截按键
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span> &lt;span class="nf">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">event&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">type&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">QEvent&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">MouseButtonPress&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">qDebug&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;Mouse clicked on&amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">obj&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">objectName&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nb">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 安装到控件
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">KeyMouseFilter&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">filter&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">KeyMouseFilter&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">ui&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">lineEdit&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">installEventFilter&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">filter&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item></channel></rss>