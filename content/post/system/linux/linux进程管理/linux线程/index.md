---
title: "Linux 线程"
description: "Linux 线程"
date: 2025-04-03
slug: "linux-thread"
categories:
    - linux
tags:
    - linux线程
---









## 线程与TCB

>线程（Thread）是进程内的一个执行分支，线程的执行粒度，要比进程更细。

如何理解？

![image-20250410164313828](image/image-20250410164313828.png)



### linux下的线程与pthread库

**linux没有真正意义的线程**，这在很多教材都提过的观点。究其原因，就如上图所示，让n个PCB来管理一个进程地址空间不就有了线程了。区别windows系统专门设置了TCB结构体，linux选择用PCB来模拟TCB，因此linux可以说没有真正意义的线程，而是叫做**轻量级进程**。



你linux搞特殊是吧？我想使用线程，你告诉我说让我使用轻量级进程。这让用户满意吗？于是linux封装了一个库 **pthread**，让用户可以使用到**用户级线程**，并不能叫做**内核级线程**，因为在linux内核中只有轻量级进程。可以通过下图来理解：

![在这里插入图片描述](image/f99a74ee3b55fc2c2ab61eae415b29a7.png)

注：

- 轻量级进程:用户级线程 = 1:1
- 用户使用到的TCB结构体并不在内核空间中。



上图中出现了2个名词：线程栈和线程局部存储

#### 线程栈

每一个线程都有自己的调用链，注定了每个线程都要有调用链对应的栈帧结构，用来存储线程函数中的局部变量、函数参数以及函数调用的返回地址等信息。这一点类似进程的main函数的函数栈帧。这里的线程栈由pthread来维护，有了线程栈，才能在内核里创建执行流，有了新的执行流，才是一个真正的线程。

> pthread是如何创建线程栈？
>
> inux下只有轻量级进程的概念，自然linux会提供轻量级进程的接口，pthread库正是对轻量级进程的接口进行了封装，才在用户层创建了线程的概念。
>
> linux下创建轻量级进程的系统接口是clone
>
> ![在这里插入图片描述](image/4172bee3ea61ac55cc7cf5ad25794b62.png)



#### 线程的局部存储





## pthread库的使用



## 线程互斥



### 相关概念
- 共享资源：多个线程之间可以**并发**访问的资源。
- 临界资源：多个线程**互斥**访问的共享资源。（共享资源 && 同一时间只能由一个线程访问）
- 临界区：每个线程内部，访问临界资源的代码，就叫做临界区
- 互斥：任何时刻，互斥保证有且只有一个执行流进入临界区，访问临界资源，通常对临界资源起保护作用
- 原子性：不会被任何调度机制打断的操作，该操作只有两态，要么完成，要么未完成







### 互斥锁

```
lock:
        movb $0, %al
        xchgb %al, mutex
        if(al寄存器的内容〉0) {
        	return 0;
        } else
	        挂起等待;
        goto lock;
unlock:
		movb $l,mutex
		唤醒等待Mutex的线程；
		return 0;
```

<img src="image/efdc12726f6487bd1c677f9e9ae7e1c1.gif" alt="请添加图片描述" style="zoom:150%;" />



## 线程同步



