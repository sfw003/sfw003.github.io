[{"content":"网站概览 ","date":"2025-04-12T00:00:00Z","permalink":"https://sfw003.github.io/p/blog-overview/","title":"网站内容概述"},{"content":"数据结构和算法系列，在个人的gitee仓库 数据结构和算法\n","date":"2025-04-13T00:00:00Z","permalink":"https://sfw003.github.io/p/data-structures-and-algorithms/","title":"数据结构与算法"},{"content":"系列介绍 本系列文章将带您从零开始学习 C++ 开发，涵盖从基础概念到高级应用的各个方面。无论您是编程新手还是有一定经验的开发者，都能在这里找到适合自己的学习路径。\n文章列表 C++ 标准 绘图文件，在c++标准.drawio\nC++ 编译和链接 - C++ 编译和链接 ","date":"2025-04-12T00:00:00Z","permalink":"https://sfw003.github.io/p/c-series/","title":"C++ 开发系列"},{"content":"系列介绍 本系列文章将带您从零开始学习软件工程，涵盖从基础概念到高级应用的各个方面。无论您是编程新手还是有一定经验的开发者，都能在这里找到适合自己的学习路径。\n文章列表 软件工程 需求 设计 测试 运维 ","date":"2025-04-12T00:00:00Z","permalink":"https://sfw003.github.io/p/soft-project-series/","title":"软件工程系列文章"},{"content":"笔者想建立自己的后端技能树，以并发量的增长为线索，构建后端开发技能树。\n单机架构 这里先介绍单机架构是什么？\n基础 刚开始，需要做一个简单的服务器，因此首要任务是做出一个简单的服务器。\n技能：\n网络编程: 使用socket编程, 熟悉TCP/IP协议, 熟悉HTTP/HTTPS协议 数据库: 看懂sql语句，知道如何使用语言的api操作数据库 测试： 知道如何进行单元测试、集成测试、压力测试 运维： 知道如何部署服务器，如何配置服务器，如何监控服务器 进阶 由于经济条件不允许，只能使用一台服务器，现在并发量增长，如何对一台服务器进行优化，提高并发量？\n技能：\n多线程： 熟悉多线程编程，熟悉线程池，熟悉线程安全 高级IO（IO多路复用, 异步IO, 零拷贝） 高性能网络模式（Reactor, Proactor） 数据库：索引优化 应用数据分离架构 应用服务集群架构 我们的系统受到了用户的欢迎，并且出现了爆款，单台应用服务器已经无法满足需求了。我们的单机应用服务器首先遇到了瓶颈，摆在我们技术团队面前的有两种方案，大家针对方案的优劣展示了热烈的讨论：\n垂直扩展/纵向扩展ScaleUp。通过购买性能更优、价格更高的应用服务器来应对更多的流量。这种方案的优势在于完全不需要对系统软件做任何的调整；但劣势也很明显：硬件性能和价格的增长关系是非线性的，意味着选择性能2倍的硬件可能需要花费超过4倍的价格，其次硬件性能提升是有明显上限的。\n水平扩展/横向扩展ScaleOut。通过调整软件架构，增加应用层硬件，将用户流量分担到不同的应用层服务器上，来提升系统的承载能力。这种方案的优势在于成本相对较低，并且提升的上限空间也很大。但劣势是带给系统更多的复杂性，需要技术团队有更丰富的经验。\n如果采用水平扩展，技能要求：负载均衡\n负载均衡： 熟悉负载均衡的原理，熟悉负载均衡的算法，熟悉负载均衡的实现 服务注册与发现：etcd 集群间通信：grpc， protobuf 配置中心 会话管理：由session管理变为token管理 发布策略 灰度发布（金丝雀发布） 蓝绿发布 滚动发布 版本控制 自动化发布 回滚机制 读写分离/主从分离架构 随着访问量继续增加，发现业务中一些数据的读取频率远大于其他数据的读取频率。我们把这部分数据称为热点数据，与之相对应的是冷数据。针对热数据，为了提升其读取的响应时间，可以增加本地缓存，并在外部增加分布式缓存，缓存热门商品信息或热门商品的html页面等。通过缓存能把绝大多数请求在读写数据库前拦截掉，大大降低数据库压力。其中涉及的技术包括：使用memcached作为本地缓存，使用Redis作为分布式缓存，还会涉及缓存一致性、缓存穿透/击穿、缓存雪崩、热点数据集中失效等问题。\n技能：引入缓存\nredis: 熟悉redis的api，熟悉redis的持久化，熟悉redis的集群 缓存一致性： 熟悉缓存一致性问题，熟悉缓存穿透/击穿、缓存雪崩、热点数据集中失效等问题 冷热分离架构 微服务架构 ","date":"2025-04-04T00:00:00Z","permalink":"https://sfw003.github.io/p/backend-development-series/","title":"后端开发系列"},{"content":"文章列表 Linux 常用命令 Linux进程管理 绘制文件：linux进程管理.drawio\nLinux 进程 - Linux 进程管理 Linux 进程间通信 - Linux 进程间通信 Linux 文件系统 ","date":"2025-04-03T00:00:00Z","permalink":"https://sfw003.github.io/p/linux-series/","title":"Linux 系统系列文章"},{"content":"系列介绍 本系列文章将带您从零开始学习 Qt 开发，涵盖从基础概念到高级应用的各个方面。无论您是编程新手还是有一定经验的开发者，都能在这里找到适合自己的学习路径。\n绘图文件，在qt.drawio\n文章列表 Qt 环境搭建 Qt 的安装与环境配置 - 搭建 Qt 开发环境 Qt Core Qt Core 02 容器类和算法 - Qt 核心概念与基础功能 Qt Core 03 事件机制 - 事件机制 Qt GUI Qt GUI 01 Qt 绘图框架 - Qt 绘图框架 Qt Widgets 资源推荐 Qt 官方文档 Qt 示例程序 Qt 论坛 Qt 中文社区 更新计划 本系列文章会持续更新，计划包含以下内容：\nQt 网络编程 Qt 数据库操作 Qt 项目实战 欢迎关注本系列文章的更新，也欢迎在评论区提出建议和问题。\n","date":"2025-04-02T00:00:00Z","permalink":"https://sfw003.github.io/p/qt-series/","title":"Qt 开发系列"},{"content":"存放个人项目\n","date":"2025-04-01T00:00:00Z","permalink":"https://sfw003.github.io/p/project-dic/","title":"个人项目"},{"content":"C++11简介 在2003年C++标准委员会曾经提交了一份技术勘误表(简称TC1)，使得C++03这个名字已经取代了C++98称为C++11之前的最新C++标准名称。不过由于C++03(TC1)主要是对C++98标准中的漏洞进行修复，语言的核心部分则没有改动，因此人们习惯性的把两个标准合并称为C++98/03标准。从C++0x到C++11，C++标准10年磨一剑，第二个真正意义上的标准珊珊来迟。相比于C++98/03，C++11则带来了数量可观的变化，其中包含了约140个新特性，以及对C++03标准中约600个缺陷的修正，这使得C++11更像是从C++98/03中孕育出的一种新语言。相比较而言C++11能更好地用于系统开发和库开发、语法更加泛华和简单化、更加稳定和安全，不仅功能更强大，而且能提升程序员的开发效率，公司实际项目开发中也用得比较多，所以我们要作为一个重点去学习。C++11增加的语法特性非常篇幅非常多，这里挑重点介绍。\n面试常问：你了解c++11的新特性吗？说一下你的看法\n回答思路：\n首先说一下有哪些新特性 然后再问面试官需要详细说说哪些特性 统一的初始化列表 {}初始化 在C++98中，标准允许使用花括号{}对数组或者结构体元素进行统一的列表初始值设定。比如\n1 2 3 4 5 6 7 8 9 10 11 12 struct Point { int _x; int _y; }; int main() { int array1[] = {1, 2, 3, 4, 5}; int array2[5] = {0}; Point p = {1, 2}; return 0; } C++11扩大了用大括号括起的列表(初始化列表)的使用范围，使其可用于所有的内置类型和用户自定义的类型，使用初始化列表时，可添加等号(=)，也可不添加。、\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Date { public: Date(int year, int month, int day) : _year(year), _month(month), _day(day) { cout \u0026lt;\u0026lt; \u0026#34;Date(int year, int month, int day)\u0026#34; \u0026lt;\u0026lt; endl; } private: int _year; int _month; int _day; } struct Point { int _x; int _y; }; int main() { int x1 = 1; int x2{2}; int array1[]{1, 2, 3, 4, 5}; int array2[5]{0}; Point p{1, 2}; // C++11中列表初始化也可以适用于new表达式中 int *pa = new int[4]{0}; Date d1(2022, 1, 1); // C++11支持的列表初始化，这里会调用构造函数初始化 Date d2{2022, 1, 2}; Date d3 = {2022, 1, 3}; return 0; } 记录一个事例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Test { public: Test(int* p) {} }; int main() { int* start = new int(); *start = 1; Test(start); //我想创建一个匿名对象, 但是编译器认为这可能是一个函数声明 Test t(start);//true Test{ start };//true } std::initializer_list std::initializer_list 是 C++11 中的一个特性，它允许你使用花括号 {} 中的值列表来初始化容器或数组。通常用于初始化标准库容器，比如 std::list、std::vector、std::set、std::map 以及数组， 也可以用于包含容器成员的自定义类。 当使用花括号初始化语法时，编译器会生成一个 std::initializer_list 对象。这个对象内部实际上包含两个指针：一个指向数组（或类似数组的结构）的开始位置，另一个指向结束位置（即下一个元素的起始位置，但不包括该位置）。\n1 2 3 4 5 6 7 8 9 10 int main() { vector\u0026lt;int\u0026gt; v = { 1,2,3,4 }; list\u0026lt;int\u0026gt; lt = { 1,2 }; // 这里{\u0026#34;sort\u0026#34;, \u0026#34;排序\u0026#34;}会先初始化构造一个pair对象 map\u0026lt;string, string\u0026gt; dict = { {\u0026#34;sort\u0026#34;, \u0026#34;排序\u0026#34;}, {\u0026#34;insert\u0026#34;, \u0026#34;插入\u0026#34;} }; // 使用大括号对容器赋值 v = {10, 20, 30}; return 0; } C++11关键字 auto 在C++98中auto是一个存储类型的说明符，表明变量是局部自动存储类型，但是局部域中定义局部的变量默认就是自动存储类型，所以auto就没什么价值了。C++11中废奔auto原来的用法，将其用于实现自动类型腿断。这样要求必须进行显示初始化，让编译器将定义对象的类型设置为初始化值的类型。\n1 2 3 auto n = 10; //auto 为int auto f = 12.8; //auto 为double auto p = \u0026amp;n;\t//auto 为int* auto的特殊情况：\nauto 不能在函数的参数中使用。\n作用于类的成员变量,auto 不能作用于类的非静态成员变量。\nauto 关键字不能定义数组\nauto不能用于模板\nvector\u0026lt;bool\u0026gt;\n1 2 3 4 5 6 int main() { std::vector\u0026lt;bool\u0026gt; vec{0,1,1,1,0}; bool var = vec[3]; auto var2 = vec[3]; return 0; } std::vector\u0026lt;bool\u0026gt; 的特殊性\n位压缩：std::vector\u0026lt;bool\u0026gt; 是一个特例，它使用位（bit）而不是字节（byte）来存储布尔值。这是为了节省内存，但它也意味着对 std::vector\u0026lt;bool\u0026gt; 的访问与常规向量有所不同。 代理对象：访问 std::vector\u0026lt;bool\u0026gt; 中的元素（例如 vec[3]）返回一个临时的代理对象，而不是普通的 bool 值。这是一个特殊的代理类型，用于提供对底层位的访问。它实际上并不是 bool 的引用。 decltype decltype 是 C++11 新增的一个关键字，它和 auto 的功能一样，都用来在编译时期进行自动类型推导。它是declare type的缩写，主要功能用来声明类型auto并不适合于所有自动推导的类型，并且auto的使用必须要初始化变量。而特殊的情况可能无法满足。declart type就可以解决这个问题。它可以在编译的时候推导出一个表达式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 int val = 10; //auto根据val的类型类推导，必须初始化 auto varName = val; --------------------------------------------- //decltype是根据exp表达式推导，可以不用初始化 decltype(exp) varname; int a = 0; decltype(a) b = 1; //b被推导成int decltype(10.8) x = 5.5; //x被推导成double decltype(x + 100) y; //b被推导成double 使用场景：模板泛型编程 //auto + decltype结合实现返回值类型后置 template\u0026lt;typename T1, typename T2\u0026gt; auto add(const T1\u0026amp; t1, const T2\u0026amp; t2) -\u0026gt; decltype(t1 + t2) { return t1 + t2; } template \u0026lt;typename T1, typename T2\u0026gt; auto mul(const T1\u0026amp; t1, const T2\u0026amp; t2) -\u0026gt; decltype(t1* t2) { return t1 * t2; } int main() { auto a = 3; auto b = 4.0; auto c = 3.14; auto d = mul(add(a, b), d); cout \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; // 21.98 } using 在老版的C++中using用于声明域名空间。在C++11中C++赋予了using更多新的功能，让C++变得更加灵活。\nC++中提供了using也有了重新定义类型别名的方式。\n1 2 3 4 5 6 7 8 9 10 11 C++98: typedef 旧的类型名 新的类型; //使用例子： typedef unsigned int uint_t; typedef int (*funp)(int ,int); C++11 using 新的类型 = 旧的类型 //例子: using uint_t = int; using funp = int (*)(int,int); 优点：\nusing可以给模板类重定义，但是typedef无法使用此功能。 using更清晰 nullptr nullptr是为了替换NULL而发明出来的。nullptr的类型为std::nullptr_t,而NULL的类型为int，可以防止一些类型转化导致的问题。如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;iostream\u0026gt; using namespace std; void funTest(char* p) { cout \u0026lt;\u0026lt; \u0026#34;void fun(char *p)\u0026#34; \u0026lt;\u0026lt; endl; } void funTest(int p) { cout \u0026lt;\u0026lt; \u0026#34;void fun(int p)\u0026#34; \u0026lt;\u0026lt; endl; } int main() { funTest(NULL); funTest(nullptr); funTest(200); return 0; } 结果： void fun(int p) void fun(char *p) void fun(int p) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //NULL底层实现 #ifndef NULL #ifdef __cplusplus #define NULL 0 #else #define NULL ((void *)0) #endif #endif //模拟nullptr底层实现（非官方) const /*常量*/ class nullptr_t { public: template\u0026lt;class T\u0026gt; operator T*() const /*向任意类的非成员指针转换*/ { return 0; } template\u0026lt;class C,class T\u0026gt; operator T C::*() const /*向任意类型的成员指针转换*/ { return 0; } private: void operator\u0026amp;() const /*不可取地址*/ { } }nullptr = {}; default 用于生产默认的成员函数\n1 2 3 4 5 6 class A { public: A() = default; A\u0026amp; operator=(const A\u0026amp;) = default; }; delete 禁止生成默认的成员函数\n1 2 3 4 5 class A { public: A(const A\u0026amp;) = delete; //禁止生成拷贝构造 }; orride c++11新增：用于明确指示派生类中的成员函数是对基类中的虚函数的重写。若没有对虚函数重写，会提示错误。一般子类写了override，就不用加virtual了。\n1 2 3 4 5 6 7 8 9 10 class A { public: virtual void test() {}; }; class B:pulic A { public: void test() orride {}; //如果没实现，就报错 }; final c++11新增：用于标记虚函数，表示该函数不能在派生类中再次被重写。\n1 2 3 4 5 6 7 8 9 10 class A { public: virtual void test() final{}; }; class B:pulic A { public: virtual void test() {}; //如果实现，就报错 }; explicit c++11新增，禁止隐式类型转换\n1 2 3 4 比如智能指针不允许将原始指针赋值给 std::shared_ptr shared_ptr\u0026lt;int\u0026gt; p(new int); shared_ptr\u0026lt;int\u0026gt; p = new int; //false 原因是shared_ptr构造函数使用了explicit.对于 std::shared_ptr 来说，如果其构造函数不带 explicit，那么像 std::shared_ptr\u0026lt;int\u0026gt; mp = new int; 这样的赋值就会被允许，编译器会尝试隐式将 int* 类型转换为 std::shared_ptr\u0026lt;int\u0026gt;。 constexpr (重要) constexpr 是 C++11 引入的关键字，用于指定表达式在编译时求值。它允许在编译期对常量表达式进行计算，从而提高程序效率，并增加编译时类型检查的可能性。\n1 2 3 4 5 6 7 8 9 10 11 12 constexpr int Square(int x) { return x * x; } int main() { constexpr int result = Square(10); // 编译期计算 int y = 5; int runtimeResult = Square(y); // 运行期计算 constexpr int z = 5; constexpr int runtimeResult = Square(z); // 编译期计算 } Square(10) 被编译期求值，而 Square(y) 则在运行时求值，因为 y 是运行时变量。\n右值引用 * 左值和右值：左值可以出现赋值符号的左边，右值不能出现在赋值符号左边\n1 2 3 4 5 6 7 8 9 10 // 以下几个都是左值 int* p = new int(0); int b = 1; const int c = 2; // 以下几个都是常见的右值 纯右值：非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和 lambda 表达式等 将亡值：与右值引用相关的表达式，比如，T\u0026amp;\u0026amp; 类型函数的返回值、 std::move 的返回值等。 10; x + y; fmin(x, y); C++98/03 标准中就有引用，使用 \u0026ldquo;\u0026amp;\u0026rdquo; 表示。但此种引用方式有一个缺陷，即正常情况下只能操作 C++ 中的左值，无法对右值添加引用。虽然 C++98/03 标准不支持为右值建立非常量左值引用，但允许使用常量左值引用操作右值。也就是说，常量左值引用既可以操作左值，也可以操作右值.\n1 2 3 4 int a = 3; int\u0026amp; b = a; //true; int\u0026amp; c = 10;//false const int\u0026amp; d = 10; //true 左指引用的缺陷：当函数返回对象是一个局部变量，出了函数作用域就不存在了，就不能使用左值引用返回，只能传值返回，而传值返回至少存在1次拷贝构造。\n为此，C++11 标准新引入了另一种引用方式，称为右值引用，用 \u0026ldquo;\u0026amp;\u0026amp;\u0026rdquo; 表示。\n左值引用总结：\n左值引用只能引用左值，不能引用右值。\n但是const左值引用既可引用左值，也可引用右值\n1 2 3 4 5 6 7 8 9 10 11 int main() { // 左值引用只能引用左值，不能引用右值。 int a = 10; int\u0026amp; ra1 = a; // ra为a的别名 //int\u0026amp; ra2 = 10; // 编译失败，因为10是右值 // const左值引用既可引用左值，也可引用右值。 const int\u0026amp; ra3 = 10; const int\u0026amp; ra4 = a; return 0; } 右值引用总结：\n右值引用只能右值，不能引用左值。\n但是右值引用可以move以后的左值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 int main() { // 右值引用只能右值，不能引用左值。 int\u0026amp;\u0026amp; r1 = 10; // error C2440: “初始化”: 无法从“int”转换为“int \u0026amp;\u0026amp;” // message : 无法将左值绑定到右值引用 int a = 10; int\u0026amp;\u0026amp; r2 = a; //error // 右值引用可以引用move以后的左值 int\u0026amp;\u0026amp; r3 = std::move(a); return 0; } 完美转发 完美转发（Perfect Forwarding）是 C++11 引入的一种机制，它允许函数在调用其他函数时，能够完美保留传入参数的类型和值类别（左值或右值），并将其准确地传递给下一个函数。\n为什么要有完美转发？根本原因在于右值引用指向右值，但本身是左值，也就是说T\u0026amp;\u0026amp; t中，t指向右值，但t本身是左值。所以，如果不采用发转，不管传进来的是右值，经过右值引用也会变成左值，从而去调用左值函\n1 2 3 4 void print(T\u0026amp;\u0026amp; t) { t指向右值，但是t本身是左值 } std::forward 完美转发在传参的过程中保留对象原生类型属性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void Fun(int \u0026amp;x){ cout \u0026lt;\u0026lt; \u0026#34;左值引用\u0026#34; \u0026lt;\u0026lt; endl; } void Fun(const int \u0026amp;x){ cout \u0026lt;\u0026lt; \u0026#34;const 左值引用\u0026#34; \u0026lt;\u0026lt; endl; } void Fun(int \u0026amp;\u0026amp;x){ cout \u0026lt;\u0026lt; \u0026#34;右值引用\u0026#34; \u0026lt;\u0026lt; endl; } void Fun(const int \u0026amp;\u0026amp;x){ cout \u0026lt;\u0026lt; \u0026#34;const 右值引用\u0026#34; \u0026lt;\u0026lt; endl; } // std::forward\u0026lt;T\u0026gt;(t)在传参的过程中保持了t的原生类型属性。 template\u0026lt;typename T\u0026gt; void PerfectForward(T\u0026amp;\u0026amp; t) { Fun(std::forward\u0026lt;T\u0026gt;(t)); } int main() { PerfectForward(10); // 右值 int a; PerfectForward(a); // 左值 PerfectForward(std::move(a)); // 右值 const int b = 8; PerfectForward(b); // const 左值 PerfectForward(std::move(b)); // const 右值 return 0; } 实际中使用场景\n1 2 3 4 5 6 7 8 9 10 //... void pushFront(T\u0026amp;\u0026amp; t) { insert(0, std::forward\u0026lt;T\u0026gt;(t)); } void insert(size_t pos, T\u0026amp;\u0026amp; t) { /.... } 万能引用（引用折叠） 万能引用（Universal References）是在 C++11 中引入的一个重要概念。万能引用是通过使用模板类型推导和右值引用的结合来实现的，主要用于实现完美转发（Perfect Forwarding）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; #include \u0026lt;utility\u0026gt; template \u0026lt;typename T\u0026gt; void Process(T\u0026amp;\u0026amp; arg) { // arg 是一个万能引用 // 完美转发，调用一个其他的函数 // std::forward 将 arg 转发为其原始值类别（左值或右值） std::cout \u0026lt;\u0026lt; arg \u0026lt;\u0026lt; std::endl; } int main() { int x = 10; Process(x); // 传递左值， T\u0026amp;\u0026amp;会发生引用折叠，折叠为T\u0026amp; Process(20); // 传递右值 return 0; } template \u0026lt;typename T\u0026gt; T\u0026amp;\u0026amp; ReturnValue(T\u0026amp;\u0026amp; value) { return std::forward\u0026lt;T\u0026gt;(value); // 完美转发，返回右值引用或左值引用 } 只有参数是万能引用，上面的返回值只能视作右值 可变模板参数 C++11的新特性可变参数模板能够让您创建可以接受可变参数的函数模板和类模板，相比C++98/03，类模版和函数模版中只能含固定数量的模版参数，可变模版参数无疑是一个巨大的改进。然而由于可变模版参数比较抽象，使用起来需要一定的技巧.\n形式：template\u0026lt;class ...Args\u0026gt;\n1 2 3 4 5 // Args是一个模板参数包，args是一个函数形参参数包 // 声明一个参数包Args...args，这个参数包中可以包含0到任意个模板参数。 template \u0026lt;class ...Args\u0026gt; void ShowList(Args... args) {} 上面的参数args前面有省略号，所以它就是一个可变模版参数，我们把带省略号的参数称为“参数包”，它里面包含了0到N(N\u0026gt;=0)个模版参数。我们无法直接获取参数包args中的每个参数的，只能通过展开参数包的方式来获取参数包中的每个参数，这是使用可变模版参数的一个主要特点，也是最大的难点，即如何展开可变模版参数。由于语法不支持使用args[]这样方式获取可变参数，所以我们的用一些奇招来\u0026ndash;获取参数包的值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 方式1：递归 // 递归终止函数 template \u0026lt;class T\u0026gt; void ShowList(const T \u0026amp;t) { cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; endl; } // 展开函数 template \u0026lt;class T, class... Args\u0026gt; void ShowList(T value, Args... args) { cout \u0026lt;\u0026lt; value \u0026lt;\u0026lt; \u0026#34; \u0026#34;; ShowList(args...); } int main() { ShowList(1); ShowList(1, \u0026#39;A\u0026#39;); ShowList(1, \u0026#39;A\u0026#39;, std::string(\u0026#34;sort\u0026#34;)); return 0; } 方式2：逗号表达式展开参数包 template \u0026lt;class T\u0026gt; void PrintArg(T t) { cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } // 展开函数 template \u0026lt;class... Args\u0026gt; void ShowList(Args... args) { int arr[] = {(PrintArg(args), 0)...}; cout \u0026lt;\u0026lt; endl; } int main() { ShowList(1); ShowList(1, \u0026#39;A\u0026#39;); ShowList(1, \u0026#39;A\u0026#39;, std::string(\u0026#34;sort\u0026#34;)); return 0; } 使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class A { private: int a, b, c; public: A(int e1 = 0, int e2 = 0, int e3 = 0) : a(e1), b(e2), c(e3) {} void print() { cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; b \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; } }; template\u0026lt;class ...Args\u0026gt; A* Create(Args... args) { A* ret = new A(args...);//一次性使用参数包的所有参数 return ret; } int main(void) { A* p1 = Create(1); A* p2 = Create(1, 2, 3); A* p3 = Create(1, 2, 3); p1-\u0026gt;print(); p2-\u0026gt;print(); return 0; } 注：STL容器中的empalce相关接口使用了 可变模板 + 万能引用\n1 2 template \u0026lt;class... Args\u0026gt; void emplace_back (Args\u0026amp;\u0026amp;... args); emplace_back是直接构造了，push_back 是先构造，再移动构造\n智能指针 * 智能指针是基于RAII机制的类模板，利用对象生命周期来控制程序资源。\nRAII是Resource Acquisition Is Initialization（wiki上面翻译成 “资源获取就是初始化”）的简称，是C++语言的一种管理资源、避免泄漏的惯用法。利用的就是C++构造的对象最终会被销毁的原则。RAII的做法是使用一个对象，在其构造时获取对应的资源，在对象生命期内控制对资源的访问，使之始终保持有效，最后在对象析构的时候，释放构造时获取的资源。\n2个问题：为什么？怎么实现？\n为什么要保障资源自动释放？\n防止开发者忘记delete，造成内存泄漏 抛异常，导致跳过delete 语句 1 2 3 int* p = new int; throw ... delete p; 如何保障资源正常释放？\n在智能指针的析构函数内，执行指针指向对象的析构函数。\n智能指针一共有4种，其中auto_ptr已经弃用。不同类型的智能指针的使用场景，实现机制不同。对于使用者，首先要记住的就是它们的使用场景。\nauto_ptr C++98: 资源转移\nC++11之前：资源管理权限的转移\u0026mdash;-对资源释放的权限\nC++11：弃用\n它的解决方式是管理权转移，p2 = p1会将p1的管理权转移给p2, 而后p1悬空。如果p1是将亡值，这没什么问题，但p1不一定是将亡值，可能是左值，不能随便的转移资源。因此建议什么情况都不要使用auto_ptr\nauto_ptr在C++11中被标记为deprecated（弃用），并建议开发者迁移至std::unique_ptr\nunique_ptr c++11：unique_ptr代表的是专属所有权，即由unique_ptr管理的内存，只能被一个对象持有。\n因此：unique_ptr不支持拷贝和赋值，只支持移动(std::move)\n使用场景：\n大多数场景下用到的应该都是unique_ptr\n忘记delete 抛异常，导致跳过delete 语句 这2点也是智能指针最基本的功能\n性能：\n因为C++的zero cost abstraction的特点，unique_ptr在默认情况下和裸指针的大小是一样的。所以内存上没有任何的额外消耗，性能是最优的。\n模拟实现:简易版\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 template\u0026lt;typename T\u0026gt; class UniquePtr { public: // 默认构造函数 UniquePtr(T* ptr = nullptr) : m_ptr(ptr) {} // 移动构造函数 UniquePtr(UniquePtr\u0026amp;\u0026amp; other) noexcept : m_ptr(other.m_ptr) { other.m_ptr = nullptr; // 转移所有权，置空其他指针 } // 移动赋值运算符 UniquePtr\u0026amp; operator=(UniquePtr\u0026amp;\u0026amp; other) noexcept { if (this != \u0026amp;other) { delete m_ptr; // 释放当前持有的指针 m_ptr = other.m_ptr; // 转移所有权 other.m_ptr = nullptr; // 置空其他指针 } return *this; } // 禁止拷贝构造和拷贝赋值 UniquePtr(const UniquePtr\u0026amp;) = delete; UniquePtr\u0026amp; operator=(const UniquePtr\u0026amp;) = delete; // 析构函数 ~UniquePtr() { delete m_ptr; // 释放管理的对象 } // 解引用操作符 T\u0026amp; operator*() const { return *m_ptr; } // 指针操作符 T* operator-\u0026gt;() const { return m_ptr; } // 获取原始指针 T* get() const { return m_ptr; } // 释放管理的指针 void reset(T* ptr = nullptr) { delete m_ptr; // 释放旧指针 m_ptr = ptr; // 更新为新指针 } // 释放并返回原始指针 T* release() { T* temp = m_ptr; m_ptr = nullptr; // 置空管理指针 return temp; // 返回原始指针 } private: T* m_ptr; // 管理的指针 }; std::unique_ptr，它专门为管理动态数组提供了支持。你可以直接使用 std::unique_ptr 的数组形式，它会在超出作用域时自动调用 delete[]：而shared_ptr直到c++17才支持动态数组\n1 std::unique_ptr\u0026lt;int[]\u0026gt; ptr(new int[5]); shared_ptr c++11新增：shared_ptr代表的是共享所有权，即多个shared_ptr可以共享同一块内存。\n使用场景：\nshared_ptr通常使用在共享权不明的场景。有可能多个对象同时管理同一个内存时。最经典场景就是：多线程下的跨线程的对象 对象的延迟销毁。当一个对象的析构非常耗时，甚至影响到了关键线程的速度。可以将对象转移到另外一个线程中释放，从而解放关键线程。 延迟对象的生命周期。 原理：\nshared_ptr内部是利用引用计数来实现内存的自动管理，每当复制一个shared_ptr，引用计数会+1。当一个shared_ptr离开作用域时，引用计数会-1。当引用计数为0的时候，则delete内存。\n性能：\n内存占用高：shared_ptr的内存占用是裸指针的两倍。因为除了要管理一个裸指针外，还要维护一个引用计数。 因此相比于unique_ptr, shared_ptr的内存占用更高 原子操作性能低：考虑到线程安全问题，引用计数的增减必须是原子操作。而原子操作一般情况下都比非原子操作慢。 我们在使用中，可以通过移动来优化：如果一个shared_ptr需要将所有权共享给另外一个新的shared_ptr，而我们确定在之后的代码中都不再使用这个shared_ptr。 对于此种场景，我们尽量使用std::move，将shared_ptr转移给新的对象。因为移动不用增加引用计数，因此性能比复制更好。\n使用：\nshared_ptr支持的操作 描述 shared_ptr\u0026lt;T\u0026gt; p 空共享指针，可以指向T类型对象 *p 获得p所指向的对象 void reset 释放任何可能存在的被管理对象的所有权。调用的共享指针被设置为空 void reset(T *ptr) 释放当前被管理的对象的所有权。获取由ptr指向的对象的所有权。 T *get() 返回指向被管理对象的裸指针，如果没有被管理的对象，则返回空指针。 make_shared\u0026lt;T\u0026gt;(args) 返回一个shared_ptr,此shared_ptr指向一个动态分配的类型为T的对象，用args初始化此对象。 p.use_cout() 返回与p共享对象的智能指针数量 使用注意事项：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 注意1：不要使用原始指针初始化多个shared_ptr { A* p = new A; shared_ptr\u0026lt;A\u0026gt; sp1(p); shared_ptr\u0026lt;A\u0026gt; sp2(p); } 当出了这个作用域后，报错，double free, 多次释放 因为这段代码相当于是 sp1和sp2分别管理不同的引用计数器，即都是1，当出了作用域后，sp1析构会释放一次，sp2析构也会释放一次 正确写法： { A* p = new A; shared_ptr\u0026lt;A\u0026gt; sp1(p); shared_ptr\u0026lt;A\u0026gt; sp2(sp1); } 注意2：不要用栈中的指针构造 shared_ptr std::shared_ptr\u0026lt;A\u0026gt; func() { A a(10); std::shared_ptr\u0026lt;A\u0026gt; sharedPtr(\u0026amp;a); return sharedPtr; // 错误：返回栈上对象的 shared_ptr } int main() { std::shared_ptr\u0026lt;A\u0026gt; ptr = func(); } 注意3：shared_ptr的参数默认是不支持数组类型 std::shared_ptr\u0026lt;int\u0026gt; ptr(new int[5]); // 错误 std::shared_ptr\u0026lt;int[]\u0026gt; sp1(new int[10]()); // 错误，c++17前不能传递数组类型作为shared_ptr的模板参数 因为 std::shared_ptr 默认使用 delete 来释放内存，而不是 delete[]。 解决方式：添加自定义删除器 std::shared_ptr\u0026lt;int\u0026gt; ptr(new int[5], [](int* p) { delete[] p; }); std::shared_ptr\u0026lt;int\u0026gt; sp3(new int[10](), std::default_delete\u0026lt;int[]\u0026gt;()); 模拟实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 #pragma once #include \u0026lt;mutex\u0026gt; template\u0026lt;typename T\u0026gt; class MySharedPtr { public: MySharedPtr(T* ptr = nullptr); MySharedPtr(const MySharedPtr\u0026lt;T\u0026gt;\u0026amp; other); MySharedPtr\u0026lt;T\u0026gt;\u0026amp; operator=(const MySharedPtr\u0026lt;T\u0026gt;\u0026amp; other); ~MySharedPtr(); T\u0026amp; operator*(); T* operator-\u0026gt;(); int useCount(); T* get(); void realse(); void addCount(); void subCount(); private: T* m_ptr; int* m_pcount; std::mutex* m_pmutex; }; template\u0026lt;typename T\u0026gt; MySharedPtr\u0026lt;T\u0026gt;::MySharedPtr(T* ptr) :m_ptr(ptr) , m_pcount(new int(1)) , m_pmutex(new std::mutex) {} template\u0026lt;typename T\u0026gt; MySharedPtr\u0026lt;T\u0026gt;::MySharedPtr(const MySharedPtr\u0026lt;T\u0026gt;\u0026amp; other) : m_ptr(other.m_ptr) , m_pcount(other.m_pcount) , m_pmutex(other.m_pmutex) { addCount(); } template\u0026lt;typename T\u0026gt; MySharedPtr\u0026lt;T\u0026gt;\u0026amp; MySharedPtr\u0026lt;T\u0026gt;::operator=(const MySharedPtr\u0026lt;T\u0026gt;\u0026amp; other) { if (this != \u0026amp;other) { realse(); m_ptr = other.m_ptr; m_pcount = other.m_pcount; m_pmutex = other.m_pmutex; addCount(); } return *this; } template\u0026lt;typename T\u0026gt; MySharedPtr\u0026lt;T\u0026gt;::~MySharedPtr() { realse(); } template\u0026lt;typename T\u0026gt; T\u0026amp; MySharedPtr\u0026lt;T\u0026gt;::operator*() { return *(m_ptr); } template\u0026lt;typename T\u0026gt; T* MySharedPtr\u0026lt;T\u0026gt;::operator-\u0026gt;() { return m_ptr; } template\u0026lt;typename T\u0026gt; int MySharedPtr\u0026lt;T\u0026gt;::useCount() { return *(m_pcount); } template\u0026lt;typename T\u0026gt; T* MySharedPtr\u0026lt;T\u0026gt;::get() { return m_ptr; } template\u0026lt;typename T\u0026gt; void MySharedPtr\u0026lt;T\u0026gt;::realse() { bool flag = false; m_pmutex-\u0026gt;lock(); if (--(*m_pcount) == 0 \u0026amp;\u0026amp; m_ptr) { delete m_ptr; delete m_pcount; flag = true; } m_pmutex-\u0026gt;unlock(); if (flag) delete m_pmutex; } template\u0026lt;typename T\u0026gt; void MySharedPtr\u0026lt;T\u0026gt;::addCount() { m_pmutex-\u0026gt;lock(); ++(*m_pcount); m_pmutex-\u0026gt;unlock(); } template\u0026lt;typename T\u0026gt; void MySharedPtr\u0026lt;T\u0026gt;::subCount() { m_pmutex-\u0026gt;lock(); --(*m_pcount); m_pmutex-\u0026gt;unlock(); } 循环引用问题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class A { public: A() { cout \u0026lt;\u0026lt; \u0026#34;A()\u0026#34; \u0026lt;\u0026lt; endl; } ~A() { cout \u0026lt;\u0026lt; \u0026#34;~A()\u0026#34; \u0026lt;\u0026lt; endl; } }; struct Node { public: A val; shared_ptr\u0026lt;Node\u0026gt; prev = nullptr; shared_ptr\u0026lt;Node\u0026gt; next = nullptr; }; int main(void) { auto p1 = std::make_shared\u0026lt;Node\u0026gt;(); auto p2 = std::make_shared\u0026lt;Node\u0026gt;(); p2-\u0026gt;prev = p1; p1-\u0026gt;next = p2; return 0; } 程序执行结果：\n1 2 A() A() weak_ptr c++11新增：weak_ptr代表的是无所有权，不能单独管理对象。配合shared_ptr解决循环引用问题\nweak_ptr 的构造和析构不会引起引用计数的增加或减少。\nweak_ptr支持的操作 描述 bool expired() const 空共判断weak_ptr保存的队行是否已经销毁，销毁了返回true，否则返回false。 shared_ptr\u0026lt;element_type\u0026gt; lock() const; 生命周期未结束，返回一个share_ptr指针，指向同样的对象，否则，返回一个为nullptr的share_ptr.引用计数 + 1 long use_count() 返回所有与weak_ptr指向同一对象的shared_ptr的数量。 我们用weak_ptr来修改之前的循环引用代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class A { public: A() { cout \u0026lt;\u0026lt; \u0026#34;A()\u0026#34; \u0026lt;\u0026lt; endl; } ~A() { cout \u0026lt;\u0026lt; \u0026#34;~A()\u0026#34; \u0026lt;\u0026lt; endl; } }; struct Node { public: A val; weak_ptr\u0026lt;Node\u0026gt; prev = nullptr; //修改prev和next其中一个为weak_ptr shared_ptr\u0026lt;Node\u0026gt; next = nullptr; }; int main(void) { auto p1 = std::make_shared\u0026lt;Node\u0026gt;(); auto p2 = std::make_shared\u0026lt;Node\u0026gt;(); p2-\u0026gt;prev = p1; //prev为weak_ptr p1-\u0026gt;next = p2; return 0; } 程序执行结果：\n1 2 3 4 A() A() ~A() ~A() c++的函数式编程 函数式编程是什么？\n函数式编程（Functional Programming, FP）是一种以数学中的λ演算（lambda calculus）为理论基础的编程范式，其核心是将计算视为函数的组合与变换，而非对状态或指令的执行顺序的依赖.\n从 C++11 开始，C++ 引入对函数式编程的支持。主要体现在\nlambda表达式：函数式编程中闭包机制的体现。 std::function：通用函数封装器，可存储Lambda、函数指针等，提供统一接口。 std::bind：参数绑定与适配工具，用于生成部分参数固定的新函数。 lambda lambda可以看作函数对象（仿函数），编译器会根据lambda表达式自动生成一个匿名函数对象，它有以下优点：\n声明式的编程风格：就地匿名定义目标函数或函数对象，不需要额外写一个命名函数或函数对象。 简洁：避免了代码膨胀和功能分散，让开发更加高效。 在需要的时间和地点实现功能闭包，使程序更加灵活。 形式：[capture-list] (parameters) mutable -\u0026gt; return-type { statement }\n[capture-list] : 捕捉列表，该列表总是出现在lambda函数的开始位置，编译器根据[]来判断接下来的代码是否为lambda函数，捕捉列表能够捕捉上下文中的变量供lambda函数使用 (parameters)：参数列表。与普通函数的参数列表一致，如果不需要参数传递，则可以连同()一起省略 mutable：可变的，默认情况下，lambda函数总是一个const函数，mutable可以取消其常量性。使用该修饰符时，参数列表不可省略(即使参数为空) return-type: 返回值类型，可以不写，编译器会自动推导 {statement} ： 函数体,短小 举例：auto add = [](int x, int y)-\u0026gt;int {return x + y; };\n捕捉列表： 捕捉列表描述了上下文中那些数据可以被lambda使用，以及使用的方式传值还是传引用。\n[var]：表示值传递方式捕捉变量var [=]：表示值传递方式捕获所有父作用域中的变量(包括this) [\u0026amp;var]：表示引用传递捕捉变量var [\u0026amp;]：表示引用传递捕捉所有父作用域中的变量(包括this) [this]：表示值传递方式捕捉当前的this指针 注意点：默认情况下，lambda函数总是一个const函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 错误代码： int a = 0, b = 3; auto swap1 = [a,b]() { std::swap(a, b); //报错 }; swap1(); cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; b; //值捕获的列表的a，b相当于 const int a， const int b： //要想改变，如下： auto swap1 = [a,b]() mutable { std::swap(a, b); }; 但是它改变的是 int a, int b,无法影响外部的a,b。 测试：\n1 2 3 4 5 6 7 8 9 10 11 12 int main() { int a = 10,b = 20; //提问下列代码哪些是正确，哪些是错误的 auto funFirst = []{return a;};\t//error auto funSecond = [\u0026amp;]{return a++;}; //true auto funThird = [=]{return a;}; //true auto funFourth = [=]{return a++;}; //false auto funFifth = [a]{return a + (b++);}; //error auto funSixth = [a,\u0026amp;b]{return a + (b++);}; //true; auto funSeventh = [=,\u0026amp;b]{return a + (b++);}; //true } lambda和闭包\n闭包（Closure） 是编程语言中一种特殊的函数与词法作用域结合的现象。其核心机制是：当一个内部函数（如 Lambda 表达式）访问其外部函数或定义环境中的变量时，即使外部函数已执行完毕，这些变量的生命周期会被延长，形成闭包环境。\nLambda 表达式通过捕获列表（如 C++ 的 [=] 或 [\u0026amp;]）或隐式捕获（如 Java、JavaScript）引用外部变量。这些变量在 Lambda 定义时被“冻结”，即使原作用域已销毁，仍可通过闭包访问。\n1 2 int x = 5; auto lambda = [x]() { return x * 2; }; // 值捕获x，形成闭包 function function是包装器，当需要将不同类型的可调用对象（如普通函数、Lambda、成员函数等）作为参数传递时，std::function提供统一的封装接口。\n比如：函数指针，反函数，lambda表达式，即使他们的功能一样，但将它们作为参数传给模板时，会被识别为三种类型，实例化为三份，这导致使用效率降低，而包装器则可以说是将它们进行了一层封装。\n验证如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 template\u0026lt;class F, class T\u0026gt; T useF(F f, T x) { static int count = 0; cout \u0026lt;\u0026lt; \u0026#34;count:\u0026#34; \u0026lt;\u0026lt; ++count \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;count:\u0026#34; \u0026lt;\u0026lt; \u0026amp;count \u0026lt;\u0026lt; endl; return f(x); } double f(double i) { return i / 2; } struct Functor { double operator()(double d) { return d / 3; } }; int main(void) { // 实例化3个useF cout \u0026lt;\u0026lt; useF(f, 11.11) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; useF(Functor(), 11.11) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; useF([](double d)-\u0026gt;double {return d / 4; }, 11.11) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; endl; // 实例化1个useF std::function\u0026lt;double(double)\u0026gt; func1 = f; std::function\u0026lt;double(double)\u0026gt; func2 = Functor(); std::function\u0026lt;double(double)\u0026gt; func3 = [](double d)-\u0026gt;double { return d / 4; }; cout \u0026lt;\u0026lt; useF(func1, 11.11) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; useF(func2, 11.11) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; useF(func3, 11.11) \u0026lt;\u0026lt; endl; return 0; } 结果：只实例化了一个useF\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 count:1 count:00FBF4F0 5.555 count:1 count:00FBF4F4 3.70333 count:1 count:00FBF4F8 2.7775 count:1 count:00FBF4FC 5.555 count:2 count:00FBF4FC 3.70333 count:3 count:00FBF4FC 2.7775 使用场景：最常见的场景是设置回调函数\n1 2 3 4 5 6 // 定义回调接口 void register_callback(std::function\u0026lt;void(int)\u0026gt; callback) { callback(42); } // 传递Lambda或函数 register_callback([](int x) { std::cout \u0026lt;\u0026lt; x; }); // 输出42 bind bind也是是包装器，也叫绑定器，当目标函数参数与调用环境不匹配时，通过绑定部分参数生成新函数对象\n使用如下：\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; #include \u0026lt;functional\u0026gt; void PrintSum(int x, int y) { std::cout \u0026lt;\u0026lt; x + y \u0026lt;\u0026lt; std::endl; } int main() { auto boundFunc = std::bind(PrintSum, 10, std::placeholders::_1); // 绑定第一个参数为10 boundFunc(20); // 只需传入第二个参数 return 0; } 理解 它的使用场景：回调函数，基本和function搭配使用。\n举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Channel { private: using EventCallback = std::function\u0026lt;void()\u0026gt;; EventCallback m_read_callback; public: void setReadCallback(const EventCallback\u0026amp; cb) { m_read_callback = cb; } }; class Connection { private: Channel m_channel; void hanleRead() { //.. } public: Connection() { m_channel.setReadCallback(std::bind(\u0026amp;Connection::hanleRead, this)); } }; 回调函数往往在事件驱动模型中使用，想更深入了解回调函数，可以去参考reactor模式的服务器等。\n其他 std::tuple c++11新增，用于将多个值打包成一个单一的对象。它可以存储不同类型的值，并且可以通过索引或类型来访问这些值。\n1 std::tuple\u0026lt;int, std::string, double\u0026gt; t(42, \u0026#34;Hello\u0026#34;, 3.14159); std::quoted c++11新增，给字符串加双引号\n1 2 3 4 5 6 7 8 int main() { std::string str = \u0026#34;hello world\u0026#34;; std::cout \u0026lt;\u0026lt; str\u0026lt;\u0026lt; std::endl; //====\u0026gt; hello world std::cout \u0026lt;\u0026lt;\u0026#34;\\\u0026#34;\u0026#34; +str + \u0026#34;\\\u0026#34;\u0026#34;\u0026lt;\u0026lt;std::endl; std::cout \u0026lt;\u0026lt; std::quoted(str) \u0026lt;\u0026lt; std::endl; //===\u0026gt; \u0026#34;hello world\u0026#34; return 0; } ","date":"2025-04-13T00:00:00Z","permalink":"https://sfw003.github.io/p/c-11/","title":"C++11"},{"content":"什么是编译链接？ 编译则是将编译型语言（如c/c++）翻译为计算机可以识别的二进制文件，即目标文件。\n链接则是一个打包的过程，将所有的目标文件以及系统组件组合成一个可执行文件。\nc/c++编译链接过程如下：\n编译 编译过程分为3部分：预处理（预编译），编译，汇编，整个编译过程由编译器负责。\n预处理 头文件的展开 #define定义的宏替换 删除注释 编译 汇编 链接 C/C++的链接方式主要分为 静态链接 和 动态链接\n静态链接 在编译时将库代码（.a/.lib）完全嵌入到可执行文件中\n特点：\n文件体积大，相同库代码在不同程序中重复存在\n更新需重新编译整个程序\n独立性强\n动态链接 运行时加载共享库（.so/.dll），代码在内存中共享\n特点：\n节省磁盘和内存空间，多个程序共用同一库 支持热更新，库更新后无需重新编译程序 依赖环境配置，需确保运行时库路径正确 如何理解？\n疑问：\n假设动态库里有一个函数 Print(), 在生成动态库的过程中，Print函数的虚拟地址是被硬编码到动态库里。\n这导致了一个问题，当进程使用Print(), 动态库首先被加载到物理内存里然后通过页表与虚拟地址相映射。但是由于Print函数的虚拟地址被硬编码到动态库，因此通过页表映射的Print函数虚拟地址是固定的。\n那问题来了，这个虚拟地址已经被占了呢？那就出问题了。为了解决这个问题，动态库内的函数不在使用绝对地址，而是相对地址，即偏移量。\n此时dy.so通过页表映射的虚拟地址不固定，之后要想找到Print函数，只需用动态库的起始地址 + Print函数的偏移量。\n下面看看具体的操作系统下c++的编译和链接\nlinux gcc/g++ GCC（GNU Compiler Collection）是Linux下C/C++开发的核心工具链，\nlinux下制作动静态库 linux的静态库为.a文件，动态库为.so文件\n静态库：通过ar -rc打包目标文件生成.a\n动态库：使用gcc -shared -fPIC编译生成位置无关代码（PIC）的.so\nlinux静态库 现在有两个文件：test.h, test.c，如下。\n1 2 3 4 5 6 7 8 9 10 root@iZbp1inz4ol3gjahpjal9qZ:~/study# cat test.h #include \u0026lt;stdio.h\u0026gt; void Print(); root@iZbp1inz4ol3gjahpjal9qZ:~/study# cat test.c #include \u0026#34;test.h\u0026#34; void Print() { printf(\u0026#34;66666666\\n\u0026#34;); } 执行上述命令后，结果如下：lib目录里存储制作的静态库。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 root@iZbp1inz4ol3gjahpjal9qZ:~/study# make gcc -o test.o -c test.c ar -rc libtest.a test.o root@iZbp1inz4ol3gjahpjal9qZ:~/study# make put mkdir -p lib/include mkdir -p lib/mylib cp *.h lib/include cp *.a lib/mylib root@iZbp1inz4ol3gjahpjal9qZ:~/study# make clean rm -f *.o *.a root@iZbp1inz4ol3gjahpjal9qZ:~/study# ls lib Makefile test.c test.h root@iZbp1inz4ol3gjahpjal9qZ:~/study# tree lib lib ├── include │ └── test.h └── mylib └── libtest.a 2 directories, 2 files 使用静态库\n现在我们创建main.c来测试我们的静态库。如下：\n1 2 3 4 5 6 7 8 9 10 11 root@iZbp1inz4ol3gjahpjal9qZ:~/study# cat main.c #include \u0026#34;test.h\u0026#34; int main() { Print(); return 0; }root@iZbp1inz4ol3gjahpjal9qZ:~/study# gcc -o main main.c main.c:1:10: fatal error: test.h: No such file or directory 1 | #include \u0026#34;test.h\u0026#34; | ^~~~~~~~ compilation terminated. 这里出现了一个报错，找不到头文件。原因很简单，test.h与main.c不在同一级目录下，此时我们有3种做法：\n告诉编译器，除了在当前目录下、系统目录下找，如果找不到，就去指定目录下找。参数-I [路径】 gcc main.c -o main -I ./lib/include include头文件时，带相对路径或绝对路径 include \u0026quot;lib/include/test.h\u0026quot; 安装到系统里，即将头文件和库移到/usr/inlcude 和/usr/lib64, 如果不想移，也可以建立软链接，再将软链接放到/usr/inlcude 和/usr/lib64 这里采用第一种，结果如下\n1 2 3 4 root@iZbp1inz4ol3gjahpjal9qZ:~/study# gcc -o main main.c -I lib/include /usr/bin/ld: /tmp/ccGShNRL.o: in function `main\u0026#39;: main.c:(.text+0xe): undefined reference to `Print\u0026#39; collect2: error: ld returned 1 exit status 报错显示找不到Print函数，属于链接报错。原因是你只告诉了.h的路径，并没有告诉.a文件的路径. 因此完整的命令如下\n1 gcc main.c -o main -I ./lib/include/ -L ./lib/mylib -ltest 其中-L [库的路径]-l[库名]\n注意库名要掐头去尾且最好与-l连在一起\n1 2 3 4 5 6 7 8 9 10 root@iZbp1inz4ol3gjahpjal9qZ:~/study# tree lib lib ├── include │ └── test.h └── mylib └── libtest.a 2 directories, 2 files root@iZbp1inz4ol3gjahpjal9qZ:~/study# gcc -o main main.c -I lib/include -L lib/mylib -ltest root@iZbp1inz4ol3gjahpjal9qZ:~/study# linux动态库 linux下有个命令可以看到程序动态链接了哪些库 \u0026mdash; ldd 以上文的main程序为例\n现在有2个文件：dytest.h dytest.c\n1 2 3 4 5 6 7 8 9 10 11 [sfw@VM-24-12-centos 3_10]$ cat dytest.c #include \u0026#34;dytest.h\u0026#34; void Print() { printf(\u0026#34;dytest链接正常\\n\u0026#34;); } [sfw@VM-24-12-centos 3_10]$ cat dytest.h #pragma once #include \u0026lt;stdio.h\u0026gt; void Print(); 执行上述命令后便会生成lib目录，libtest.so便是我们制作的动态库 创建main.c进行测试 同样和静态库一样：gcc main.c -o main -I ./lib/include/ -L ./lib/mylib/ -ltest 最后便会出现下面的错误 此时我们用ldd命令来查看，会看到not found,找不到库，可我们明明已经告诉编译器库在哪里，为什么还是找不到？原因是我们告诉了编译器，但现在已经是可执行程序，需要通过加载器来进行链接，但我们并没有告诉加载器，库在哪里。 解决这个问题的方法很多，这里介绍3种：\n安装到系统里，即/usr/lib64 添加路径到环境变量LD_LTBRAY_PATH export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/sfw/study/3_10/lib/mylib 地址写到库所在目录就可以了，因为库的名字早就写在可执行程序中 但是这种方法，在重启时，环境变量更新，便会失效。除非，你写到系统配置文件里。 在/etc/ld.so.conf.d里面建立动态库路径，然后ldconfig /etc/ld.so.conf.d 目录是 Linux 下的动态链接器配置目录。在这个目录下，可以放置一系列以 .conf 结尾的文件，这些文件包含了动态链接器的库文件搜索路径配置。每个文件通常包含一组路径，告诉动态链接器在运行时去哪里搜索共享库文件。 操作如下：(下面操作需要root权限） windows MSVC windows下的c/c++工具链是 MSVC，MSVC包括以下几个工具\ncl.exe：一个控制 Microsoft C++ (MSVC) C 和 C++ 编译器和链接器的工具\nlink.exe：链接器\n其他（debugger……）\n误解：cl.exe 这里的cl是编译器compiler和链接器linker的两个单词首字母的缩写，是不是表示cl.exe即是编译器又是链接器？\n不是，根据官方文档：除非使用 /c 选项，否则 CL 会在编译后自动调用链接器link.exe。cl.exe本身只是编译器。\nwindows SDK windows制作动静态库 ","date":"2025-04-12T00:00:00Z","permalink":"https://sfw003.github.io/p/compile-and-link/","title":"编译和链接"},{"content":"智能手写输入法 设计思路 模块划分 【金山文档 | WPS云文档】 手写输入法模块划分 https://kdocs.cn/l/cbaoXUi8YmWw\nmodels\nStrokeModel: 管理笔画数据，提供数据的增删改查功能。 CandidateModel: 管理候选词数据，提供候选词的选择和更新功能。 ConfigModel: 管理配置数据，如用户设置、手写识别参数等。 delegates\nStrokeDelegate: 负责笔画的渲染。 CandidateDelegate: 负责候选词的渲染。 views\nHandWriteView: 手写板视图，处理用户输入和笔画显示。 CandidateView: 候选词视图，显示识别结果的候选词。 SettingsPopupDialog: 设置弹窗，提供用户配置界面。 ToolPopupDialog：手动选择标点、数字、字母、语言弹窗 controllers\nRecognitionController: 负责与识别引擎的交互，处理识别结果。 TSFController: 负责与文本服务框架（TSF）的交互，管理输入法状态。 core\nRecognition：提供识别服务 RecognitionModel: 识别服务，提供手写识别的核心算法。 IPC: 用于和TSF服务通信 IPCServer: 使用命名管道进行双向通信 Common: 公共组件，提供通用的工具类和数据结构。 data.h：核心数据结构。 dictionary\ndictionary.db: Sqlite数据库，里面存储汉字-拼音表，汉字-常见词组表 DictionaryManager：词典管理类 LocalDictionary：本地词典（使用dictionary.db） OnlineDictionary：在线词典（使用第三方平台词典） 手写区域 笔迹数据存储\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 struct StrokeStyle // 笔迹样式 { QColor color{Qt::black};\t// 笔迹颜色（默认颜色: 黑） int width{2};\t// 笔迹大小（默认大小: 2px） bool operator==(const StrokeStyle \u0026amp;other) const { return color == other.color \u0026amp;\u0026amp; width == other.width; } }; struct StrokeData // 笔迹数据 { QVector\u0026lt;QPoint\u0026gt; points; // 笔迹点集 StrokeStyle style; // 笔迹样式 qint64 timestamp; // 时间戳（目前未用到） StrokeData() = default; StrokeData(const StrokeStyle \u0026amp;s) : style(s) {} }; 手写区域采用 Qt 的 Model-View 架构。\nview：通过继承 QAbstractItemView 实现自定义视图控件。设计了基类 HandWriteView 及其两个子类 SingleHandWriting（单字手写）和 LongSentenceHandWriting（长句手写），实现了不同模式下的手写功能。\ndelegate: 通过继承QStyledItemDelegate 实现自定义代理。设计了类StrokeDelegate，实现paint函数，进行局部重绘，减少整个手写试图的重绘次数。\nmodel: 因为笔迹用通过继承QAbstractListModel 实现自定义模型，数据采用QVector\u0026lt;StrokeDate\u0026gt;存储。\n时序图 基本流程：\n用户用鼠标在HandWriteView上绘制，先后触发 mousePressEvent, mouseMoveEvent, mouseReleaseEvent，采集笔迹给StrokeModel 每次笔迹(点)更新，通知StrokeDelegate进行笔迹渲染，展示给用户 当一次完整笔迹采集后，发送信号StrokeDateChange给RecognitionContoller调用识别引擎进行识别 通过单字手写按钮、长句手写按钮可以将进行不同手写模式的切换\n详细设计 手写输入法有2种模式：单字手写和长句手写\n在单字手写模式下，手写区域为正方形，米字格 在长句手写模式下，手写区域为矩形，网格。 二者的区别在于paintEvent绘制背景。 因此我设计了一个基类HandWriteView，2个子类SingleHandWriting和LongSentenceHandWriting\n基类 HandWriteView\nUI 组件管理\n撤销按钮：支持笔画回退 清空按钮：清除所有笔画 提示文本：显示当前状态信息 笔迹处理\n笔画捕获：处理鼠标事件实现笔迹采集 笔迹渲染：实时绘制用户输入的笔画 状态管理：跟踪书写状态，控制按钮启用/禁用 事件处理\nmousePressEvent：开始笔画 mouseMoveEvent：继续笔画 mouseReleaseEvent：结束笔画 paintEvent：渲染视图 resizeEvent：处理尺寸变化 子类特化\nSingleHandWriting\n实现米字格背景 LongSentenceHandWriting\n实现网格背景 笔迹识别 我希望我的笔迹识别能够支持多种识别引擎。因此采用策略模式设置了一个抽象类IRecognitionEngine\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class IRecognitionEngine : public QObject { Q_OBJECT public: explicit IRecognitionEngine(QObject* parent = nullptr) : QObject(parent) {} virtual ~IRecognitionEngine() = default; // 初始化引擎 virtual bool initialize() = 0; // 处理笔画数据 virtual void processStrokes(const QVector\u0026lt;StrokeData\u0026gt;\u0026amp; strokes) = 0; // 清理资源 virtual void cleanup() = 0; signals: void recognitionCompleted(const QStringList\u0026amp; candidates);\t// 笔迹识别完成信号 void recognitionError(const QString\u0026amp; error);\t// 笔迹识别错误信号 }; 目前我只设置了一种识别引擎：windows的墨迹识别 window LNK\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class WindowsTabletEngine : public IRecognitionEngine { Q_OBJECT public: explicit WindowsTabletEngine(QObject* parent = nullptr); ~WindowsTabletEngine(); bool initialize() override; void processStrokes(const QVector\u0026lt;StrokeData\u0026gt;\u0026amp; strokes) override; void cleanup() override; void setRecognitionMode(RecognitionMode mode) override; private: // 辅助方法 winrt::Windows::UI::Input::Inking::InkStroke createInkStroke(const StrokeData\u0026amp; strokeData); // 处理坐标转换 winrt::Windows::UI::Input::Inking::InkStrokeContainer handleCoordinateConversion(const QVector\u0026lt;StrokeData\u0026gt;\u0026amp; strokes); // 处理错误 void handleRecognitionError(const QString\u0026amp; message); // 数据补充 void dataSupplement(RecognitionResult\u0026amp; result, RecognitionMode mode); private: // 识别器容器 winrt::Windows::UI::Input::Inking::InkRecognizerContainer m_recognizerContainer; // 识别目标 RecognitionMode m_recognitionTarget; }; 时序图 详细设计 笔迹识别函数processStrokes包括3部分：\nqt笔迹 \u0026ndash;\u0026gt; windows LNK（handleCoordinateConversion） 异步识别 结果补充(如果候选词\u0026lt;9则补充，同时加入拼音和4个词组)（dataSupplement） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 InkStrokeContainer WindowsTabletEngine::handleCoordinateConversion(const QVector\u0026lt;StrokeData\u0026gt; \u0026amp;strokes) { InkStrokeContainer strokeContainer; InkStrokeBuilder builder; // qt坐标转换为winrt坐标 if(m_recognitionTarget == RecognitionMode::SingleChar) { // 单字模式：将所有笔画的点合并成一个笔画 IVector\u0026lt;Windows::Foundation::Point\u0026gt; allpoints = single_threaded_vector\u0026lt;Windows::Foundation::Point\u0026gt;(); for (const auto\u0026amp; stroke : strokes) { for (const QPoint\u0026amp; point : stroke.points) { float scaledX = point.x(); float scaledY = point.y(); allpoints.Append(Windows::Foundation::Point(scaledX, scaledY)); } } auto inkStroke = builder.CreateStroke(allpoints); strokeContainer.AddStroke(inkStroke); } else if(m_recognitionTarget == RecognitionMode::MultiChar) { for (const auto \u0026amp;stroke : strokes) { // 自由书写模式：保持原有的多笔画结构 IVector\u0026lt;Windows::Foundation::Point\u0026gt; points = single_threaded_vector\u0026lt;Windows::Foundation::Point\u0026gt;(); for (const QPoint \u0026amp;point : stroke.points) { float scaledX = point.x(); float scaledY = point.y(); points.Append(Windows::Foundation::Point(scaledX, scaledY)); } auto inkStroke = builder.CreateStroke(points); strokeContainer.AddStroke(inkStroke); } } return strokeContainer; } 结果补充\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 void WindowsTabletEngine::dataSupplement(RecognitionResult\u0026amp; result, RecognitionMode mode) { if(mode == RecognitionMode::SingleChar) { #ifdef USE_LIBRARY // 1. 如果候选字少于9个，补充相似字 if (result.candidates.size() \u0026lt; 9) { QString firstChar = result.candidates.first(); DictionaryManager::instance().getSimilarCharacters(firstChar, 9 - result.candidates.size(), [\u0026amp;result](const QStringList\u0026amp; similar) { // 添加相似字到候选列表 result.candidates.append(similar); // 确保不超过9个 while (result.candidates.size() \u0026gt; 9) { result.candidates.removeLast(); } }); } // 2. 为所有候选字获取拼音 result.pinyins.clear(); // 确保拼音列表为空 int pendingPinyinRequests = result.candidates.size(); for (const QString\u0026amp; character : result.candidates) { DictionaryManager::instance().getPinyin(character, [\u0026amp;result, character, \u0026amp;pendingPinyinRequests, this](const QString\u0026amp; char_, const QString\u0026amp; pinyin) { result.pinyins[character] = pinyin; --pendingPinyinRequests; // 当所有拼音都获取完毕后，获取相关词组 if (pendingPinyinRequests == 0) { // 3. 获取相关词组 DictionaryManager::instance().getRelatedWords(result.candidates.first(), 4, [this, \u0026amp;result](const QStringList\u0026amp; words) { result.relatedWords = words; // 这里可以发送完成信号（上述步骤都是异步获取，当获取完成后，发送信号通知） emit recognitionCompleted(result); }); } }); } #endif } else if(mode == RecognitionMode::MultiChar) { while(result.candidates.size() \u0026lt; 9) { result.candidates.append(QString::fromLocal8Bit(\u0026#34; \u0026#34;)); } emit recognitionCompleted(result); } } 词典 词典用来补充数据，为识别出的字提供拼音、词组服务。词典分为在线词典和本地词典，对于这种双模式词典设计，我使用策略、单例、工厂模式的组合。\n策略模式：采用在线词典和本地词典双重实现\n工厂模式：使用词典管理器统一管理不同词典实现\n单例模式：词典管理器采用单例设计，确保全局唯一访问点\n详细设计 词典接口（IDictionary）\n定义统一的词典操作接口\n包含拼音查询、相似字查询、相关词组查询等基本功能\n提供可用性检查机制\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class IDictionary { public: virtual ~IDictionary() = default; // 核心接口 virtual void getPinyin(const QString\u0026amp; character, std::function\u0026lt;void(const QString\u0026amp;, const QString\u0026amp;)\u0026gt; callback) = 0; virtual void getSimilarCharacters(const QString\u0026amp; character, int count, std::function\u0026lt;void(const QStringList\u0026amp;)\u0026gt; callback) = 0; virtual void getRelatedWords(const QString\u0026amp; character, int count, std::function\u0026lt;void(const QStringList\u0026amp;)\u0026gt; callback) = 0; // 状态检查 virtual bool isAvailable() const = 0; }; 本地词典（LocalDictionary）\n基于 SQLite 数据库实现\n包含字符表和词组表两个基本表结构\n提供快速的本地查询能力\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class LocalDictionary : public IDictionary { public: LocalDictionary(); ~LocalDictionary(); void getPinyin(const QString\u0026amp; character, std::function\u0026lt;void(const QString\u0026amp;, const QString\u0026amp;)\u0026gt; callback) override; void getSimilarCharacters(const QString\u0026amp; character, int count, std::function\u0026lt;void(const QStringList\u0026amp;)\u0026gt; callback) override; void getRelatedWords(const QString\u0026amp; character, int count, std::function\u0026lt;void(const QStringList\u0026amp;)\u0026gt; callback) override; bool isAvailable() const override; private: bool initDatabase(); QSqlDatabase m_db; bool m_isInitialized; }; 在线词典（OnlineDictionary）（未测试）\n通过网络 API 实现（采用百度只能云）\n提供更丰富的词典数据\n支持数据的实时更新\n包含请求缓存机制，优化性能\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class OnlineDictionary : public QObject, public IDictionary { Q_OBJECT public: explicit OnlineDictionary(QObject* parent = nullptr); ~OnlineDictionary(); // IDictionary 接口实现 void getPinyin(const QString\u0026amp; character, std::function\u0026lt;void(const QString\u0026amp;, const QString\u0026amp;)\u0026gt; callback) override; void getSimilarCharacters(const QString\u0026amp; character, int count, std::function\u0026lt;void(const QStringList\u0026amp;)\u0026gt; callback) override; void getRelatedWords(const QString\u0026amp; character, int count, std::function\u0026lt;void(const QStringList\u0026amp;)\u0026gt; callback) override; bool isAvailable() const override; // API配置 void setApiKey(const QString\u0026amp; appId, const QString\u0026amp; secretKey); void setTimeout(int milliseconds); signals: void error(const QString\u0026amp; errorMessage); private slots: void handleNetworkReply(QNetworkReply* reply); void handleTimeout(); private: // API请求相关 QString generateSignature(const QUrlQuery\u0026amp; query) const; QNetworkReply* sendRequest(const QString\u0026amp; endpoint, QUrlQuery\u0026amp; query); // 缓存相关 struct CacheEntry { QVariant data; qint64 timestamp; }; QVariant getCachedData(const QString\u0026amp; key) const; void cacheData(const QString\u0026amp; key, const QVariant\u0026amp; data); void cleanCache(); private: // 网络相关 QNetworkAccessManager* m_networkManager; std::map\u0026lt;QNetworkReply*, std::function\u0026lt;void(const QJsonDocument\u0026amp;)\u0026gt;\u0026gt; m_pendingReplies; QTimer* m_timeoutTimer; int m_timeout; // API配置 QString m_appId; QString m_secretKey; QString m_baseUrl; bool m_isInitialized; // 缓存 QMap\u0026lt;QString, CacheEntry\u0026gt; m_cache; static const int CACHE_DURATION = 3600; // 缓存时间（秒） static const int CACHE_MAX_SIZE = 1000; // 最大缓存条目数 }; 词典管理器（DictionaryManager）\n统一管理在线和本地词典\n提供智能切换机制\n处理词典查询的优先级策略\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class DictionaryManager { public: static DictionaryManager\u0026amp; instance(); // 获取拼音 void getPinyin(const QString\u0026amp; character, std::function\u0026lt;void(const QString\u0026amp;, const QString\u0026amp;)\u0026gt; callback); // 获取相似字 void getSimilarCharacters(const QString\u0026amp; character, int count, std::function\u0026lt;void(const QStringList\u0026amp;)\u0026gt; callback); // 获取相关词 void getRelatedWords(const QString\u0026amp; character, int count, std::function\u0026lt;void(const QStringList\u0026amp;)\u0026gt; callback); // 配置方法 void setOnlineApiKey(const QString\u0026amp; appId, const QString\u0026amp; secretKey); // 设置是否优先使用在线词典 void setPreferOnline(bool prefer); private: DictionaryManager(); DictionaryManager(const DictionaryManager\u0026amp;) = delete; DictionaryManager\u0026amp; operator=(const DictionaryManager\u0026amp;) = delete; IDictionary* getPreferredDictionary(); OnlineDictionary* m_onlineDictionary; LocalDictionary* m_localDictionary; bool m_preferOnline; }; 候选词区域 候选词区域负责展示和管理用户可选择的候选字词。采用 Qt 的 Model-View 架构。\nview：系统提供两种候选词视图模式:单字模式(SingleCharCandidateView)，长句模式(LongSentenceCandidateView),里面设置成员QTableView\ndelegate: 通过继承QStyledItemDelegate实现自定义代理。对TableItem设置的动态属性进行样式绘制。\nmodel：通过继承QAbstractTableModel实现自定义模型。存储候选词数据，接受笔迹识别控制器传输的候选词数据。\n时序图 详细设计 候选词区域有2种模式：单字手写和长句手写\n在单字手写模式下，候选词区域(SingleCharCandidateView)由4部分组成，从上到下 提示窗口（QWidget* m_hintWidget）：显示鼠标hover的候选词，如果是汉字，添加拼音 单字候选词（QTableView* m_mainCandidateView）：3x3表格，显示单字 词组候选词（QTableView* m_phraseCandidateView）：2x2表，显示词组 4个工具按钮：标点、数字、字母、语言 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class SingleCharCandidateView : public CandidateView { Q_OBJECT public: // ... protected: // ... // 事件过滤器(过滤鼠标事件，未TableItem添加动态属性) bool eventFilter(QObject* watched, QEvent* event) override; private: QWidget* m_hintWidget{nullptr}; // 提示窗口 QLabel* m_hintLabel{nullptr}; // 提示文本 QLabel* m_pinyinLabel{nullptr};// 提示拼音 QTableView* m_mainCandidateView{nullptr}; // 3x3候选词表格 QTableView* m_phraseCandidateView{nullptr}; // 2x2词组表格 }; 在长句手写模式下，候选词区域(LongSentenceCandidateView)由2部分，从上到下 候选词（QTableView* m_candidateView）：1x9的表格，显示识别的长句 4个工具按钮：标点、数字、字母、语言 1 2 3 4 5 6 7 8 9 10 11 12 13 class LongSentenceCandidateView : public CandidateView { Q_OBJECT public: // ... protected: // 事件过滤器(过滤鼠标事件，未TableItem添加动态属性) bool eventFilter(QObject* watched, QEvent* event) override; private: // ... private: QTableView* m_candidateView{nullptr}; // 1x9候选词表格 }; 手写上屏 采用分离式设计：Qt程序负责手写识别，TSF模块负责文本服务\n使用命名管道（IPC）实现两个模块间的通信\nTSF模块以COM组件形式实现，注册为系统输入法\n基本流程：手写输入 -\u0026gt; Qt识别 -\u0026gt; IPC传输 -\u0026gt; TSF接收 -\u0026gt; 创建EditSession -\u0026gt; 插入文本\n该功能我没有测试通过，我成功了注册了输入法，实现了qt程序和tsf模块的通信，但是在创建编辑会话这一步，我无法将文本插入进去\n具体的模块划分\n核心组件：\nTextService类：实现TSF核心接口\nITfTextInputProcessor：输入法处理器接口\nITfThreadMgrEventSink：线程管理事件接口\nITfTextEditSink：文本编辑事件接口\nEditSession类：实现文本编辑会话负责实际的文本插入操作管理文本选区和光标位置\n","date":"2025-04-12T00:00:00Z","permalink":"https://sfw003.github.io/p/handwrite-input-method/","title":"手写输入法"},{"content":"单例模式 单例模式是指在内存只会创建且仅创建一次对象的设计模式，确保在程序运行期间只有唯一的实例。\n使用场景 当对象需要被共享的时候又或者某类需要频繁实例化.\n设备管理器，系统中可能有多个设备，但是只有一个设备管理器，用于管理设备驱动; 数据池，用来缓存数据的数据结构，需要在一处写，多处读取或者多处写，多处读取; 回收站,在整个系统运行过程中，回收站一直维护着仅有的一个实例; 应用程序的日志应用，一般都何用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加; 网站的计数器，一般也是采用单例模式实现，否则难以同步。 实际开发中，如果不是完美符合使用场景，不推荐使用。 如果实际开发经验不够，很容易看什么都是单例。\nc++实现 单例模式的关键点：创建且仅创建一次对象 2个关键点：\n如何只创建一次？ 如何禁止拷贝和赋值？（保证只有一个） 静态局部变量 对于1：这很容易想到静态局部变量 当一个函数中定义一个局部静态变量，那么这个局部静态变量只会初始化一次，就是在这个函数第一次调用的时候，以后无论调用几次这个函数，函数内的局部静态变量都不再初始化。\n对于2：可以将拷贝构造和赋值重载设置位私有成员。\n综上，我们可以得到第一个版本\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Singleton1 { public: static Singleton1\u0026amp; getInstance() { static Singleton1 s_single; return s_single; } private: Singleton1() = default; Singleton1(const Singleton1\u0026amp;) = delete; Singleton1\u0026amp; operator=(const Singleton1\u0026amp;) = delete; }; 上述版本的单例模式在C++11 以前存在多线程不安全的情况，多个线程同时执行这段代码，编译器可能会初始化多个静态变量。\nmagic static, 它是C++11标准中提供的新特性\n如果在初始化变量时控制同时进入声明，则并发执行应等待初始化完成。 如果当变量在初始化的时候，并发同时进入声明语句，并发线程将会阻塞等待初始化结束。 即c++规定各厂商优化编译器，能保证线程安全。所以为了保证运行安全请确保使用C++11以上的标准。\n/Zc:threadSafeInit 是 Microsoft Visual Studio 编译器中的一个编译选项，作用是启用线程安全的静态局部变量初始化。这个选项对于 C++11 引入的“magic statics”（线程安全的静态局部变量）机制尤为重要。 当启用 /Zc:threadSafeInit（默认在 C++11 及更高标准中启用）时，编译器会确保静态局部变量的初始化是线程安全的。这意味着如果多个线程首次访问同一个静态局部变量，编译器会保证该变量只被初始化一次，并确保其他线程可以看到初始化后的正确值。 VS2015+：默认启用线程安全初始化（等效于主动设置 /Zc:threadSafeInit）。 VS2013 及之前：不启用线程安全初始化，需手动加锁或升级编译器\n在项目- 属性 - C/C++ -命令行里可以查看。如果想禁用，输入/Zc:threadSafeInit- 实际开发中一定要注意是否遵循规定。 如果遵循，推荐使用静态局部变量的方式，又简单又安全。\n饿汉式（线程安全） 饿汉式：程序启动即初始化\n在C++11 推出以前，局部静态变量的方式实现单例存在线程安全问题，所以部分人提出了一种方案，就是在主线程启动后，其他线程没有启动前，由主线程先初始化单例资源，这样其他线程获取的资源就不涉及重复初始化的情况了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //饿汉式初始化 class Singleton2 { public: static Singleton2* getInstance() { if (s_single == nullptr) { s_single = new Singleton2(); } return s_single; } private: Singleton2() = default; Singleton2(const Singleton2\u0026amp;) = delete; Singleton2\u0026amp; operator=(const Singleton2\u0026amp;) = delete; static Singleton2* s_single; }; Singleton2* Singleton2::s_single = Singleton2::getInstance(); 虽然从使用的角度规避多线程的安全问题，但是又引出了很多问题，如1. 启动即初始化，可能导致程序启动时间延长。2. 从规则上束缚了开发者\n懒汉式（线程安全） 懒汉式：需要时即初始化\n事例何时初始化应该由开发者决定。因此我们使用懒汉式初始化。但懒汉式初始化存在线程安全问题，即资源的重复初始化，因此，我们需要加锁。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;mutex\u0026gt; class Singleton3 { public: static Singleton3* getInstance() { //这里不加锁判断，提高性能 if (s_single != nullptr) { return s_single; } s_mutex.lock();//1处 if (s_single != nullptr) //2处 { s_mutex.unlock(); return s_single; } s_single = new Singleton3();//3处 s_mutex.unlock(); return s_single; } private: Singleton3() = default; Singleton3(const Singleton3\u0026amp;) = delete; Singleton3\u0026amp; operator=(const Singleton3\u0026amp;) = delete; static Singleton3* s_single; static std::mutex s_mutex; }; Singleton3* Singleton3::s_single = nullptr; std::mutex Singleton3::s_mutex; 为什么2处要加一个判断呢？ 假如现在有线程A, B同时调用getInstance()\n此时s_single == nullptr， A和B同时进入1处，假设A加上锁，B等待 A执行完3处的命令后，通过s_mutex.unlock()解锁，此时B加上锁。 如果没有2处，B会再执行一遍3处，这会导致内存泄漏，而加上2处后，B会判断s_single != nullptr, 解锁返回 懒汉式（线程安全）+ 智能指针 但这还没完，懒汉式相比饿汉式有一个最大的不同：不确定是哪个线程初始化的。那之后由谁析构呢？ 其实不必操心，我们可以利用c++的RAIII，使用智能指针。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;mutex\u0026gt; class Singleton3 { public: static std::shared_ptr\u0026lt;Singleton3\u0026gt; getInstance() { if (s_single != nullptr) { return s_single; } s_mutex.lock(); if (s_single != nullptr) { s_mutex.unlock(); return s_single; } s_single = std::shared_ptr\u0026lt;Singleton3\u0026gt;(new Singleton3); s_mutex.unlock(); return s_single; } private: Singleton3() = default; Singleton3(const Singleton3\u0026amp;) = delete; Singleton3\u0026amp; operator=(const Singleton3\u0026amp;) = delete; static std::shared_ptr\u0026lt;Singleton3\u0026gt; s_single; static std::mutex s_mutex; }; std::shared_ptr\u0026lt;Singleton3\u0026gt; Singleton3::s_single = nullptr; std::mutex Singleton3::s_mutex; 有些人认为虽然智能指针能自动回收内存，如果有开发人员手动delete指针怎么办？将析构函数设为私有，为智能指针添加删除器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;mutex\u0026gt; class Singleton3 { public: static std::shared_ptr\u0026lt;Singleton3\u0026gt; getInstance() { if (s_single != nullptr) { return s_single; } s_mutex.lock(); if (s_single != nullptr) { s_mutex.unlock(); return s_single; } s_single = std::shared_ptr\u0026lt;Singleton3\u0026gt;(new Singleton3, [](Singleton3* single) { delete single; }); s_mutex.unlock(); return s_single; } private: Singleton3() = default; ~Singleton3() = default; //析构私有 Singleton3(const Singleton3\u0026amp;) = delete; Singleton3\u0026amp; operator=(const Singleton3\u0026amp;) = delete; static std::shared_ptr\u0026lt;Singleton3\u0026gt; s_single; static std::mutex s_mutex; }; std::shared_ptr\u0026lt;Singleton3\u0026gt; Singleton3::s_single = nullptr; std::mutex Singleton3::s_mutex; 上面的代码仍然存在危险，主要原因在于new操作是由三部分组成的\n分配内存 在第一个阶段，new 操作会调用内存分配函数（默认是 operator new），在堆上为新对象分配足够的空间。如果内存分配失败，通常会抛出 std::bad_alloc 异常。\n调用构造函数 分配到内存后，new 操作会在刚刚分配的内存上调用对象的构造函数，初始化该对象的各个成员。构造函数的参数可以在 new 语句中直接传递。\n返回指针 构造函数执行完毕后，new 操作会返回一个指向新创建对象的指针。如果是 new[] 操作符（即分配数组），则返回指向数组起始元素的指针\n这里的问题就再2和3的顺序上，有些编译器会优化，将2和3的顺序颠倒。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 static Singleton3* getInstance() { if (s_single != nullptr) //1处 { return s_single; } s_mutex.lock(); if (s_single != nullptr) { s_mutex.unlock(); return s_single; } s_single = new Singleton3();//2处 s_mutex.unlock(); return s_single; } 如果2和3的顺序颠倒，那么顺序变为 1.分配内存 3.返回指针 2.调用构造 可能出现下面的情况： 线程A执行到2处的new的第3步，此时s_single已经不为空，但是指向的对象还未调用构造。 线程B刚好执行1处，此时s_single != nullptr, 直接返回s_single。外部将接受到一个还没来的及调用构造函数的对象的指针。\n为解决这个问题，C++11 推出了std::call_once函数保证多个线程只执行一次\n懒汉式(线程安全)+智能指针+call_once std::call_once 是 C++11 引入的一个函数，用于保证某段代码在多线程环境中只被执行一次。这对单例模式、懒加载或只需执行一次的初始化操作非常有用。 std::call_once 与一个 std::once_flag 对象配合使用。std::once_flag 是一个标志，确保 std::call_once 所调用的函数只会执行一次，不论有多少个线程试图同时调用它。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;mutex\u0026gt; class Singleton { public: static std::shared_ptr\u0026lt;Singleton\u0026gt; getInstance() { static std::once_flag s_flag; std::call_once(s_flag, [\u0026amp;]() { s_single = std::shared_ptr\u0026lt;Singleton\u0026gt;(new Singleton, [](Singleton* single) { delete single; }); }); return s_single; } private: Singleton() = default; ~Singleton() = default; //析构私有 Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; static std::shared_ptr\u0026lt;Singleton\u0026gt; s_single; }; std::shared_ptr\u0026lt;Singleton\u0026gt; Singleton::s_single = nullptr; 懒汉式(线程安全)+智能指针+call_once+CRTP 为了让单例类更通用，可以通过继承实现多个单例类。 注：这里需要使用c++的CRTP（奇异递归模板模式），不知道是什么，自己查一下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;mutex\u0026gt; template\u0026lt;typename T\u0026gt; class Singleton { public: static std::shared_ptr\u0026lt;T\u0026gt; getInstance() { static std::once_flag s_flag; std::call_once(s_flag, [\u0026amp;]() { s_instance = std::shared_ptr\u0026lt;T\u0026gt;(new T); }); return s_instance; } protected: Singleton() = default; Singleton(const Singleton\u0026lt;T\u0026gt;\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026lt;T\u0026gt;\u0026amp;) = delete; static std::shared_ptr\u0026lt;T\u0026gt; s_instance; }; template\u0026lt;typename T\u0026gt; std::shared_ptr\u0026lt;T\u0026gt; Singleton\u0026lt;T\u0026gt;::s_instance = nullptr; class A :public Singleton\u0026lt;A\u0026gt; //CRTP { friend class Singleton\u0026lt;A\u0026gt;; public: //... }; friend class Singleton\u0026lt;A\u0026gt;;的目的是允许 Singleton\u0026lt;A\u0026gt; 类访问 A 的受保护构造函数。没有这个 friend 声明，Singleton\u0026lt;A\u0026gt; 将无法调用 A 的构造函数，从而无法在 getInstance 方法中正确地创建 A 的实例。\n","date":"2025-04-08T00:00:00Z","permalink":"https://sfw003.github.io/p/soft-project-design-pattern-singleton/","title":"单例模式"},{"content":"Bug 定义：一个计算机bug指在计算机程序中存在的一个错误(error)、缺陷(flaw)、疏忽(mistake)或者故障（fault)，这些bug使程序无法正确的运行。Bug产生于程序的源代码或者程序设计阶段的疏忽或者错误。\nBug的描述 描述bug的基本要素：问题出现的版本、问题出现的环境、问题出现的步骤、预期结果、实际结果、解决方案（可以不提）\n案例：\n问题出现的版本：谷歌浏览器版本123.0.6312.123（正式版本）(64位) 问题出现的环境：Windows家庭版 问题出现的步骤： 1、打开谷歌浏览器，输入网址https://www.101eduyun.com/ 2、等待首页页面渲染完成 预期结果：二维码与登陆模块不会出现遮挡，二维码可以正常扫描 实际结果：二维码被登陆模块遮挡，二维码扫描失败\nBug的级别 bug级别⼀般分为：崩溃、严重、⼀般、次要。具体参考公司的Bug文档\nBug的流程 ","date":"2025-04-07T00:00:00Z","permalink":"https://sfw003.github.io/p/soft-project-bug/","title":"bug"},{"content":"","date":"2025-04-07T00:00:00Z","permalink":"https://sfw003.github.io/p/soft-project-test-classification/","title":"测试分类"},{"content":"测试用例 测试用例（TestCase）是为了实施测试而向被测试的系统提供的一组集合，这组集合包含：测试环境、操作步骤、测试数据、预期结果等要素。\n设计思想 工具选择：\n过去的方式：Excel\n现在的方式：思维导图\n设计思想：\n正确设计测试用例的思想：常规思维+逆向思维+发散性思维 设计测试用例的原则二：\n测试用例的编写不仅应当根据有效和预料到的输入情况，而且也应该根据无效和未预料到的输入情况。 检查程序是否“未做其应该做的”仅是成功的一半，测试的另一半是检查程序是否“做了其不应该做的”。(是上一条原则的必然结果) 计划测试工作时不应默许假定不会发现错误。 设计方法 设计测试用例的万能公式：功能测试+界面测试+性能测试+兼容性测试+易用性测试+安全测试\n特殊测试：弱网测试，安装和卸载测试\n基于需求的设计方法 基于需求的设计方法也是总的设计测试用例的方法，在工作中，我们需要参考需求文档/产品规格说明书来设计测试用例。 测试人员接到需求之后，要对需求进行分析和验证，从合理的需求中进一步分析细化需求，从细化的需求中找出测试点，根据这些测试点再去设计测试用例。 以该注册邮箱账号需求为例，我们来设计测试用例。\n需求如下：\n根据万能公式，我们可以设计出基本的轮廓\n以功能测试为例： 上面的内容不包含具体的测试用例\n具体用例的设计方法 等价类和边界值法 上面的格式要求：6-15位字符，我们如何测试呢？分别测试6,7,8……15位吗。如果是6-1500位字符呢？显然穷举很麻烦， 我们采用方法是等价类。\n依据需求将输入（特殊情况下会考虑输出）划分为若干个等价类，从等价类中选出一个测试用例，如果这个测试用例测试通过，则认为所代表的等价类测试通过，这样就可以用较少的测试用例达到尽量多的功能覆盖，解决了不能穷举测试的问题。\n等价类分类：\n有效等价类：对于程序的规格说明书是合理的、有意义的输入数据构成的集合，利用有效等价类验证程序是否实现了规格说明中所规定的功能和性能 无效等价类：根据需求说明书，不满足需求的集合。 6-15位则可以划为\n有效等价类：[6, 15] 无效等价类：[0, 6) (15 正无穷) 但这还是几个区间，如何设计具体的值？边界值法\n边界值分析法就是对输入或输出的边界值进行测试的一种黑盒测试方法。通常边界值分析法是作为对等价类划分法的补充，这种情况下，其测试用例来自等价类的边界。\n边界值包含: 边界值、次边界值\n[6, 15]\n边界值为 6， 15 次边界值为5，16 正交法 测试用例案例 对命令进行测试 如对windows/linux的某个命令设计测试用例\n功能测试：对不同的文件类型进行测试 1）普通的txt文件能够生成zip文件 2）图片/视频/zip文件能够生成zip文件 3）多个文件能够生成zip文件(混合文件) 4）空文件夹可以生成zip文件 5）错误的命令是否可以解压 (zipzip/没有写压缩包文件名称/没有源文件) 6）其他参数的测试 界面测试： 1）文件压缩成功命令行提示是否美观 2）文件压缩报错命令行提示是否友好 性能测试： 1）文件大小超过1G时文件是否可以压缩 2）文件大小超过1G时文件压缩消耗的时间是否在合理的时间范围内 兼容性测试： 1）zip工具可以在多系统上使用，如Windows、Linux、Mac 易用性测试： 1）zip命令有使用帮助教程，如zip\u0026ndash;help命令下会展示如何使用 安全性： 1）使用zip命令不会泄漏文件内容\n对接口进行测试 假设一个论坛系统有接口\n1 2 3 4 http://ip:port/get?id=10 如果接口为 http://ip:port/get 返回所有的帖子 如果接口为 http://ip:port/get?id=10 返回id=10的帖子 对于接口测试，我们就不考虑界面测试、易用性测试、兼容性测试等等，专注于功能测试、安全测试。\n","date":"2025-04-07T00:00:00Z","permalink":"https://sfw003.github.io/p/soft-project-test-case/","title":"测试用例"},{"content":"","date":"2025-04-07T00:00:00Z","permalink":"https://sfw003.github.io/p/soft-project-automation-test/","title":"自动化测试"},{"content":"软件生命周期 软件生命周期（Software Development Life Cycle，SDLC）是软件开发和维护的整个过程，包括需求分析、设计、实现、测试、部署和维护等阶段。\n","date":"2025-04-06T00:00:00Z","permalink":"https://sfw003.github.io/p/soft-project/","title":"软件工程"},{"content":"编写软件过程中，程序员面临着来自耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性等多方面的挑战，设计模式是为了让程序(软件)，具有更好特性。\n代码复用性(即:相同功能的代码，不用多次编写)\n可读性(即:编程规范性，便于其他程序员的阅读和理解)\n可扩展性(即:当需要增加新的功能时，非常的方便，称为可维护)4)可靠性(即:当我们增加新的功能后，对原来的功能没有影响)5)使程序呈现高内聚，低耦合的特性\n七大原则 开闭原则 依赖倒转(倒置)原则 单一职责原则 接口隔离原则 里氏替换原则 迪米特法则 合成复用原则 开闭原则 * Open-Closed Principle, OCP\n对扩展开放，对更改关闭。 单一职责原则 * Simple Responsibility Pinciple，SRP\n不要存在多余一个导致类变更的原因。一个类应该应该只负责一项职责。\n每个应该实现单一职责，否则就应该把类拆分，便于后期的维护\n依赖倒转(倒置)原则 Dependence Inversion Principle,DIP\n高层模块(稳定)不应该依赖于底层模块(变化),二者都应该依赖于抽象(稳定)\n抽象(稳定)不应该依赖于实现细节(变化),实现细节应该依赖于抽象(稳定).\n数据库操作\n假设你有一个高层模块（比如用户管理模块），它需要访问数据库执行增、删、改、查操作。如果在不遵守依赖倒转原则的情况下，用户管理模块直接依赖于具体的数据库实现（例如 MySQL 操作），那么这个模块就与数据库紧密耦合，不利于扩展和测试。\n应用DIP：\n高层模块：用户管理模块定义一个接口 IDatabase，负责所有与数据库相关的操作。 低层模块：具体的数据库实现类（如 MySQLDatabase 或 PostgreSQLDatabase）实现 IDatabase 接口。 支付接口集成\n假设你的系统支持多种支付方式（如支付宝、微信支付、银行卡支付等），如果每次增加一种支付方式都需要修改支付处理的高层逻辑，就会导致代码的耦合度增加，违反了单一职责和开闭原则。\n应用DIP：\n高层模块：支付处理模块定义一个 IPaymentProcessor 接口。 低层模块：每种支付方式都实现 IPaymentProcessor 接口。 里氏替换原则 Liskov Substitution Principle,LSP\n通俗的来讲就是子类可以扩展父类的功能，但不能改变父类原有的功能。【尽量不用重写父类的方法】 动物类和鸟类\n假设有一个 Animal 类，它有一个 move 方法，表示动物的移动方式。Bird 类继承自 Animal 类，并且需要实现 move 方法来表示鸟类的飞行。这里的问题是，如果我们在 Bird 类中强行调用 move 方法来表示飞行，就可能出现不符合预期的行为，尤其是当 Bird 类具有一些不适用于其他动物的行为时。\n如果我们使用 LSP 来设计这个问题，应该将 move 方法根据动物的类型进行抽象，避免让所有的动物都遵循同样的 move 行为。我们可以将动物分为两类，Flyable 和 Swimmable，分别定义 fly 和 swim 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Animal { public: virtual void sound() = 0; // 动物发出声音 }; class Flyable { public: virtual void fly() = 0; // 可以飞的动物 }; class Swimmable { public: virtual void swim() = 0; // 可以游泳的动物 }; 接口隔离原则 Interface Segregation Principle,ISP\n使用多个专门的接口，而不使用单一的总接口，不应该强迫客户程序依赖它们不用的方法\n接口尽量细化，同时接口中的方法尽量少并且完备\n（注：这里和\u0026quot;单一职责\u0026quot;是有区别的,单一职责强调类的职责单一，站在业务逻辑的角度，这里强调的是接口，要求接口的方法尽可能的少而完备）\n符合我们常说的高内聚低耦合的设计思想，从而使得类具有很好的可读性、可扩展性和可维护性\n迪米特法则 迪米特原则（Law of Demeter LoD）是指一个对象应该对其他对象保持最少的了解，又叫最少知道原则（Least Knowledge Principle,LKP），尽量降低类与类之间的耦合。迪米特原则主要强调只和朋友交流，不和陌生人说话。出现在成员变量、方法的输入、输出参数中的类都可以称之为成员朋友类，而出现在方法体内部的类不属于朋友类。\n合成复用原则 合成复用原则的主要观点是，应该优先考虑使用组合，即将现有的类对象作为新类的成员变量，而不是继承已有的类\n但是组合是否优于继承完全取决实际情况。\n设计模式 单例模式 * 单例模式确保其一个类只有一个实例，而且自行实例化并向整个系统提供单个对象的模式。单例模式只应在有真正的“单一实例”的需求时才可使用。\n单例模式很常用，但也特别容易用错。一定要明确 单一实例的应用场景\n工厂模式 * 工厂模式将目的创建对象的具体过程屏蔽隔离起来，从而达到更高的灵活性，工厂模式可以分为三类：\n简单工厂模式(Simple Factory) 工厂方法模式(Factory Method) 抽象工厂模式(Abstract Factory) 一般用一下简单工厂就可以了\n简单工厂\n简单工厂模式就是一个工厂类根据传入的参数决定创建出哪一类产品类的实例，被创建的实例具有共同的父类或接口。\n举例：聊天消息\n工厂方法\n工厂方法模式：它也被叫做工厂模式。工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。\n工厂方法相对于简单工厂来说，就是把单一的工厂类，分成了多个具体的小厂，并抽象出一个工厂接口，这个接口只负责创建的方法，具体创建的过程由小工厂完成。\n抽象工厂\n抽象工厂模式是工厂方法的仅一步深化，在这个模式中的工厂类不单单可以创建一个对象，而是可以创建一组对象。这是和工厂方法最大的不同点。\n(这个模式最不好理解，而且在实际应用中局限性也蛮大的，因为这个模式并不符合开闭原则。实际开发还需要做好权衡。)\n建造者模式 建造者模式（Builder Pattern）是一种创建型设计模式，它允许使用多个简单的对象一步步构建成一个复杂的对象。建造者模式使得对象的创建过程独立于对象的组成部分以及如何组合它们。\n建造者模式的常见场景：\n当一个对象的构建过程中有多个步骤，且这些步骤的顺序、类型可能不同。 对象的构建过程独立于其组成部分的实现和顺序。 总结：分段初始化\n适配器模式 其实就和转接口一样\n策略模式 * 策略模式的作用就是把具体的算法实现从业务逻辑中剥离出来，成为一些列独立算法，使得它们可以相互转换。\n当你有多个算法可以完成某项任务，而且这些算法的使用在不同的情况下是可替换的。\n你希望避免使用多个条件语句（if 或 switch）来选择某个算法或行为\n支付方式选择\n假设你正在开发一个在线支付系统，用户可以选择不同的支付方式（如信用卡、支付宝、微信支付）。在这种情况下，使用策略模式可以帮助你避免在每个支付方式中编写大量的条件判断。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;memory\u0026gt; // 策略接口：支付方式 class PaymentStrategy { public: virtual void pay(double amount) = 0; // 每种支付方式的具体实现 virtual ~PaymentStrategy() = default; }; // 具体策略：信用卡支付 class CreditCardPayment : public PaymentStrategy { public: void pay(double amount) override { std::cout \u0026lt;\u0026lt; \u0026#34;Paying \u0026#34; \u0026lt;\u0026lt; amount \u0026lt;\u0026lt; \u0026#34; using Credit Card.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 具体策略：支付宝支付 class AlipayPayment : public PaymentStrategy { public: void pay(double amount) override { std::cout \u0026lt;\u0026lt; \u0026#34;Paying \u0026#34; \u0026lt;\u0026lt; amount \u0026lt;\u0026lt; \u0026#34; using Alipay.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 具体策略：微信支付 class WeChatPayment : public PaymentStrategy { public: void pay(double amount) override { std::cout \u0026lt;\u0026lt; \u0026#34;Paying \u0026#34; \u0026lt;\u0026lt; amount \u0026lt;\u0026lt; \u0026#34; using WeChat.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 上下文：订单类，负责选择支付方式 class Order { public: // 可以动态改变支付策略 void setPaymentStrategy(std::shared_ptr\u0026lt;PaymentStrategy\u0026gt; strategy) { paymentStrategy = strategy; } // 执行支付 void processPayment(double amount) { paymentStrategy-\u0026gt;pay(amount); } private: std::shared_ptr\u0026lt;PaymentStrategy\u0026gt; paymentStrategy; }; 观察者模式 * 观察者模式（Observer Pattern）是一种行为型设计模式，它定义了一种一对多的依赖关系，允许多个观察者对象同时监听某一个主题对象的状态变化。当主题对象的状态发生变化时，所有依赖于它的观察者都会得到通知并自动更新。\n当一个对象的状态变化需要同时影响到多个对象，并且这些对象之间存在松散耦合关系时。\n事件驱动系统，或某个状态变化会引发其他对象的行为（例如GUI界面中的按钮点击、发布订阅系统等）。\n天气预报系统\n假设我们正在设计一个天气预报系统，其中有多个显示屏（例如当前天气显示、统计显示、热力图显示等），当天气状态变化时，所有显示屏都需要更新自己的信息。我们可以使用观察者模式来解决这个问题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; // 观察者接口 class Observer { public: virtual void update(float temperature, float humidity, float pressure) = 0; virtual ~Observer() = default; }; // 被观察者接口（主题接口） class Subject { public: virtual void registerObserver(Observer* observer) = 0; virtual void removeObserver(Observer* observer) = 0; virtual void notifyObservers() = 0; virtual ~Subject() = default; }; // 具体主题类：天气数据 class WeatherData : public Subject { public: void registerObserver(Observer* observer) override { observers.push_back(observer); } void removeObserver(Observer* observer) override { observers.erase(std::remove(observers.begin(), observers.end(), observer), observers.end()); } void notifyObservers() override { for (Observer* observer : observers) { observer-\u0026gt;update(temperature, humidity, pressure); } } // 设置天气数据，并通知观察者 void setMeasurements(float temp, float hum, float pres) { temperature = temp; humidity = hum; pressure = pres; notifyObservers(); } private: std::vector\u0026lt;Observer*\u0026gt; observers; float temperature; float humidity; float pressure; }; // 具体观察者类：当前天气显示 class CurrentConditionsDisplay : public Observer { public: CurrentConditionsDisplay(Subject* weatherData) { this-\u0026gt;weatherData = weatherData; weatherData-\u0026gt;registerObserver(this); } void update(float temperature, float humidity, float pressure) override { this-\u0026gt;temperature = temperature; this-\u0026gt;humidity = humidity; display(); } void display() { std::cout \u0026lt;\u0026lt; \u0026#34;Current conditions: \u0026#34; \u0026lt;\u0026lt; temperature \u0026lt;\u0026lt; \u0026#34;°C and \u0026#34; \u0026lt;\u0026lt; humidity \u0026lt;\u0026lt; \u0026#34;% humidity\\n\u0026#34;; } private: float temperature; float humidity; Subject* weatherData; }; // 具体观察者类：统计天气显示 class StatisticsDisplay : public Observer { public: StatisticsDisplay(Subject* weatherData) { this-\u0026gt;weatherData = weatherData; weatherData-\u0026gt;registerObserver(this); } void update(float temperature, float humidity, float pressure) override { this-\u0026gt;temperature = temperature; this-\u0026gt;humidity = humidity; display(); } void display() { std::cout \u0026lt;\u0026lt; \u0026#34;Statistics: \u0026#34; \u0026lt;\u0026lt; temperature \u0026lt;\u0026lt; \u0026#34;°C, \u0026#34; \u0026lt;\u0026lt; humidity \u0026lt;\u0026lt; \u0026#34;% humidity\\n\u0026#34;; } private: float temperature; float humidity; Subject* weatherData; }; // 客户端代码 int main() { // 创建一个天气数据对象 WeatherData weatherData; // 创建观察者对象 CurrentConditionsDisplay currentDisplay(\u0026amp;weatherData); StatisticsDisplay statisticsDisplay(\u0026amp;weatherData); // 模拟天气变化 std::cout \u0026lt;\u0026lt; \u0026#34;Setting new weather measurements...\\n\u0026#34;; weatherData.setMeasurements(30.4f, 65.0f, 1012.0f); std::cout \u0026lt;\u0026lt; \u0026#34;\\nSetting new weather measurements...\\n\u0026#34;; weatherData.setMeasurements(25.0f, 70.0f, 1010.0f); return 0; } ","date":"2025-04-06T00:00:00Z","permalink":"https://sfw003.github.io/p/soft-project-design-pattern/","title":"设计模式"},{"content":"需求 业务需求 定义：反映企业或客户对系统的高层次目标，通常由项目发起人定义\n用户需求 用户需求：描述的是用户的具体目标，或用户要求系统必须能完成的任务。\n系统需求 系统需求：从系统角度来说明软件的需求，包括功能需求(系统必须实现的功能)、非功能需求(比如软件的质量，可维护性，效率等等)和设计约束(交付时的一些限制条件，比如必须采用国有自主知识产权的数据库，必须运行在某个操作系统下)等等。\n需求分析 绘制系统上下文范围关系图：用于定义系统与系统外部实体间界限和接口的简单模型，为需求确定范围； 创建用户界面原型：可以通过快速开发工具开发一个原型或者通过幻灯片、Flash等演示工具制作一个演示原型，甚至可以通过纸笔画出一些关键的界面接口示意图，从而帮助用户更好的理解要解决的问题，理解系统； 分析需求的可行性：对获取到的需求进行成本、性能和技术实现方面的可行性研究，以及是否与其他的需求存在冲突，是否有对外部的依赖等； 确定需求的优先级：是制订选代计划的一个重要的依据，可以使用满意和不满意指标进行说明。满意度表示当需求被实现时用户的满意程度，不满意度表示当需求未被实现时用户的不满意程度； 为需求建立模型：表现形式主要是图表加上少量的文字描述，图形化的描述使需求更加清晰、易懂。需求分析模型主要描述系统的数据、功能、用户界面和运行的外部行为，并不会涉及软件的具体实现细节，同时，为后续的软件设计提供了系统的表示视图； 创建数据字典：对系统用到的所有数据项和结构进行定义，以确保开发人员使用统一的数据定 义。 用例模型分析 用例图 你展示的就是一个详细的用例描述（Use Case Description）示例。这是用例文档的标准格式之一，用于详细描述每个用例的具体信息。让我解释一下用例描述的各个组成部分：\n用例描述 用例名称：用例的唯一标识符和名称\n例：发布帖子 简要说明：对用例功能的简短描述\n例：用户发布新帖子，同时增加对应版块帖子数量 事件流（基本流程）：描述用例的主要步骤\n用户的操作步骤 系统的响应步骤 按照时间顺序排列 备选事件流（替代流程）：描述可能的异常情况和处理方式\n例：如果标题为空，系统提示错误 非功能需求：与该用例相关的性能、安全等要求\n前置条件：执行用例前必须满足的条件\n例：用户必须登录系统 后置条件：用例执行完成后的系统状态\n例：更新帖子数量统计 扩展点：用例可能的扩展或变化点\n优先级：用例的重要程度\n可以用数字或描述表示 模版：\n用例名称 发布帖子 简要说明 用户发布新帖，同时增加对应版块帖子数量 事件流 1. 用户向系统发出发布新贴请求2. 系统展示编辑新帖界面3. 用户选择对应的版块类别，写入帖子标题与正文，并提交4. 系统检查版块类别、标题、正文是否有效5. 系统将所输入的信息存储建档，帖子发布成功 备选事件流 非功能需求 无 前置条件 用户必须登录系统进行权限校验 后置条件 修改对应版块下帖子的数量，修改用户发帖数 扩展点 无 优先级 最高(满意度5，不满意度5) 数据模型分析 E-R图 类图 1. 发现概念类\n概念类：模型中可以代表事物与概念的对象。 OOA的主要任务就是找到系统中的对象和类，这些类将反映到OOD中的软件类和OOP中具体的实 现类。 发现类的方式有很多种，其中应用最广泛的是名词短语法，具体步骤如下：\n阅读和理解需求文档或用例描述\n筛选出名词或名词短语，建立初始类清单(候选类)\n将候选类分为三类：分别是显而易见的类，明显无意义的类和不确定类别的类\n舍弃明显无意义类别的类\n小组讨论不确定类别的类，直到把他们合并或调整到其他两个类别。\n2. 确定类和类的关系\n当完成了类的寻找工作之后，就是理清这些类之间的关系，类之间的关系有：关联、依赖、泛化、聚合、组合和实现。\n3. 画图\n","date":"2025-04-06T00:00:00Z","permalink":"https://sfw003.github.io/p/soft-project-needs-analysis/","title":"需求分析"},{"content":"Qt 绘图框架 QPainter 与 QPaintDevice 和 QPaintEngine类一起构成了 Qt绘画系统的基础.\nQPainter 是用于执行绘图操作的类。 QPaintDevice 表示可以使用QPainter绘制的设备。Qt中绘图设备的基类，它是一个抽象类，用于描述可以绘制的设备,QPainter 在 绘图设备中绘制中,常用的绘图设备 QWidget、QPixmap 、QImage QPaintEngine提供了 Painter 用于在不同类型的设备上绘图的界面。对程序员不不透明，提供了不同类型设备的接口,由 QPaintDevice 和 QPainter 与其进行交互 如果 Painter处于活动状态，device()返回 Painter在其上绘画的绘制设备，paintEngine ()返回 Painter 当前正在操作的绘制引擎。有关更多信息，请参阅绘制系统。\nQPaintDevice QWidget 、QImage 、QPixmap 等等绘图场景都是从 QPainterDevice 继承而来的。\n1 2 3 4 5 6 class Q_WIDGETS_EXPORT QWidget : public QObject, public QPaintDevice {} class Q_GUI_EXPORT QImage : public QPaintDevice {} class Q_GUI_EXPORT QPixmap : public QPaintDevice {} QPainter QPainter 是用于执行绘图操作的类，需要配合辅助类来使用，常见的有以下三种\nQPen 描述画笔，用户画线 QBrush 描述画刷，用于填充 QColor 描述颜色 Qt绘图事件 绘图事件处理触发时机\n在窗口部件第一次显示时，系统会自动产生一个绘图事件(QPaintEvent),从而强制绘制这个窗口部件 当重新调整窗口部件的大小时，系统也会产生一个绘制事件 调用 update( 或者repaint()) 函数 1 2 void QWidget::update() void QWidget::repaint() update和repaint的区别：\nupdate是一个异步函数,它会将绘图事件添加到事件队列中,当事件循环回到主线程时，会调用组件的 paintEvent() 函数进行实际的重绘工作 是一个同步函数，会立即触发组件的重绘操作,不会等待事件循环 Qt绘图实战 QPen 线型风格(Qt::PenStyle) 端点风格( Qt::PenCapStyle) 连接风格(Qt::PenJoinStyle) 使用案例\n1 2 3 4 5 6 7 8 9 QPainter painter(this); QPen pen; pen.setStyle(Qt::DashDotLine); //设置线性风格 pen.setWidth(3); pen.setBrush(Qt::green); //设置刷子 pen.setCapStyle(Qt::RoundCap); //设置端点风格 pen.setJoinStyle(Qt::RoundJoin); //设置连接风格 painter.setPen(pen); QBrush QBrush用于描述画刷，Qt中用于描述绘图区域填充样式的类。它可以用于指定绘图区域的背景色、渐变色、纹理、图片等\nQColor QColor 是Qt中用于表示颜色的类。它可以用于描述RGB颜色、RGBA颜色、HSL颜色、HSV颜色以及16进制颜色等。\n1 2 3 4 5 QColor color(Qt::red); // 使用预定义颜色 QColor color(255, 0, 0); // 使用RGB值 QColor color(\u0026#34;#FF0000\u0026#34;); // 使用16进制值 color.setRgb(255, 0, 0); // 设置RGB颜色值 color.setHsl(0, 255, 127); // 设置HSL颜色值 Qt坐标 QPainter 使用的坐标系是组件自身坐标系，如果通过 geometry() 函数与 pos() 函数获取的坐标是基于父组件的坐标系\n相对于父组件的坐标可以通过 mapFromParent 函数进行转换，得到想的自己的坐标系\n1 2 3 4 //获得相对父控件的坐标 QPoint centerPointFromParent = this-\u0026gt;geometry().center(); //获得相对自身的坐标 QPoint centerPoint = mapFromParent(centerPointFromParent); Qt图形变换 在图形变换操作时,是对坐标系进行变换\n1 2 3 4 void QPainter::scale(qreal sx, qreal sy) // 缩放 void QPainter::rotate(qreal angle) // 旋转 void QPainter::shear(qreal sh, qreal sv) // 扭曲 void QPainter::translate(qreal dx, qreal dy) // 平移 ","date":"2025-04-04T00:00:00Z","permalink":"https://sfw003.github.io/p/qt-gui_01_qt_drawing_framework/","title":"【Qt GUI 01】Qt 绘图框架"},{"content":"MVC 模型-视图-控制(MVC) 是源自 Smalltalk 的一种设计模式,在构建用户界面时经常使用。用于将应用程序的数据、逻辑和界面分离，以提高代码可读性、可维护性和可扩展性\nMVC 框架由三个对象组成:\nModel (模型) : 负责存储和处理数据，通常与数据库进行交互。模型表示应用程序的核心逻辑,例如数据结构、数据处理和存储等 View (视图) ：负责显示数据，将模型中的数据可视化。视图是用户与系统交互的接口,通常包括图形用户界面 GUI 或者网页 Controller (控制器 ） : 负责接收用户输入，处理用户请求，并更新模型和视图 QT Model-View 在Qt中，Model-View是一种设计模式，用于将数据（Model）与其可视化表示（View）分离，使得程序更加模块化、可扩展和易于维护。\nModel/View 框架主要包括以下三个组件\nModel：模型是数据的抽象表示，它负责存储和管理数据。\n模型通常从底层数据源（如数据库、文件或数据结构）获取数据，并将其呈现给视图。 View : 视图是数据的可视化表示，它负责呈现模型中的数据。\n视图可以有多种形式，如表格、列表、树状结构等 Delegate : 委托负责处理数据的显示和编辑。委托可以自定义单元格的渲染方式，以及将用户输入的数据写回模型\n如果用户没有设置委托，则使用默认委托 View 在 Qt 内部实现了多个可以支持 Model/View 的视图,具体如下:\n视图名称 描述 示例 QListView 用于显示单列的列表数据，适用于一维数据的操作 QTreeView 用于显示树状结构数据，适用于树状结构数据的操作 QTableView 用于显示表格状数据，适用于二维表格型数据的操作 QColumnView 用于多个QListView显示树状层次结构，树状结构的一层用一个QListView显示。 它们的继承关系如下图。\n自定义View Model 模型 描述 QStandardItemModel 1.通用的数据模型类，可以存储各种类型的数据（如列表、树形结构、表格等）2.是 QAbstractItemModel 的子类，提供了一组用于管理数据项（如添加、删除、修改等）的便捷方法 QStringListModel 1.用于存储字符串列表的数据模型类，2.是 QAbstractListModel 的子类，可以方便地管理字符串列表（如添加、删除、修改等3.适用于需要展示和操作字符串列表的场景，如列表框、下拉框 QFileSystemModel 用于访问文件系统的数据模型类是 QAbstractItemModel 的子类,可以表示文件系统的目录结构和文件信息适用于需要浏览和操作文件系统的场景，如文件选择器、文件管理器等 QSqlTableModel 一个用于访问 SQL 数据库的数据模型类是 QAbstractTableModel 的子类,可以表示 SQL 数据库中的表格数据QSqlTableModel 提供了一组用于查询、插入、更新和删除数据库记录的方法。它适用于需要与 SQL 数据库交互的场景。 QSqlRelationalTableModel 用于访问带有关系的 SQL 数据库的数据模型类是 QSqlTableModel 的子类，可以表示 SQL 数据库中的关系表格数据QSqlRelationalTableModel 提供了一组用于处理关系字段（如外键）的方法。适用于需要表示和操作关系数据库的场景。 QSortFilterProxyModel 代理模型类，用于对其他模型数据进行排序和过滤是 QAbstractProxyModel 的子类,可以作为其他模型（如上述内置模型）的代理，对数据进行排序和过滤QSortFilterProxyModel 适用于需要对数据进行排序和过滤的场景，如表格视图、树形视图等 Model索引 所有的模型都是统一通过模型索引来访问数据，它用于表示数据模型中特定数据项的位置 模型索引由QModellndex类来表示，包含了一个数据项的行、列和父索引信息 关于QModellndex类一些主要特性如下：\n行和列：QModellndex包含一个数据项在模型中的行和列信息 父索引：QModellndex还包含一个父索引l，表示数据项的父项，对于树形结构的模型（如QStandardltemModel或QFileSystemModel特别有用 有效性：QModellndex可以是有效或无效的。有效索引表示模型中实际存在的数据项，而无效索引表示一个空或未定义的位置 数据访问：通过模型索引，可以访问和操作模型中的数据 模型指针：QModellndex包含一个指向其所属模型的指针 获取索引的函数是index，它在这一层定义\n1 2 QAbstracTableMode: QModelIndex\tindex(int row, int column, const QModelIndex \u0026amp;parent = QModelIndex()) const override 自定义Model 系统的标准模型(QStandardltemModel）主要支持字符串与图标(Qlcon)，对于其他类型支持能力较弱 如果需要显示自定义数据结构，则更好的方式是采用自定义模型，同时对于大量数据的处理，自定义数据模型可以实现数据的按需加载、缓存等策略，以提高视图的性能。\n自定义模型基本实现思路：\n明确自定义模型需要处理的数据结构和特点，如树形结构，列表或者表格 根据数据结构的特点，选择合适的基类，下面列举了相应的数据类型对应的比较合适的基类 数据结构类型 自定义模型基类 表格 QAbstractTableModel 列表 QAbstractListModel 通用 QAbstractItemModel 继承这些模型后，需要实现以下函数（不同的模型实现的函数不同）\n方法原型 方法描述 int rowCount(const QModelIndex\u0026amp; parent) const 返回数据模型的行数 int columnCount(const QModelIndex\u0026amp; parent = QModelIndex()) 返回数据模型的列数 QVariant data(const QModelIndex\u0026amp; index, int role = Qt::DisplayRole) const ; 返回指定数据模型中指定单元格数据 QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole 返回表头数据 bool setData(const QModelIndex \u0026amp;index, const QVariant \u0026amp;value, int role = Qt::EditRole); 设置指定索引的项的数据 QModelIndex index(int row, int column, const QModelIndex \u0026amp;parent = QModelIndex()) const; 返回给定行和列的项的索引 QModelIndex parent(const QModelIndex \u0026amp;child) const; 返回给定子项的父项的索引 Qt::ItemFlags flags(const QModelIndex \u0026amp;index) const; 返回给定索引的项的标志 bool insertRows(int row, int count, const QModelIndex \u0026amp;parent = QModelIndex()); 在给定位置插入指定数量的行 bool removeRows(int row, int count, const QModelIndex \u0026amp;parent = QModelIndex()); 从给定位置移除指定数量的行 bool insertColumns(int column, int count, const QModelIndex \u0026amp;parent = QModelIndex()); 在给定位置插入指定数量的列 bool removeColumns(int column, int count, const QModelIndex \u0026amp;parent = QModelIndex()); 从给定位置移除指定数量的列 其中最重要的是\nQVariant data(const QModelIndex\u0026amp; index, int role = Qt::DisplayRole) const ; index 是索引 role则是角色说明，Qt里有自带的角色说明 DisplayRole (0)，这是最基本的角色，通常用来显示文本内容 DecorationRole (1)，通常用来显示图标或图片 如果是自定义Model, 最好使用自定义.\n数据的更改和增加，可以使用bool insertColumns(int column, int count, const QModelIndex \u0026amp;parent = QModelIndex()); 。。。\n简易使用自定义函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 添加一个新的笔画 void StrokeModel::addStroke(const StrokeData\u0026amp; stroke) { // 通知视图即将插入新行 beginInsertRows(QModelIndex(), m_strokes.size(), m_strokes.size()); // 创建新的笔画数据，使用当前样式和时间戳 StrokeData newStroke = stroke; newStroke.style = m_currentStyle; newStroke.timestamp = QDateTime::currentMSecsSinceEpoch(); m_strokes.append(newStroke); // 添加到笔画列表中 // 通知视图插入完成 endInsertRows(); emit strokeAdded(m_strokes.size() - 1); // 发射笔画添加信号，处理handwriteview的按钮更新 } 使用自定义函数就需要关注：通知\nbeginRemoveRows 和 endRemoveRows 主要用于通知视图模型的结构变化（即行的添加或删除）\n这对函数主要影响视图的行管理，比如：\n更新视图的行数\n更新行的索引\n更新视图的滚动范围等\ndataChanged 信号用于通知视图数据内容的变化\n这个信号会触发视图的重绘操作\n它告诉视图：\u0026ldquo;这些数据已经改变，你需要重新绘制它们\nDelegate Qt Delegate 负责数据的编辑和渲染。当用户需要编辑数据时，Delegate负责提供编辑器，同时负责将编辑后的数据写回Model\nQt 内置支持 MVD 模式的组件都是支持 QTableView,QTreeView 都支持默认委托,用于基本数据类型的渲染,包括文本、数字和图像，还有默认编辑组件 QLineEdit\n默认委托是由 ﻿QStyledItemDelegate 类来进行过描述,继承于QAbstractItemDelegate\n当遇到单元格的内容非文本，数字和图像等基本数据类型，则应该考虑自定义 Delegate,如下面应用场景\n委托类名称 描述 父类 QItemDelegate 基本的委托类，提供默认的渲染和编辑功能 QAbstractItemDelegate QStyledItemDelegate 继承自 QItemDelegate，提供更好的样式支持和性能 QItemDelegate 自定义Delegate 在实现自定义 Delegate 主要方式就是选择合适的 Delegate 基类，并重写实现相应的方法,这里一般选择 QStyledItemDelegate作为基类\nvirtual QWidget *createEditor(QWidget *parent, const QStyleOptionViewItem \u0026amp;option, const QModelIndex \u0026amp;index) const 自定义单元格编辑器组件 *virtual void paint(QPainter painter, const QStyleOptionViewItem \u0026amp;option, const QModelIndex \u0026amp;index) const = 0 自定义组件绘制 virtual void setEditorData(QWidget *editor, const QModelIndex \u0026amp;index) const 将模型数据设置到编辑器 virtual void setModelData(QWidget *editor, QAbstractItemModel *model, const QModelIndex \u0026amp;index) const 将编辑后的数据设置到模型 virtual void updateEditorGeometry(QWidget *editor, const QStyleOptionViewItem \u0026amp;option, const QModelIndex \u0026amp;index) const 自定义编辑器的几何位置 ","date":"2025-04-04T00:00:00Z","permalink":"https://sfw003.github.io/p/qt-mvc/","title":"【Qt MVC】model-view-delegate"},{"content":"Qt 布局管理 基本布局 Qt 的布局管理系统提供了多种布局管理器类，用于自动排列和管理控件的位置与大小，确保界面在不同分辨率下保持美观和功能性。以下是其核心布局类及其特点的总结：\nQHBoxLayout（水平布局） • 功能：将控件从左到右水平排列，适用于工具栏、按钮组等横向布局场景。 • 特点：自动调整控件间距，支持拉伸系数（stretch）控制控件宽度占比。 • 代码示例：\n1 2 3 QHBoxLayout *layout = new QHBoxLayout; layout-\u0026gt;addWidget(button1); layout-\u0026gt;addWidget(button2); QVBoxLayout（垂直布局） • 功能：将控件从上到下垂直排列，常用于表单、列表等纵向布局。 • 特点：支持设置空白区域（addStretch()）和固定间距（addSpacing()），灵活分配空间。\n1 2 3 QVBoxLayout *layout = new QVBoxLayout; layout-\u0026gt;addWidget(label1); layout-\u0026gt;addWidget(lineEdit); QGridLayout（网格布局） • 功能：将控件按行和列排列成网格，支持控件跨行或跨列。 • 特点：适用于复杂界面（如计算器、表格），通过 addWidget(widget, row, column, rowSpan, columnSpan) 指定位置。\n1 2 3 QGridLayout *layout = new QGridLayout; layout-\u0026gt;addWidget(button1, 0, 0); // 第0行第0列 layout-\u0026gt;addWidget(button2, 0, 1, 1, 2); // 跨2列 QFormLayout（表单布局） • 功能：专为表单设计，每行包含标签（如 QLabel）和输入控件（如 QLineEdit）。 • 特点：自动对齐标签和输入框，简化登录界面、设置对话框的开发。\n1 2 3 QFormLayout *layout = new QFormLayout; layout-\u0026gt;addRow(\u0026#34;用户名:\u0026#34;, lineEditUser); layout-\u0026gt;addRow(\u0026#34;密码:\u0026#34;, lineEditPass); ","date":"2025-04-04T00:00:00Z","permalink":"https://sfw003.github.io/p/qt-widgets_layout_management/","title":"【Qt Widgets】Qt 布局管理"},{"content":"io过程分析 PIO模式 编程式IO（Process IO)：数据需通过 CPU 寄存器中转，完全占用 CPU（早期设备的实现方式）\nCPU发出对应的指令给磁盘控制器，然后返回； 磁盘控制器收到指令后，于是就开始准备数据，会把数据放入到磁盘控制器的内部缓冲区中，然后产生一个中断; CPU收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节地读进自己的寄存器，然后再把寄存器里的数据写入到内存。在数据传输的期间CPU是无法执行其他任务的。 %% 时序图：CPU与磁盘控制器的交互（PIO模式） sequenceDiagram participant 用户进程 participant CPU participant 磁盘控制器 participant 内存 用户进程-\u003e\u003eCPU: read() 系统调用（用户态→内核态） CPU-\u003e\u003e磁盘控制器: 发送读取指令 Note over CPU: CPU返回继续执行其他任务 磁盘控制器-\u003e\u003e磁盘控制器: 准备数据到内部缓冲区 磁盘控制器-\u003e\u003eCPU: 产生中断信号 loop 逐个字节传输 磁盘控制器-\u003e\u003eCPU: 从缓冲区读取一个字节到寄存器 CPU-\u003e\u003e内存: 将寄存器数据写入内存 Note over CPU: CPU 无法执行其他任务 end CPU-\u003e\u003e用户进程: 完成中断处理（内核态→用户态） CPU-\u003e\u003e用户进程: read() 返回数据 DMA模式 直接内存访问（Direct Memory Access）技术：DMA将数据从磁盘控制器缓冲区搬运到内存，不需要 CPU 逐字节参与（现代通用方案）\n用户进程调用read方法，向操作系统发出I/O请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态; 操作系统收到请求后，进一步将I/O请求发送DMA，然后让CPU执行其他任务； DMA进一步将I/O请求发送给磁盘； 磁盘收到DMA的I/O请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向DMA发起中断信号，告知自己缓冲区已满； DMA收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用CPU，CPU可以执行其他任务； 当DMA读取了足够多的数据，就会发送中断信号给CPU; CPU收到DMA的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回； sequenceDiagram participant 用户空间 participant CPU participant DMA participant 磁盘控制器 participant 内核空间 用户空间-\u003e\u003eCPU: read() 系统调用 CPU-\u003e\u003eDMA: 配置传输参数（内存地址、数据长度等） Note over CPU: CPU返回继续执行其他任务 DMA-\u003e\u003e磁盘控制器: 发送IO请求 磁盘控制器-\u003e\u003e磁盘控制器: 准备数据到内部缓冲区 磁盘控制器-\u003e\u003eDMA: 数据就绪中断 DMA-\u003e\u003e内核空间: DMA自动搬运数据（无需CPU参与） DMA-\u003e\u003eCPU: 传输完成中断 CPU-\u003e\u003e用户空间: 返回数据 早期DMA只存在在主板上，如今由于I/O 设备越来越多，数据传输的需求也不尽相同，所以每个I/O设 备里面都有自己的DMA控制器。\n传统IO的效率分析 IO可以划分为2个过程：等待数据就绪+数据拷贝\n我们先说传统IO的数据拷贝\n多次切换和拷贝 对于一次read + write，总共发生4次用户态和内核态的上下文切换和4次数据拷贝\n上下文切换\nread的调用和返回：2次 write的调用和返回：2次 数据拷贝\n外存（如磁盘、网卡）到内核空间，内核空间再到用户空间：2次 用户空间到内核空间，内核空间到外存：2次 上下文切换到成本并不小，一次切换需要耗时几十纳秒到几微秒，虽然时间看上去很短，但是在高并发的场景下，这类时间容易被累积和放大，从而影响系统的性能，数据拷贝同理。\n等待数据就绪 对于本地，多数情况下数据都是就绪的，但到了网络，情况就不同了，等待时间往往大于数据拷贝时间。在传统IO中，往往是阻塞式等待，导致用户进程浪费了很多时间。\n如何提高IO效率 2个维度：\n减少等待时间（即在等待时间内做其他事） 减少上下文切换和数据拷贝的次数 关于内核缓存区 前文一直提到一个叫名词：内核缓存区，内核缓存区是什么？内核缓冲区实际上是磁盘高速缓存（PageCache）。\n它采用局部型原理来提高速度，举例：用户需要读取磁盘某部分0-50字节的内容，PageCache会预读0-100字节的内容。\n多数情况下，PageCache能提高速率，但如果文件很大，PageCache的作用就体现不了，原因有2：\nPageCache 本身容量较小，读取大文件时，导致PageCache长时间被大文件占据，其他热点小文件可能就无法充分使用到 PageCache，于是磁盘读写的性能就会下降了 PageCache 中的大文件数据，不但没有享受到缓存带来的好处，还耗费 DMA 多拷贝到 PageCache一次； 那如何解决大文件的读取呢？\n综上，我们留下了3个问题：\n如何减少等待时间（即在等待时间内做其他事）\n如何减少上下文切换和数据拷贝的次数\n如何高效读取大文件\n减少上下文切换和数据拷贝次数 零拷贝技术 零拷贝技术的核心目标是通过减少或消除用户空间与内核空间之间的数据复制次数，从而提升性能并降低资源消耗。\n实现零拷贝技术的方式有很多。\n内存映射 我目前就使用过这个\n原理如下图，将文件直接映射到进程的虚拟内存地址空间，用户程序通过操作内存指针访问文件数据，无需通过read/write系统调用复制数据\nwindows的api\nlinux的api\n1 2 // 直接通过addr指针访问文件数据 void *addr = mmap(file_fd, file_size, PROT_READ, MAP_SHARED); 基本流程：\n1 2 void* addr = mmap(file, len); write(fd, addr, len); graph TD A[磁盘文件] --\u003e|DMA 拷贝| B[缓存区] B --\u003e|CPU 拷贝| C[socket 缓冲区] C --\u003e|DMA 拷贝| D[网卡] 上下文切换次数：4次\nmmap的调用和返回 write的调用和返回 数据拷贝次数：3次\n优势：减少用户态与内核态之间的数据拷贝次数，适用于频繁访问文件的场景（如数据库、视频处理）\nsendfile 系统调用 原理：直接在内核空间完成文件数据到网络套接字的传输，绕过用户空间。 • 传统流程：磁盘 → 内核缓冲区 → 用户缓冲区 → 内核缓冲区 → 网络。 • sendfile流程：磁盘 → 内核缓冲区 → 网络（无需用户空间参与）。 • 适用场景：文件传输（如Web服务器发送静态文件）。 • 代码示例（Linux）：\n1 sendfile(out_fd, in_fd, NULL, file_size); 技术 实现方式 适用场景 引用来源 内存映射 文件映射到虚拟内存 频繁文件读写（数据库、视频） sendfile 内核直接传输文件到网络 Web服务器文件传输 splice 管道传输数据 文件/网络间高效复制 分散-聚集 单次操作多缓冲区 网络协议分片处理 DMA 硬件直接访问内存 高速I/O设备数据传输 减少等待时间 感觉叫减少等待时间不是很准确，应该叫利用等待时间。我们怎么做到在数据未就绪的时候干其他事呢？通过采用高效的IO模型。\n我们常见的IO模型有以下5种：\n5种IO模型 阻塞IO 一直等，直到数据就绪。\n非阻塞IO 非阻塞IO往往需要程序员循环的方式反复尝试读写文件描述符, 这个过程称为轮询. 这对CPU来说是较大的浪费, 一般只有特定场景下才使用. 不等，但会一直询问数据是否就绪，一旦就绪就处理。\n信号驱动IO 不等，数据就绪后，系统通过信号来通知进程处理。\nIO多路转接 （多路复用） IO多路转接: 虽然从流程图上看起来和阻塞IO类似. 实际上最核心在于IO多路转接能够同时等待多个文件描述符的就绪状态. 异步IO 由内核在数据拷贝完成时, 通知应用程序(而信号驱动是告诉应用程序何时可以开始拷贝数据). 总结：5种IO好比5种钓鱼方式\n阻塞IO: 一直盯着鱼竿直到中鱼 非阻塞IO: 看会手机，看会鱼竿，发现中鱼，收杆 信号驱动IO: 一直看手机，直到鱼竿抖动，收杆 多路复用IO: 同时使用多个鱼竿，一直等，直到中鱼 异步IO: 让小弟去等鱼竿，自己干其他事，等中鱼了，让小弟打电话通知我 前4种都属于同步IO，\n同步和异步关注的是消息通信机制.\n所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回. 但是一旦调用返回，就得到返回值了; 换句话说，就是由调用者主动等待这个调用的结果; 异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果; 换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果; 而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用 现在回答：哪种IO模型最能充分利用等待时间？异步IO\n模型 开发难度 性能 典型应用场景 阻塞I/O 简单 低 低并发文件读写 非阻塞I/O 中等 中 传感器轮询 信号驱动I/O 复杂 中高 UDP协议通信 多路复用I/O 复杂 高 Web服务器（Nginx） 异步I/O 复杂 极高 分布式存储系统 技术演进趋势：现代高并发系统（如Kafka、Netty）普遍采用多路复用+异步I/O组合模型，在降低线程开销的同时实现高吞吐量\n1 2 3 4 5 6 +-------------------+ +------------------+ +-------------------+ | 多路复用线程 | | 异步I/O线程池 | | 业务处理线程池 | | (epoll_wait循环) | ----\u0026gt; | (io_uring提交任务) | ----\u0026gt; | (处理HTTP请求等) | +-------------------+ +-------------------+ +-------------------+ ↑ ↑ ↑ 监控事件就绪 提交异步任务 处理完成回调 IO多路复用详解 select I/O多路转接之select 系统提供select函数来实现多路复用输入/输出模型.\nselect系统调用是用来让我们的程序监视多个文件描述符的状态变化的; 程序会停在select这里等待，直到被监视的文件描述符有一个或多个发生了状态改变; select接口介绍\n1 2 3 4 #include \u0026lt;sys/select.h\u0026gt; int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); int nfds 参数类型：输入型参数 说明：待检测的文件描述符中最大的文件描述符值加一\nfd_set * readfds/writefds/exceptfds 参数类型：输入输出型参数 说明：fed_set是内核提供的一种数据类型，本质是位图.它的作用如下图： readfds \u0026ndash; 监控可读 writefds \u0026ndash; 监控可写 exceptfds - -监控错误\nstruct timeval * timeout 参数类型：输入输出型参数 说明：超时时间，如果为 NULL，则 select 函数会一直阻塞直到有事件发生；如果为非 NULL，则表示最长等待时间。 struct timeval timeout = {1, 0}; 就表示最长等待时间为1秒\n返回值 int n = select() 如果n \u0026gt; 0\t表明有n个fd就绪 如果n == 0\t表明超时 如果n \u0026lt; 0\t表明出错\n先介绍几个select的附属函数：select的参数fd_set是位图，如果让用户自己修改，不安全也不方便，与开发者也提供了几个专门修改fd_set的函数\n1 2 3 4 void FD_CLR(int fd, fd_set *set); -- 清空 int FD_ISSET(int fd, fd_set *set); -- 是否已经设置 void FD_SET(int fd, fd_set *set); -- 设置 void FD_ZERO(fd_set *set); -- 清0 select的例子\n这里不会对select的例子进行讲解，因此select太麻烦了。 select需要一个辅助数组，这个数组是用来保存sockfd（包括listensockfd， 已经客户端连接的sockfd)。为什么？原因在于select的参数。 第1个参数：nfds = maxfd+1，每次使用select时，都要遍历辅助数组来获得最大的fd，麻烦（当然你也可以设置成员来专门存储maxfd, 真正麻烦在后面）。 第2，3、4个参数：由于它们在调用select前后，比特位的含义发生了变化。（前表示是否监控，后表示是否就绪）因此你每次在调用之前都要重新设置。但你怎么知道要保存哪些fd？因此需要一个辅助数组来记录fd。在调用select前，遍历辅助数据来设置fd_set。 因此，select会出现很多遍历。代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 #pragma once #include \u0026lt;iostream\u0026gt; #include \u0026lt;sys/select.h\u0026gt; #include \u0026lt;sys/time.h\u0026gt; #include \u0026#34;Socket.hpp\u0026#34; using namespace std; static const uint16_t defaultport = 8888; static const int fd_num_max = (sizeof(fd_set) * 8); int defaultfd = -1; class SelectServer { public: SelectServer(uint16_t port = defaultport) : _port(port) { for (int i = 0; i \u0026lt; fd_num_max; i++) { fd_array[i] = defaultfd; // std::cout \u0026lt;\u0026lt; \u0026#34;fd_array[\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;]\u0026#34; \u0026lt;\u0026lt; \u0026#34; : \u0026#34; \u0026lt;\u0026lt; fd_array[i] \u0026lt;\u0026lt; std::endl; } } bool Init() { _listensock.Socket(); _listensock.Bind(_port); _listensock.Listen(); return true; } void Accepter() { // 我们的连接事件就绪了 std::string clientip; uint16_t clientport = 0; int sock = _listensock.Accept(\u0026amp;clientip, \u0026amp;clientport); // 会不会阻塞在这里？不会 if (sock \u0026lt; 0) return; // sock -\u0026gt; fd_array[] int pos = 1; for (; pos \u0026lt; fd_num_max; pos++) // 第二个循环 { if (fd_array[pos] != defaultfd) continue; else break; } if (pos == fd_num_max) { lg(Warning, \u0026#34;server is full, close %d now!\u0026#34;, sock); close(sock); } else { fd_array[pos] = sock; PrintFd(); } } void Recver(int fd, int pos) { // demo char buffer[1024]; ssize_t n = read(fd, buffer, sizeof(buffer) - 1); // bug? if (n \u0026gt; 0) { buffer[n] = 0; cout \u0026lt;\u0026lt; \u0026#34;get a messge: \u0026#34; \u0026lt;\u0026lt; buffer \u0026lt;\u0026lt; endl; } else if (n == 0) { lg(Info, \u0026#34;client quit, me too, close fd is : %d\u0026#34;, fd); close(fd); fd_array[pos] = defaultfd; // 这里本质是从select中移除 } else { lg(Warning, \u0026#34;recv error: fd is : %d\u0026#34;, fd); close(fd); fd_array[pos] = defaultfd; // 这里本质是从select中移除 } } void Dispatcher(fd_set \u0026amp;rfds) { for (int i = 0; i \u0026lt; fd_num_max; i++) // 这是第三个循环 { int fd = fd_array[i]; if (fd == defaultfd) continue; if (FD_ISSET(fd, \u0026amp;rfds)) { if (fd == _listensock.Fd()) { Accepter(); // 连接管理器 } else // non listenfd { Recver(fd, i); } } } } void Start() { int listensock = _listensock.Fd(); fd_array[0] = listensock; for (;;) { fd_set rfds; FD_ZERO(\u0026amp;rfds); int maxfd = fd_array[0]; for (int i = 0; i \u0026lt; fd_num_max; i++) // 第一次循环 { if (fd_array[i] == defaultfd) continue; FD_SET(fd_array[i], \u0026amp;rfds); if (maxfd \u0026lt; fd_array[i]) { maxfd = fd_array[i]; } } int n = select(maxfd + 1, \u0026amp;rfds, nullptr, nullptr,nullptr); switch (n) { case 0: cout \u0026lt;\u0026lt; \u0026#34;time out, timeout: \u0026#34; \u0026lt;\u0026lt; timeout.tv_sec \u0026lt;\u0026lt; \u0026#34;.\u0026#34; \u0026lt;\u0026lt; timeout.tv_usec \u0026lt;\u0026lt; endl; break; case -1: cerr \u0026lt;\u0026lt; \u0026#34;select error\u0026#34; \u0026lt;\u0026lt; endl; break; default: cout \u0026lt;\u0026lt; \u0026#34;get a new link!!!!!\u0026#34; \u0026lt;\u0026lt; endl; Dispatcher(rfds); break; } } } void PrintFd() { cout \u0026lt;\u0026lt; \u0026#34;online fd list: \u0026#34;; for (int i = 0; i \u0026lt; fd_num_max; i++) { if (fd_array[i] == defaultfd) continue; cout \u0026lt;\u0026lt; fd_array[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } ~SelectServer() { _listensock.Close(); } private: Sock _listensock; uint16_t _port; int fd_array[fd_num_max]; // 数组, 用户维护的！ // int wfd_array[fd_num_max]; }; 总结一下：select实现多路复用的方式是，将已连接的Socket都放到一个文件描述符集合，然后调用select函数将文件描述符集合拷贝到内核里，让内核来检查是否有网络事件产生（通过遍历的方式）当检查到有事件产生后，将此Socket标记为可读或可写，接着再把整个文件描述符集合拷贝回用户态里，然后用户态再通过遍历的方法找到可读或可写的Socket，然后再对其处理。\nselect的缺点\n固定的文件描述符集合大小：select 使用 fd_set 数据结构来管理文件描述符集合，其大小由宏 FD_SETSIZE 决定，通常默认为 1024。这意味着 select 一次最多只能处理 1024 个文件描述符，这在某些需要处理大量并发连接的场景下可能会成为限制。\n复杂的代码逻辑：由于 select 的参数有很多输入输出型参数。这导致每次使用都要遍历辅助数组来重新设置。（这个辅助数组是常数大小，因此算法优化遍历，效率不会改变多少）因此使用 select 编写的代码可能会比较麻烦、复杂，容易出错，并且难以维护和理解。\n不支持高级别的事件通知：select 仅支持基本的事件通知，如可读、可写、异常等。在某些高级别的应用场景中，可能需要更多的事件类型和更细粒度的事件控制，而 select 无法满足这些需求。\npoll poll是对select的优化，它解决了select的一些缺点。 哪些缺点？\n固定的文件描述符集合大小 不支持高级别的事件通知 poll的接口介绍\nevents和revents的取值： poll的优点\n不同与select使用三个位图来表示三个 fdset的方式，poll使用一个pollfd的指针实现.pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式. 接口使用比select更方便. poll并没有最大数量限制 (但是数量过大后性能也是会下降). poll的缺点\npoll中监听的文件描述符数目增多时，和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符.每次调用poll都需要把大量的pollfd结构从用户态拷贝到内核中.同时连接的大量客户端在一时刻可能只有很少的处于就绪状态, 因此随着监视的描述符数量的增长, 其效率也会线性下降。\nepoll 按照man手册的说法: 是为处理大批量句柄而作了改进的poll. 但其实epoll已经可以说是一个新东西了。 它是在2.5.44内核中被引进的(epoll(4) is a new API introduced in Linux kernel 2.5.44) Linux2.6下性能最好的多路它几乎具备了之前所说的一切优点，被公认为性能最好的多路IO转接方案。\nepoll的接口\nepoll有3个系统调用接口：\n1 2 3 int epoll_create(int size); int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout); 下面我们来看看epoll的具体流程： 网卡接收数据，触发硬件中断，OS调用epoll的回调函数，执行以下4步\n根据网卡驱动信息，获取就绪的fd 将数据交付给TCP的接收缓冲区 以就绪的fd作为红黑树节点的key值，提取对应红黑树节点（内部包含events信息） 依据提取的信息创建就绪节点，连接到就绪队列中 ","date":"2025-04-03T00:00:00Z","permalink":"https://sfw003.github.io/p/io_process_analysis/","title":"IO效率优化"},{"content":"绘图文件，在linux系列文章:进程管理\n进程和PCB 什么是进程？ 课本上的定义有很多，如：进程是程序的一次执行，是加载到内存的程序，是系统进行资源分配和调度的一个独立单位。\n我们不必去纠结定义，只需知道2点：如何描述进程？如何管理进程？\n描述=提取进程属性，管理=对进程的属性进行管理 由此首先要引出一个概念：进程的PCB\nPCB(process control block) 是什么？一句话：进程属性的集合，是一个结构体。此时进程就被拆分为2个部分：属性和数据，如下图：\nlinux下的进程信息存储在/proc目录下\nlinux下的PCB 在linux操作系统下的PCB：task_struct（结构体）\ntask_struct的内容分类：\n标识符: 描述本进程的唯一标示符，用来区别其他进程。 状态: 任务状态，退出代码，退出信号等。 优先级: 相对于其他进程的优先级。 程序计数器: 程序中即将被执行的下一条指令的地址。 内存指针: 包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针 上下文数据: 进程执行时处理器的寄存器中的数据[休学例子，要加图CPU，寄存器]。 I／O状态信息: 包括显示的I/O请求,分配给进程的I／O设备和被进程使用的文件列表。 记账信息: 可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号等。 …… 进程状态 在操作系统学科中，描述了一个进程活动期间至少具备3种状态，即进程的三态模型。\n但是这几种状态不够应对实际的情况。如果有大量处于阻塞状态的进程，将长时间占据物理内存空间，造成浪费。因此我们新增一种状态——挂起状态\n挂起状态：进程没有占用物理内存空间的状态（关键词：物理内存）\n理解：此时进程的数据会被移到磁盘空间中\n其中挂起状态又分为2种：阻塞挂起和就绪挂起\n阻塞挂起状态：进程在外存，等待事件 就绪挂起状态：进程在外存，事件就绪 因此现在有 运行、就绪、阻塞、阻塞挂起、就绪挂起共5种状态，如果再具体一点，还可以加入进程创建状态和进程结束状态，共7种。\n在linux系统中，关于进程状态的定义如下，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 static const char * const task_state_array[] = { /* states in TASK_REPORT: */ \u0026#34;R (running)\u0026#34;,\t/* 0x00 */ \u0026#34;S (sleeping)\u0026#34;,\t/* 0x01 */ \u0026#34;D (disk sleep)\u0026#34;,\t/* 0x02 */ \u0026#34;T (stopped)\u0026#34;,\t/* 0x04 */ \u0026#34;t (tracing stop)\u0026#34;,\t/* 0x08 */ \u0026#34;X (dead)\u0026#34;,\t/* 0x10 */ \u0026#34;Z (zombie)\u0026#34;,\t/* 0x20 */ \u0026#34;P (parked)\u0026#34;,\t/* 0x40 */ /* states beyond TASK_REPORT: */ \u0026#34;I (idle)\u0026#34;,\t/* 0x80 */ }; 磁盘睡眠 \u0026ndash; D D状态，磁盘睡眠，进程的磁盘睡眠状态（Disk Sleep State）通常是指进程处于等待磁盘I/O操作完成的状态。这种状态通常出现在进程请求进行磁盘读取或写入操作时，但磁盘尚未完成相应的I/O操作，因此进程被阻塞，等待磁盘响应。在这种状态下，进程不会消耗CPU时间，而是被挂起，直到磁盘I/O操作完成。\n也就是挂起状态。\n暂停和跟踪暂停 \u0026ndash; T和t Linux操作系统的有个信号kill -19， 可以使进程暂停。T状态即进程处于暂停状态。注意不要于S状态混淆，S状态一定是进程在等待某种资源，但T状态不一定在等待某种资源。\n那T和t有什么区别呢？\nStopped（停止）状态： 进程处于停止状态通常是由于接收到了一个信号，例如SIGSTOP（Ctrl-Z产生的SIGTSTP信号）或者SIGTSTP（通常由shell的暂停命令引发）。这种状态下的进程被挂起，暂时停止执行，但可以通过发送SIGCONT信号来恢复执行。\nTracing Stop（跟踪停止）状态： 进程处于跟踪停止状态通常是由于调试器（如GDB）或者ptrace系统调用的作用。在这种状态下，进程被调试器所追踪，通常是因为调试器在进行单步执行、观察或者修改进程的内存等操作。这种状态下的进程暂时停止执行，直到调试器允许其继续执行。\n僵尸进程 \u0026ndash; Z 当一个进程（子进程）完成执行后，它的退出状态需要被父进程获取。如果父进程没有主动获取子进程的退出状态，那么子进程就会变成僵尸进程，相当于一个人处于生死之间。\n父子进程 * 这里提到了父子进程，那什么是父进程、子进程？如何创建子进程？\n下方代码实现：父进程一直运行，子进程执行3次后结束\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { printf(\u0026#34;我是进程：pid = %d，ppid = %d\\n\u0026#34;，getpid()，getppid()); pid_t id = fork(); if(id == 0) { int cnt = 3; while(cnt--) { printf(\u0026#34;我是子进程，pid =%d，ppid =%d\\n\u0026#34;，getpid()，getppid()); sleep(1); } exit(0); } else if(id \u0026gt; 0) { while(1) { printf(\u0026#34;我是父进程，pid = %d，ppid = %d\\n\u0026#34;，getpid()，getppid()); sleep(1); } } return 0; } 结果如下：子进程的状态由S+ \u0026ndash;\u0026gt; Z+， Z即处于僵尸状态\n僵尸进程虽然不会直接对系统造成严重影响，但长时间存在的僵尸进程会对系统的正常运行产生一些间接的危害，包括：可能导致资源耗尽，影响进程管理，降低系统稳定性，因此需要父进程处理僵尸进程。 父进程通常需要调用类似于wait()或waitpid()的系统调用来等待子进程的退出，并获取其退出状态。\n当然如果父进程也结束，系统会自动把子进程释放。\n孤儿进程 僵尸进程是子进程结束，但父进程未结束。如何父进程先结束，子进程后结束呢？那么子进程便会变为孤儿进程，并被托孤给1号进程，即操作系统。\n进程优先级 PRI（Priority）：PRI 表示进程的静态优先级或调度优先级。俗点说就是程序被CPU执行的先后顺序，此值越小,进程的优先级别越高。 NI（Nice Value）：NI 表示进程的 Nice 值，是一个表示进程调度优先级的数值。它的作用是改变PRI的值。\n通过PRI和NI可以调整进程的优先级，计算公式如下：\nPRI(new)=PRI(old)+nice '\n这样，当nice值为负值的时候，那么该程序将会优先级值将变小，即其优先级会变高，则其越快被执行所以，调整进程优先级，在Linux下，就是调整进程nice值\n注意：nice 的范围在 【-20， 19】 PRI(old) 最小是80，如果原来的PRI \u0026lt; 80， 则会直接从80开始算： 因此：PRI 范围【60， 99】，但在计算新的PRI时，最小从80开始 举例：原来 ： PRI = 60 NI = 0; 更改：令PRI = 100 结果：PRI = 99 NI = 19\n那如何更改nice值呢？\n在Linux系统中，nice命令用于启动一个新的进程，并设置其优先级。而renice命令用于修改已经运行的进程的优先级。\nnice命令的使用：\n1 nice [OPTION] [COMMAND [ARG]...] nice命令通过改变进程的优先级来影响其调度。数值越大，优先级越低。默认情况下，优先级是0。\n例如，运行一个命令并设置其优先级：\n1 nice -n \u0026lt;优先级\u0026gt; \u0026lt;命令\u0026gt; 例如，将ls命令的优先级降低为10：\n1 nice -n 10 ls renice命令的使用：\n1 renice [优先级] -p \u0026lt;进程ID\u0026gt; [\u0026lt;进程ID\u0026gt;...] renice命令用于修改已经运行的进程的优先级。可以指定一个或多个进程ID来修改它们的优先级。\n例如，将进程ID为1234的进程的优先级设置为10：\n1 renice 10 -p 1234 进程地址空间 进程地址空间是操作系统为每个进程分配的虚拟内存区域，它让每个进程有独立的地址范围，隔离了物理内存，提高了安全性和管理效率。\n进程地址空间分布 linux下进程地址空间如下：内核空间和用户空间按1 : 3\nLinux系统与Windows系统在进程地址空间设计上存在显著差异，而不同编程语言的进程地址空间本质上是统一的（受操作系统管理）\nWindows：默认采用 2:2模式（用户空间和内核空间各占2GB）但可通过设置 Large-Address-Aware 标志调整为 3:1模式\n但是它们的用户空间都包含代码段、数据段、堆、栈等\n验证一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; using namespace std; int g_A; int g_B = 100; int main() { const char* a = \u0026#34;ab\u0026#34;; static int s_A = 5; int A; int B; int C; int* m_A = new int; int* m_B = new int; int* m_C = new int; printf(\u0026#34;字符常量：a : %p\\n\u0026#34;, a); cout \u0026lt;\u0026lt; \u0026#34;静态变量：s_A : \u0026#34; \u0026lt;\u0026lt; \u0026amp;s_A \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;全局变量：未初始化g_A : \u0026#34; \u0026lt;\u0026lt; \u0026amp;g_A \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;全局变量：已初始化g_B : \u0026#34; \u0026lt;\u0026lt; \u0026amp;g_B \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;栈区：A : \u0026#34; \u0026lt;\u0026lt; \u0026amp;A \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;栈区：B : \u0026#34; \u0026lt;\u0026lt; \u0026amp;B \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;栈区：C : \u0026#34; \u0026lt;\u0026lt; \u0026amp;C \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;堆区：m_A : \u0026#34; \u0026lt;\u0026lt; m_A \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;堆区：m_B : \u0026#34; \u0026lt;\u0026lt; m_B \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;堆区：m_C : \u0026#34; \u0026lt;\u0026lt; m_C \u0026lt;\u0026lt; endl; } 结果如下：\n1 2 3 4 5 6 7 8 9 10 11 ubuntu g++: 字符常量：a : 0x5649d4534009 静态变量：s_A : 0x5649d4536014 全局变量：未初始化g_A : 0x5649d4536154 未初始化地址 \u0026gt; 已初始化地址 符合 全局变量：已初始化g_B : 0x5649d4536010 栈区：A : 0x7ffc892fb3cc A到B栈区的地址是增长的, 不符合 栈区：B : 0x7ffc892fb3d0 栈区：C : 0x7ffc892fb3d4 堆区：m_A : 0x5649d5eadeb0 堆区的地址是增长的，符合 堆区：m_B : 0x5649d5eaded0 堆区：m_C : 0x5649d5eadef0 这里栈区的地址是增长的，不是应该是减少吗？我再测试一下windows下vs2019\n1 2 3 4 5 6 7 8 9 10 11 windows vs2019 字符常量：a : 00639B30 静态变量：s_A : 0063C004 全局变量：未初始化g_A : 0063C3E0 全局变量：已初始化g_B : 0063C000 栈区：A : 004FFBA8\tA到B栈区的地址是下降的, 符合 栈区：B : 004FFB9C 栈区：C : 004FFB90 堆区：m_A : 0069FD68 堆区的地址是增长的，符合 堆区：m_B : 0069FD98 堆区：m_C : 006A0118 这是什么情况？linux栈区是向高地址分配？windows的栈区是向低地址分配？这个问题我之前查阅的时候，得到答案是局部变量按编译器自己方式进行分配。\n？？？\n我对此很懵逼，后来我才理解。这里需要引入一个概念：函数栈帧\n函数栈帧（stack frame）就是函数调用过程中在程序的调用栈（call stack）所开辟的空间，这些空间是用来存放：\n函数参数和函数返回值 临时变量（包括函数的非静态的局部变量以及编译器自动生产的其他临时变量） 保存上下文信息（包括在函数调用前后需要保持不变的寄存器）。 虚拟地址和页表 前面提到，进程地址空间是操作系统为每个进程分配的虚拟内存区域，这么说，在进程中使用的地址都是虚拟地址，如何证明？来看下面一段代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;iostream\u0026gt; int g_val = 100; int main() { pid_t id = fork(); if(id == 0) { g_val = 200; printf(\u0026#34;子进程：g_val = %d, \u0026amp;g_val = %p\\n\u0026#34;, g_val, \u0026amp;g_val); } else if(id \u0026gt; 0) { printf(\u0026#34;父进程：g_val = %d, \u0026amp;g_val = %p\\n\u0026#34;, g_val, \u0026amp;g_val); } } 结果： 父进程：g_val = 100, \u0026amp;g_val = 0x55631bc26010 子进程：g_val = 200, \u0026amp;g_val = 0x55631bc26010 子进程更改数据后，会发生写时拷贝，因此子进程和父进程的g_val值不一样，符合预期，但是为什么发生了写时拷贝，父子进程的g_val地址还是相同？ 显然这里的地址一定不是真实的地址。\n那虚拟地址如何于物理地址联系呢？通过页表与物理地址映射。 回到fork里的问题：为什么父子进程不同的值有着相同的地址？因为这里的地址是虚拟地址。子进程只需更改子进程页表。\n进程控制 前文提到linux下进程有7种状态，如果从进程控制的角度，我们关心\n进程如何创建 进程运行结束，结果是否正确？ 进程异常，如何终止？ 创建进程 系统创建进程的流程如下：\n申请一个空白的PCB，初始化PCB； 为进程分配运行时所必需的资源； 将PCB 插入到就绪队列，等待进程调度； 用户如何创建进程？\n运行一个可执行程序 fork创建子进程 进程等待 当一个进程（子进程）完成执行后，它的退出状态需要被父进程获取。如果父进程没有主动获取子进程的退出状态，那么子进程就会变成僵尸进程。僵尸进程无法被信号 kill -9 杀死，如果放着不管，就会造成内存泄漏。 如何解决呢？此时需要父进程通过进程等待的方式，回收子进程资源，获取子进程退出信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include\u0026lt;sys/types.h\u0026gt; #include\u0026lt;sys/wait.h\u0026gt; pid_t wait(int*status); 返回值： 成功返回被等待进程pid，失败返回-1。 参数： 输出型参数，获取子进程退出状态,不关心则可以设置成为NULL pid_ t waitpid(pid_t pid, int *status, int options); 返回值： 当正常返回的时候waitpid返回收集到的子进程的进程ID； 如果设置了选项WNOHANG,而调用中waitpid发现没有已退出的子进程可收集,则返回0； 如果调用中出错,则返回-1,这时errno会被设置成相应的值以指示错误所在； 参数： pid： Pid=-1,等待任一个子进程。与wait等效。 Pid\u0026gt;0.等待其进程ID与pid相等的子进程。 status: WIFEXITED(status): 若为正常终止子进程返回的状态，则为真。（查看进程是否是正常退出） WEXITSTATUS(status): 若WIFEXITED非零，提取子进程退出码。（查看进程的退出码） options: WNOHANG: 若pid指定的子进程没有结束，则waitpid()函数返回0，不予以等待。若正常结束，则返回该子进 程的ID。 使用案例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/wait.h\u0026gt; #include \u0026lt;iostream\u0026gt; using std::endl; using std::cout; int main() { for(int i = 0; i \u0026lt; 5; i++) { pid_t id = fork(); if(id == 0) { cout \u0026lt;\u0026lt; \u0026#34;create a child process, pid = \u0026#34; \u0026lt;\u0026lt; getpid() \u0026lt;\u0026lt; endl; exit(i); } } sleep(3); //经过3秒后，wait子进程 for(int i = 0; i \u0026lt; 5; i++) { int status; pid_t id = wait(\u0026amp;status); if(id \u0026gt; 0) { cout \u0026lt;\u0026lt; \u0026#34;wait a process pid = \u0026#34; \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34; status = \u0026#34; \u0026lt;\u0026lt; status \u0026lt;\u0026lt; endl; } } return 0; } 结果： create a child process, pid = 230665 create a child process, pid = 230667 create a child process, pid = 230668 create a child process, pid = 230669 create a child process, pid = 230666 wait a process pid = 230665 status = 0 wait a process pid = 230666 status = 256 wait a process pid = 230667 status = 512 wait a process pid = 230668 status = 768 wait a process pid = 230669 status = 1024 使用while :; do ps ajx | head -1 \u0026amp;\u0026amp; ps ajx | grep t1; sleep 1; done来监控 发现5个僵尸进程，被wait回收了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 root@iZbp1inz4ol3gjahpjal9qZ:~# while :; do ps ajx | head -1 \u0026amp;\u0026amp; ps ajx | grep t1; sleep 1; done PPID PID PGID SID TTY TPGID STAT UID TIME COMMAND 229980 230652 230651 229980 pts/3 230651 S+ 0 0:00 grep --color=auto t PPID PID PGID SID TTY TPGID STAT UID TIME COMMAND 229980 230657 230656 229980 pts/3 230656 S+ 0 0:00 grep --color=auto t PPID PID PGID SID TTY TPGID STAT UID TIME COMMAND 229980 230662 230661 229980 pts/3 230661 S+ 0 0:00 grep --color=auto t PPID PID PGID SID TTY TPGID STAT UID TIME COMMAND 229863 230664 230664 229863 pts/2 230664 S+ 0 0:00 ./t1 230664 230665 230664 229863 pts/2 230664 Z+ 0 0:00 [t1] \u0026lt;defunct\u0026gt; 230664 230666 230664 229863 pts/2 230664 Z+ 0 0:00 [t1] \u0026lt;defunct\u0026gt; 230664 230667 230664 229863 pts/2 230664 Z+ 0 0:00 [t1] \u0026lt;defunct\u0026gt; 230664 230668 230664 229863 pts/2 230664 Z+ 0 0:00 [t1] \u0026lt;defunct\u0026gt; 230664 230669 230664 229863 pts/2 230664 Z+ 0 0:00 [t1] \u0026lt;defunct\u0026gt; 229980 230673 230672 229980 pts/3 230672 S+ 0 0:00 grep --color=auto t PPID PID PGID SID TTY TPGID STAT UID TIME COMMAND 229863 230664 230664 229863 pts/2 230664 S+ 0 0:00 ./t1 230664 230665 230664 229863 pts/2 230664 Z+ 0 0:00 [t1] \u0026lt;defunct\u0026gt; 230664 230666 230664 229863 pts/2 230664 Z+ 0 0:00 [t1] \u0026lt;defunct\u0026gt; 230664 230667 230664 229863 pts/2 230664 Z+ 0 0:00 [t1] \u0026lt;defunct\u0026gt; 230664 230668 230664 229863 pts/2 230664 Z+ 0 0:00 [t1] \u0026lt;defunct\u0026gt; 230664 230669 230664 229863 pts/2 230664 Z+ 0 0:00 [t1] \u0026lt;defunct\u0026gt; 229980 230678 230677 229980 pts/3 230677 S+ 0 0:00 grep --color=auto t PPID PID PGID SID TTY TPGID STAT UID TIME COMMAND 229863 230664 230664 229863 pts/2 230664 S+ 0 0:00 ./t1 230664 230665 230664 229863 pts/2 230664 Z+ 0 0:00 [t1] \u0026lt;defunct\u0026gt; 230664 230666 230664 229863 pts/2 230664 Z+ 0 0:00 [t1] \u0026lt;defunct\u0026gt; 230664 230667 230664 229863 pts/2 230664 Z+ 0 0:00 [t1] \u0026lt;defunct\u0026gt; 230664 230668 230664 229863 pts/2 230664 Z+ 0 0:00 [t1] \u0026lt;defunct\u0026gt; 230664 230669 230664 229863 pts/2 230664 Z+ 0 0:00 [t1] \u0026lt;defunct\u0026gt; 229980 230683 230682 229980 pts/3 230682 S+ 0 0:00 grep --color=auto t PPID PID PGID SID TTY TPGID STAT UID TIME COMMAND 229980 230688 230687 229980 pts/3 230687 S+ 0 0:00 grep --color=auto t PPID PID PGID SID TTY TPGID STAT UID TIME COMMAND 229980 230693 230692 229980 pts/3 230692 S+ 0 0:00 grep --color=auto t 进程退出信息 wait和waitpid，都有一个status参数，该参数是一个输出型参数，由操作系统填充。\n如果传递NULL，表示不关心子进程的退出状态信息。 否则，操作系统会根据该参数，将子进程的退出信息反馈给父进程。 status不能简单的当作整形来看待，可以当作位图来看待，具体细节如下图（只研究status低16比特位）：\n1 2 int status; pid_t id = wait(\u0026amp;status); 正常退出看退出码，异常退出看信号。status作为子进程的退出信息，通过位图的方式将退出码和信号的信息存储在比特位中。\n你可以通过status的值来分析它的退出信息，如果你嫌麻烦，可以使用2个宏\n1 2 WIFEXITED(status): 若为正常终止子进程返回的状态，则为真。（查看进程是否是正常退出） WEXITSTATUS(status): 若WIFEXITED非零，提取子进程退出码。（查看进程的退出码） 进程替换 当进程调用一种exec函数时,该进程的用户空间代码和数据完全被新程序替换,从新程序的启动进程程开始执行。调用exec并不创建新进程,所以调用exec前后该进程的id并未改变。 函数关系： 事实上,只有execve是真正的系统调用,其它五个函数最终都调用 execve,所以execve在man手册 第2节,其它函数在man手册第3节。这些函数之间的关系如下图所示 ","date":"2025-04-03T00:00:00Z","permalink":"https://sfw003.github.io/p/linux-process/","title":"Linux 进程"},{"content":"绘图文件，在linux系列文章:进程管理\n进程间通信 进程间通信（Inter-Process Communication，IPC）是指在操作系统中，不同的进程之间进行数据交换、信息传递和同步操作的机制。在多任务操作系统中，不同的进程可能同时运行，它们之间可能需要进行数据共享、协作完成某项任务等操作，这就需要进程间通信。 进程间通信目的：\n数据传输：一个进程需要将它的数据发送给另一个进程 资源共享：多个进程之间共享同样的资源。 通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。 进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变 如何理解进程间通信：本质是让不同的进程看到同一份资源。\n那如何让不同进程看到同一份资源呢？ 资源又是什么呢？ 怀着这2个问题，我们来看看进程通信模块： 一般操作系统会有一个独立的通信模块，隶属于文件系统, 即IPC通信模块。 在linux内核刚被设计时，不支持通信，后来发现通信很重要，于是很多开发人员开始设计通信模块。当时的设计一个通信模块并不难，很多人提出了不同设计思路，谁也不服谁，为了统一，制定了标准。 最后落地了2套标准：system V \u0026amp;\u0026amp; posix\n进程间通信的分类：\n管道\n匿名管道pipe 命名管道 System V IPC\nSystem V 消息队列 System V 共享内存 3 .System V 信号量 POSIX IPC\n消息队列 共享内存 信号量 互斥量 条件变量 读写锁 管道 在使用linux命令时，常常需要使用管道\n1 ps aux | grep name 这里的丨竖线就是一个管道，它的功能是将前一个命令的输出，作为后一个命令的输入，采用FIFO（先进先出）的传输方式。\n这种管道没有名字，称为匿名管道\n有了匿名管道，那肯定还有命名管道。命名管道通过mkfifo来创建\n1 mkfifo name 匿名管道 匿名管道是如何创建的呢？这涉及到一个系统调用：pipe\n1 2 3 4 5 6 7 #include \u0026lt;unistd.h\u0026gt; 功能:创建管道 原型 int pipe(int pipefd[2]); 参数 pipefd：文件描述符数组,输出型参数，其中pipefd[0]存放读端的文件描述符, pipefd[1]存放读端的文件描述符 返回值:成功返回0，失败返回错误代码 管道通常是单向通信，主要是为了简化设计。如果要进行双向通信，那就创造两个管道。\n案例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;cassert\u0026gt; int main() { //创建管道，让父进程写，子进程读 int pipefd[2]; int n = pipe(pipefd); assert(n != -1); pid_t id = fork(); if(id == 0) { //子进程 -- 读取管道 close(pipefd[1]);//关闭写端,留下读端 //……子进程接受数据 close(pipefd[0]); exit(0); } else if(id \u0026gt; 0) { //父进程 -- 写入管道 close(pipefd[0]);//关闭读端，留下写端 //……父进程写入数据 close(pipefd[1]); } return 0; } 命名管道 理解管道 linux下一切皆文件，管道能读能写，肯定是一种文件。一般情况下，进程管理文件如下图。\n这里内核缓存区到外存，要通过页表，到物理内存，在通过DMA写入外存。\n管道不同于上面的形式，它是一种内存级别的文件，本质就是内核里面的一串缓存。\n共享内存 听名字就懂了，具体原理：拿出一块虚拟地址空间来，映射到相同的物理内存中。\n套接字（socket） ","date":"2025-04-03T00:00:00Z","permalink":"https://sfw003.github.io/p/linux-process-communication/","title":"Linux 进程间通信"},{"content":"相关文章链接\nLinux 文件操作命令 Linux 网络命令 \u0026lt;== 本文\n网络操作命令：ifconfig、ip、ping、netstat、telnet、ftp、route、rlogin、rcp、finger、mail、 nslookup；\nifconfig ifconfig用于查看和更改网络接口的地址和参数，包括IP地址、网络掩码、广播地址，使用权限是超级用户。\n命令参数\n1 2 3 4 5 6 7 8 9 ifconfig -interface [options] address 主要参数 -interface：指定的网络接口名，如eth0和eth1。 up：激活指定的网络接口卡。 down：关闭指定的网络接口。 broadcast address：设置接口的广播地址。 pointopoint：启用点对点方式。 address：设置指定接口设备的IP地址。 netmask address：设置接口的子网掩码。 ifconfig是用来设置和配置网卡的命令行工具。\n为了手工配置网络，这是一个必须掌握的命令。\n使用该命令的好处是无须重新启动机器。\n要赋给eth0接口IP地址207.164.186.2，并且马上激活它，使用下面命令： #fconfig eth0 210.34.6.89 netmask 255.255.255.128 broadcast 210.34.6.127\n该命令的作用是设置网卡eth0的IP地址、网络掩码和网络的本地广播地址。\n若运行不带任何参数的ifconfig命令，这个命令将显示机器所有激活接口的信息。\n带有“-a”参数的命令则显示所有接口的信息，包括没有激活的接口。\n注意，用ifconfig命令配置的网络设备参数，机器重新启动以后将会丢失。\n如果要暂停某个网络接口的工作，可以使用down参数：\n1 # ifconfig eth0 down ip ip是iproute2软件包里面的一个强大的网络配置工具，它能够替代一些传统的网络管理工具，例如ifconfig、route等，使用权限为超级用户。\n几乎所有的Linux发行版本都支持该命令。\nip [OPTIONS] OBJECT [COMMAND [ARGUMENTS]] 主要参数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 OPTIONS是修改ip行为或改变其输出的选项。所有的选项都是以-字符开头，分为长、短两种形式。目前，ip支持如表1所示选项。 OBJECT是要管理者获取信息的对象。目前ip认识的对象见表2所示。 表1 ip支持的选项 -V,-Version 打印ip的版本并退出。 -s,-stats,-statistics 输出更为详尽的信息。如果这个选项出现两次或多次，则输出的信息将更为详尽。 -f,-family 这个选项后面接协议种类，包括inet、inet6或link，强调使用的协议种类。 如果没有足够的信息告诉ip使用的协议种类，ip就会使用默认值inet或any。link比较特殊，它表示不涉及任何网络协议。 -4是-family inet的简写。 -6 是-family inet6的简写。 -0 是-family link的简写。 -o,-oneline 对每行记录都使用单行输出，回行用字符代替。如果需要使用wc、grep等工具处理ip的输出，则会用到这个选项。 -r,-resolve 查询域名解析系统，用获得的主机名代替主机IP地址 应用实例\n添加IP地址192.168.2.2/24到eth0网卡上： #ip addr add 192.168.1.1/24 dev eth0 丢弃源地址属于192.168.2.0/24网络的所有数据报： #ip rule add from 192.168.2.0/24 prio 32777 reject\nping ping检测主机网络接口状态，使用权限是所有用户。\n主要参数\n1 ping [选项] 目标IP/域名 1 2 3 4 5 6 7 8 9 10 11 12 13 14 -d：使用Socket的SO_DEBUG功能。 -c：设置完成要求回应的次数。 -f：极限检测。 -i：指定收发信息的间隔秒数。 -I：网络界面使用指定的网络界面送出数据包。 -l：前置载入，设置在送出要求信息之前，先行发出的数据包。 -n：只输出数值。 -p：设置填满数据包的范本样式。 -q：不显示指令执行过程，开头和结尾的相关信息除外。 -r：忽略普通的Routing Table，直接将数据包送到远端主机上。 -R：记录路由过程。 -s：设置数据包的大小。 -t：设置存活数值TTL的大小。 -v：详细显示指令的执行过程。 ping命令是使用最多的网络指令，通常我们使用它检测网络是否连通，它使用ICMP协议。\n但是有时会有这样的情况，我们可以浏览器查看一个网页，但是却无法ping通，这是因为一些网站处于安全考虑安装了防火墙。\n另外，也可以在自己计算机上试一试，通过下面的方法使系统对ping没有反应：\n1 # echo 1 \u0026gt; /proc/sys/net/ipv4/icmp_echo_ignore_all netstat 检查整个Linux网络状态。\n命令参数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 -a--all：显示所有连线中的Socket。 -A：列出该网络类型连线中的IP相关地址和网络类型。 -c--continuous：持续列出网络状态。 -C--cache：显示路由器配置的快取信息。 -e--extend：显示网络其它相关信息。 -F--fib：显示FIB。 -g--groups：显示多重广播功能群组组员名单。 -h--help：在线帮助。 -i--interfaces：显示网络界面信息表单。 -l--listening：显示监控中的服务器的Socket。 -M--masquerade：显示伪装的网络连线。 -n--numeric：直接使用IP地址，而不通过域名服务器。 -N--netlink--symbolic：显示网络硬件外围设备的符号连接名称。 -o--timers：显示计时器。 -p--programs：显示正在使用Socket的程序识别码和程序名称。 -r--route：显示Routing Table。 -s--statistice：显示网络工作信息统计表。 -t--tcp：显示TCP传输协议的连线状况。 -u--udp：显示UDP传输协议的连线状况。 -v--verbose：显示指令执行过程。 -V--version：显示版本信息。 -w--raw：显示RAW传输协议的连线状况。 -x--unix：和指定“-A unix”参数相同。 --ip--inet：和指定“-A inet”参数相同。 应用实例\nnetstat 主要用于Linux察看自身的网络状况，如开启的端口、在为哪些用户服务，以及服务的状态等。此外，它还显示系统路由表、网络接口状态等。\n可以说，它是一个综合性的网络状态的察看工具。\n在默认情况下，netstat只显示已建立连接的端口。\n如果要显示处于监听状态的所有端口，使用-a参数即可： #netstat -a Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 *:32768 : LISTEN tcp 0 0 *:32769 : LISTEN tcp 0 0 *:nfs : LISTEN tcp 0 0 *:32770 : LISTEN tcp 0 0 *:868 : LISTEN tcp 0 0 *:617 : LISTEN tcp 0 0 *:mysql : LISTEN tcp 0 0 *:netbios-ssn : LISTEN tcp 0 0 *:sunrpc : LISTEN tcp 0 0 *:10000 : LISTEN tcp 0 0 *:http : LISTEN \u0026hellip;\u0026hellip; 上面显示出，这台主机同时提供HTTP、FTP、NFS、MySQL等服务。\ntelnet telnet表示开启终端机阶段作业，并登入远端主机。telnet是一个Linux命令，同时也是一个协议（远程登陆协议）。\n1 telnet [option] [主机名称IP地址] 主要参数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 -8：允许使用8位字符资料，包括输入与输出。 -a：尝试自动登入远端系统。 -b：使用别名指定远端主机名称。 -c：不读取用户专属目录里的.telnetrc文件。 -d：启动排错模式。 -e：设置脱离字符。 -E：滤除脱离字符。 -f：此参数的效果和指定“-F”参数相同。 -F：使用Kerberos V5认证时，加上此参数可把本地主机的认证数据上传到远端主机。 -k：使用Kerberos认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名。 -K：不自动登入远端主机。 -l：指定要登入远端主机的用户名称。 -L：允许输出8位字符资料。 -n：指定文件记录相关信息。 -r：使用类似rlogin指令的用户界面。 -S：服务类型，设置telnet连线所需的IP TOS信息。 -x：假设主机有支持数据加密的功能，就使用它。 -X：关闭指定的认证形态。 用户使用telnet命令可以进行远程登录，并在远程计算机之间进行通信。\n用户通过网络在远程计算机上登录，就像登录到本地机上执行命令一样。\n为了通过telnet登录到远程计算机上，必须知道远程机上的合法用户名和口令。\n虽然有些系统确实为远程用户提供登录功能，但出于对安全的考虑，要限制来宾的操作权限，因此，这种情况下能使用的功能是很少的。\ntelnet只为普通终端提供终端仿真，而不支持X-Window等图形环境。\n当允许远程用户登录时，系统通常把这些用户放在一个受限制的Shell中，以防系统被怀有恶意的或不小心的用户破坏。\n用户还可以使用telnet从远程站点登录到自己的计算机上，检查电子邮件、编辑文件和运行程序，就像在本地登录一样。\nftp ftp命令进行远程文件传输。FTP是ARPANet的标准文件传输协议，该网络就是现今Internet的前身，所以ftp既是协议又是一个命令。\n1 ftp [-dignv] [主机名称IP地址] 主要参数\n1 2 3 4 5 -d：详细显示指令执行过程，便于排错分析程序执行的情形。 -i：关闭互动模式，不询问任何问题。 -g：关闭本地主机文件名称支持特殊字符的扩充特性。 -n：不使用自动登陆。 -v：显示指令执行过程。 应用说明 ftp命令是标准的文件传输协议的用户接口，是在TCP/IP网络计算机之间传输文件简单有效的方法，它允许用户传输ASCⅡ文件和二进制文件。\n为了使用ftp来传输文件，用户必须知道远程计算机上的合法用户名和口令。\n这个用户名/口令的组合用来确认ftp会话，并用来确定用户对要传输的文件进行什么样的访问。 另外，用户需要知道对其进行ftp会话的计算机名字的IP地址。 用户可以通过使用ftp客户程序，连接到另一台计算机上；\n可以在目录中上下移动、列出目录内容；\n可以把文件从远程计算机机拷贝到本地机上；\n还可以把文件从本地机传输到远程系统中。\nftp内部命令有72个，下面列出主要几个内部命令：\nls：列出远程机的当前目录。 cd：在远程机上改变工作目录。 lcd：在本地机上改变工作目录。 close：终止当前的ftp会话。 hash：每次传输完数据缓冲区中的数据后就显示一个#号。 get（mget）：从远程机传送指定文件到本地机。 put（mput）：从本地机传送指定文件到远程机。 quit：断开与远程机的连接，并退出ftp。\n##route\n作用 route表示手工产生、修改和查看路由表。\n格式 1 2 #route [-add][-net|-host] targetaddress [-netmask Nm][dev]If] #route [－delete][-net|-host] targetaddress [gw Gw][-netmask Nm] [dev]If] 主要参数 -add：增加路由。 -delete：删除路由。 -net：路由到达的是一个网络，而不是一台主机。 -host：路由到达的是一台主机。 -netmask Nm：指定路由的子网掩码。 gw：指定路由的网关。 [dev]If：强迫路由链指定接口。\n应用实例 route命令是用来查看和设置Linux系统的路由信息，以实现与其它网络的通信。\n要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。 在Linux系统中，设置路由通常是为了解决以下问题：该Linux系统在一个局域网中，局域网中有一个网关，能够让机器访问Internet，那么就需要将这台机器的IP地址设置为Linux机器的默认路由。\n使用下面命令可以增加一个默认路由： route add 0.0.0.0 192.168.1.1\nrlogin 作用 rlogin用来进行远程注册。\n格式 rlogin [ -8EKLdx ] [ -e char ] [-k realm ] [ - l username ] host 主要参数 -8：此选项始终允许8位输入数据通道。该选项允许发送格式化的ANSI字符和其它的特殊代码。如果不用这个选项，除非远端的不是终止和启动字符，否则就去掉奇偶校验位。 -E：停止把任何字符当作转义字符。当和-8选项一起使用时，它提供一个完全的透明连接。 -K：关闭所有的Kerberos确认。只有与使用Kerberos确认协议的主机连接时才使用这个选项。 -L：允许rlogin会话在litout模式中运行。要了解更多信息，请查阅tty联机帮助。 -d：打开与远程主机进行通信的TCP sockets的socket调试。要了解更多信息，请查阅setsockopt的联机帮助。 -e：为rlogin会话设置转义字符，默认的转义字符是“～”。 -k：请求rlogin获得在指定区域内远程主机的Kerberos许可，而不是获得由krb_realmofhost(3)确定的远程主机区域内的远程主机的Kerberos许可。 -x：为所有通过rlogin会话传送的数据打开DES加密。这会影响响应时间和CPU利用率，但是可以提高安全性。\n使用说明 如果在网络中的不同系统上都有账号，或者可以访问别人在另一个系统上的账号，那么要访问别的系统中的账号，首先就要注册到系统中，接着通过网络远程注册到账号所在的系统中。\nrlogin可以远程注册到别的系统中，它的参数应是一个系统名。\nrcp 作用 rcp代表远程文件拷贝，用于计算机之间文件拷贝，使用权限是所有用户。\n格式 rcp [-px] [-k realm] file1 file2 rcp [-px] [-r] [-k realm] file 主要参数 -r：递归地把源目录中的所有内容拷贝到目的目录中。要使用这个选项，目的必须是一个目录。 -p：试图保留源文件的修改时间和模式，忽略umask。 -k：请求rcp获得在指定区域内的远程主机的Kerberos许可，而不是获得由krb_relmofhost(3)确定的远程主机区域内的远程主机的Kerberos许可。 -x：为传送的所有数据打开DES加密。\nfinger 作用 finger用来查询一台主机上的登录账号的信息，通常会显示用户名、主目录、停滞时间、登录时间、登录Shell等信息，使用权限为所有用户。\n格式 finger [选项] [使用者] [用户@主机] 主要参数 -s：显示用户注册名、实际姓名、终端名称、写状态、停滞时间、登录时间等信息。 -l：除了用-s选项显示的信息外，还显示用户主目录、登录Shell、邮件状态等信息，以及用户主目录下的.plan、.project和.forward文件的内容。 -p：除了不显示.plan文件和.project文件以外，与-l选项相同。\n应用实例 在计算机上使用finger： [root@localhost root]# Finger Login Name Tty Idle Login Time Office Office Phone root root tty1 2 Dec 15 11 root root pts/0 1 Dec 15 11\nroot root *pts/1 Dec 15 11\n应用说明 如果要查询远程机上的用户信息，需要在用户名后面接“@主机名”，采用[用户名@主机名]的格式，不过要查询的网络主机需要运行finger守护进程的支持。\nmail 作用 mail作用是发送电子邮件，使用权限是所有用户。此外，mail还是一个电子邮件程序。\n格式 mail [-s subject] [-c address] [-b address] mail -f [mailbox]mail [-u user] 主要参数 -b address：表示输出信息的匿名收信人地址清单。 -c address：表示输出信息的抄送（）收信人地址清单。 -f [mailbox]：从收件箱者指定邮箱读取邮件。 -s subject：指定输出信息的主体行。 [-u user]：端口指定优化的收件箱读取邮件。\nnslookup 作用 nslookup命令的功能是查询一台机器的IP地址和其对应的域名。使用权限所有用户。\n它通常需要一台域名服务器来提供域名服务。如果用户已经设置好域名服务器，就可以用这个命令查看不同主机的IP地址对应的域名。\n格式 nslookup［IP地址/域名］\n应用实例 （1）在本地计算机上使用nslookup命令 $ nslookup Default Server: name.cao.com.cn Address: 192.168.1.9\n在符号“\u0026gt;”后面输入要查询的IP地址域名，并回车即可。如果要退出该命令，输入“exit”，并回车即可。 （2）使用nslookup命令测试named 输入下面命令： nslookup 然后就进入交换式nslookup环境。\n如果named正常启动，则nslookup会显示当前DNS服务器的地址和域名，否则表示named没能正常启动。 下面简单介绍一些基本的DNS诊断。 ◆检查正向DNS解析，在nslookup提示符下输入带域名的主机名，如hp712.my.com，nslookup应能显示该主机名对应的IP地址。\n如果只输入hp712，nslookup会根据/etc/resolv.conf的定义，自动添加my.com域名，并回答对应的IP地址。\n◆检查反向DNS解析，在nslookup提示符下输入某个IP地址，如192.22.33.20，nslookup应能回答该IP地址所对应的主机名。\n◆检查MX邮件地址记录在nslookup提示符下输入： set q=mx 然后输入某个域名，输入my.com和mail.my.com，nslookup应能够回答对应的邮件服务器地址，即support.my.com和support2.my.com。\n","date":"2025-04-03T00:00:00Z","permalink":"https://sfw003.github.io/p/linux-network-command/","title":"Linux 网络命令"},{"content":"相关文章链接\nLinux 文件操作命令\u0026lt;== 本文 Linux 网络命令\nmore 功能类似于 cat, more 会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示。\n1 2 3 4 5 6 7 8 9 +n 从笫 n 行开始显示 -n 定义屏幕大小为n行 +/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 -c 从顶部清屏，然后显示 -d 提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能 -l 忽略Ctrl+l（换页）字符 -p 通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似 -s 把连续的多个空行显示为一行 -u 把文件内容中的下画线去掉 操作命令\n1 2 3 4 5 6 7 8 9 Enter 向下 n 行，需要定义。默认为 1 行 Ctrl+F 向下滚动一屏 空格键 向下滚动一屏 Ctrl+B 返回上一屏 = 输出当前行的行号 :f 输出文件名和当前行的行号 V 调用vi编辑器 !命令 调用Shell，并执行命令 q 退出more 实例：\n（1）显示文件中从第3行起的内容\n1 more +3 text.txt （2）在所列出文件目录详细信息，借助管道使每次显示 5 行\n1 ls -l | more -5 按空格显示下 5 行。\nless less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 -i 忽略搜索时的大小写 -N 显示每行的行号 -o \u0026lt;文件名\u0026gt; 将less 输出的内容在指定文件中保存起来 -s 显示连续空行为一行 /字符串：向下搜索“字符串”的功能 ?字符串：向上搜索“字符串”的功能 n：重复前一个搜索（与 / 或 ? 有关） N：反向重复前一个搜索（与 / 或 ? 有关） -x \u0026lt;数字\u0026gt; 将“tab”键显示为规定的数字空格 b 向后翻一页 d 向后翻半页 h 显示帮助界面 Q 退出less 命令 u 向前滚动半页 y 向前滚动一行 空格键 滚动一行 回车键 滚动一页 [pagedown]： 向下翻动一页 [pageup]： 向上翻动一页 实例：\n（1）ps 查看进程信息并通过 less 分页显示\n1 ps -aux | less -N （2）查看多个文件\n1 less 1.log 2.log 可以使用 n 查看下一个，使用 p 查看前一个。\nhead 命令 head 用来显示档案的开头至标准输出中，默认 head 命令打印其相应文件的开头 10 行。\n常用参数：\n1 -n\u0026lt;行数\u0026gt; 显示的行数（行数为复数表示从最后向前数） 实例：\n（1）显示 1.log 文件中前 20 行\n1 head 1.log -n 20 （2）显示 1.log 文件前 20 字节\n1 head -c 20 log2014.log （3）显示 t.log最后 10 行\n1 head -n -10 t.log tail 命令 用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。\n常用参数：\n1 2 -f 循环读取（常用于查看递增的日志文件） -n\u0026lt;行数\u0026gt; 显示行数（从后向前） （1）循环读取逐渐增加的文件内容\n1 ping 127.0.0.1 \u0026gt; ping.log \u0026amp; 后台运行：可使用 jobs -l 查看，也可使用 fg 将其移到前台运行。\n1 tail -f ping.log （查看日志）\nwhich 命令 在 linux 要查找某个文件，但不知道放在哪里了，可以使用下面的一些命令来搜索：\n1 2 3 4 which 查看可执行文件的位置。 whereis 查看文件的位置。 locate 配合数据库查看文件位置。 find 实际搜寻硬盘查询文件名称。 which 是在 PATH 就是指定的路径中，搜索某个系统命令的位置，并返回第一个搜索结果。使用 which 命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。\n常用参数：\n1 -n 指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。 实例：\n（1）查看 ls 命令是否存在，执行哪个\n1 which ls （2）查看 which\n1 which which （3）查看 cd\n1 which cd（显示不存在，因为 cd 是内建命令，而 which 查找显示是 PATH 中的命令） 查看当前 PATH 配置：\n1 echo $PATH 或使用 env 查看所有环境变量及对应值\nwhereis 命令 whereis 命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。whereis 及 locate 都是基于系统内建的数据库进行搜索，因此效率很高，而find则是遍历硬盘查找文件。\n常用参数：\n1 2 3 4 -b 定位可执行文件。 -m 定位帮助文件。 -s 定位源代码文件。 -u 搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件。 实例：\n（1）查找 locate 程序相关文件\n1 whereis locate （2）查找 locate 的源码文件\n1 whereis -s locate （3）查找 lcoate 的帮助文件\n1 whereis -m locate locate 命令 locate 通过搜寻系统内建文档数据库达到快速找到档案，数据库由 updatedb 程序来更新，updatedb 是由 cron daemon 周期性调用的。默认情况下 locate 命令在搜寻数据库时比由整个由硬盘资料来搜寻资料来得快，但较差劲的是 locate 所找到的档案若是最近才建立或 刚更名的，可能会找不到，在内定值中，updatedb 每天会跑一次，可以由修改 crontab 来更新设定值 (etc/crontab)。\nlocate 与 find 命令相似，可以使用如 *、? 等进行正则匹配查找\n常用参数：\n1 2 3 -l num（要显示的行数） -f 将特定的档案系统排除在外，如将proc排除在外 -r 使用正则运算式做为寻找条件 实例：\n（1）查找和 pwd 相关的所有文件(文件名中包含 pwd）\n1 locate pwd （2）搜索 etc 目录下所有以 sh 开头的文件\n1 locate /etc/sh （3）查找 /var 目录下，以 reason 结尾的文件\n1 locate -r \u0026#39;^/var.*reason$\u0026#39;（其中.表示一个字符，*表示任务多个；.*表示任意多个字符） chmod 命令 用于改变 linux 系统文件或目录的访问权限。用它控制文件或目录的访问权限。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。\n每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件属主的读、写和执行权限；与属主同组的用户的读、写和执行权限；系统中其他用户的读、写和执行权限。可使用 ls -l test.txt 查找。\n以文件 log2012.log 为例：\n1 -rw-r--r-- 1 root root 296K 11-13 06:03 log2012.log 第一列共有 10 个位置，第一个字符指定了文件类型。在通常意义上，一个目录也是一个文件。如果第一个字符是横线，表示是一个非目录的文件。如果是 d，表示是一个目录。从第二个字符开始到第十个 9 个字符，3 个字符一组，分别表示了 3 组用户对文件或者目录的权限。权限字符用横线代表空许可，r 代表只读，w 代表写，x 代表可执行。\n常用参数：\n1 2 -c 当发生改变时，报告处理信息 -R 处理指定目录以及其子目录下所有文件 权限范围：\n1 2 3 4 u ：目录或者文件的当前的用户 g ：目录或者文件的当前的群组 o ：除了目录或者文件的当前用户或群组之外的用户或者群组 a ：所有的用户及群组 权限代号：\n1 2 3 4 5 r ：读权限，用数字4表示 w ：写权限，用数字2表示 x ：执行权限，用数字1表示 - ：删除权限，用数字0表示 s ：特殊权限 实例：\n（1）增加文件 t.log 所有用户可执行权限\n1 chmod a+x t.log （2）撤销原来所有的权限，然后使拥有者具有可读权限,并输出处理信息\n1 chmod u=r t.log -c （3）给 file 的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限\n1 chmod 751 t.log -c（或者：chmod u=rwx,g=rx,o=x t.log -c) （4）将 test 目录及其子目录所有文件添加可读权限\n1 chmod u+r,g+r,o+r -R text/ -c 19、tar 命令\n用来压缩和解压文件。tar 本身不具有压缩功能，只具有打包功能，有关压缩及解压是调用其它的功能来完成。\n弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件\n常用参数：\n1 2 3 4 5 6 7 8 9 10 -c 建立新的压缩文件 -f 指定压缩文件 -r 添加文件到已经压缩文件包中 -u 添加改了和现有的文件到压缩包中 -x 从压缩包中抽取文件 -t 显示压缩文件中的内容 -z 支持gzip压缩 -j 支持bzip2压缩 -Z 支持compress解压文件 -v 显示操作过程 有关 gzip 及 bzip2 压缩:\n1 2 3 4 5 gzip 实例：压缩 gzip fileName .tar.gz 和.tgz 解压：gunzip filename.gz 或 gzip -d filename.gz 对应：tar zcvf filename.tar.gz tar zxvf filename.tar.gz bz2实例：压缩 bzip2 -z filename .tar.bz2 解压：bunzip filename.bz2或bzip -d filename.bz2 对应：tar jcvf filename.tar.gz 解压：tar jxvf filename.tar.bz2 实例：\n（1）将文件全部打包成 tar 包\n1 tar -cvf log.tar 1.log,2.log 或tar -cvf log.* （2）将 /etc 下的所有文件及目录打包到指定目录，并使用 gz 压缩\n1 tar -zcvf /tmp/etc.tar.gz /etc （3）查看刚打包的文件内容（一定加z，因为是使用 gzip 压缩的）\n1 tar -ztvf /tmp/etc.tar.gz （4）要压缩打包 /home, /etc ，但不要 /home/dmtsai\n1 tar --exclude /home/dmtsai -zcvf myfile.tar.gz /home/* /etc chown 命令 chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户 ID；组可以是组名或者组 ID；文件是以空格分开的要改变权限的文件列表，支持通配符。\n1 2 -c 显示更改的部分的信息 -R 处理指定目录及子目录 实例：\n（1）改变拥有者和群组 并显示改变信息\n1 chown -c mail:mail log2012.log （2）改变文件群组\n1 chown -c :mail t.log （3）改变文件夹及子文件目录属主及属组为 mail\n1 chown -cR mail: test/ df 命令 显示磁盘空间使用情况。获取硬盘被占用了多少空间，目前还剩下多少空间等信息，如果没有文件名被指定，则所有当前被挂载的文件系统的可用空间将被显示。默认情况下，磁盘空间将以 1KB 为单位进行显示，除非环境变量 POSIXLY_CORRECT 被指定，那样将以512字节为单位进行显示：\n1 2 3 4 5 6 -a 全部文件系统列表 -h 以方便阅读的方式显示信息 -i 显示inode信息 -k 区块为1024字节 -l 只显示本地磁盘 -T 列出文件系统类型 实例：\n（1）显示磁盘使用情况\n1 df -l （2）以易读方式列出所有文件系统及其类型\n1 df -haT du 命令 du 命令也是查看使用空间的，但是与 df 命令不同的是 Linux du 命令是对文件和目录磁盘使用的空间的查看：\n命令格式：\n1 du [选项] [文件] 常用参数：\n1 2 3 4 5 6 7 -a 显示目录中所有文件大小 -k 以KB为单位显示文件大小 -m 以MB为单位显示文件大小 -g 以GB为单位显示文件大小 -h 以易读方式显示文件大小 -s 仅显示总计 -c或--total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和 实例：\n（1）以易读方式显示文件夹内及子文件夹大小\n1 du -h scf/ （2）以易读方式显示文件夹内所有文件大小\n1 du -ah scf/ （3）显示几个文件或目录各自占用磁盘空间的大小，还统计它们的总和\n1 du -hc test/ scf/ （4）输出当前目录下各个子目录所使用的空间\n1 du -hc --max-depth=1 scf/ 24、date 命令 显示或设定系统的日期与时间。\n命令参数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 -d\u0026lt;字符串\u0026gt; 显示字符串所指的日期与时间。字符串前后必须加上双引号。 -s\u0026lt;字符串\u0026gt; 根据字符串来设置日期与时间。字符串前后必须加上双引号。 -u 显示GMT。 %H 小时(00-23) %I 小时(00-12) %M 分钟(以00-59来表示) %s 总秒数。起算时间为1970-01-01 00:00:00 UTC。 %S 秒(以本地的惯用法来表示) %a 星期的缩写。 %A 星期的完整名称。 %d 日期(以01-31来表示)。 %D 日期(含年月日)。 %m 月份(以01-12来表示)。 %y 年份(以00-99来表示)。 %Y 年份(以四位数来表示)。 实例：\n（1）显示下一天\n1 date +%Y%m%d --date=\u0026#34;+1 day\u0026#34; //显示下一天的日期 （2）-d参数使用\n1 2 3 4 5 6 7 date -d \u0026#34;nov 22\u0026#34; 今年的 11 月 22 日是星期三 date -d \u0026#39;2 weeks\u0026#39; 2周后的日期 date -d \u0026#39;next monday\u0026#39; (下周一的日期) date -d next-day +%Y%m%d（明天的日期）或者：date -d tomorrow +%Y%m%d date -d last-day +%Y%m%d(昨天的日期) 或者：date -d yesterday +%Y%m%d date -d last-month +%Y%m(上个月是几月) date -d next-month +%Y%m(下个月是几月) 25、cal 命令 可以用户显示公历（阳历）日历如只有一个参数，则表示年份(1-9999)，如有两个参数，则表示月份和年份：\n常用参数：\n1 2 3 4 -3 显示前一月，当前月，后一月三个月的日历 -m 显示星期一为第一列 -j 显示在当前年第几天 -y [year]显示当前年[year]份的日历 实例：\n（1）显示指定年月日期\n1 cal 9 2012 （2）显示2013年每个月日历\n1 cal -y 2013 （3）将星期一做为第一列,显示前中后三月\n1 cal -3m grep 命令 强大的文本搜索命令，grep(Global Regular Expression Print) 全局正则表达式搜索。\ngrep 的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。\n命令格式：\n1 grep [option] pattern file|dir 常用参数：\n1 2 3 4 5 6 7 8 9 -A n --after-context显示匹配字符后n行 -B n --before-context显示匹配字符前n行 -C n --context 显示匹配字符前后n行 -c --count 计算符合样式的列数 -i 忽略大小写 -l 只列出文件内容符合指定的样式的文件名称 -f 从文件中读取关键词 -n 显示匹配内容的所在文件中行数 -R 递归查找文件夹 grep 的规则表达式:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ^ #锚定行的开始 如：\u0026#39;^grep\u0026#39;匹配所有以grep开头的行。 $ #锚定行的结束 如：\u0026#39;grep$\u0026#39;匹配所有以grep结尾的行。 . #匹配一个非换行符的字符 如：\u0026#39;gr.p\u0026#39;匹配gr后接一个任意字符，然后是p。 * #匹配零个或多个先前字符 如：\u0026#39;*grep\u0026#39;匹配所有一个或多个空格后紧跟grep的行。 .* #一起用代表任意字符。 [] #匹配一个指定范围内的字符，如\u0026#39;[Gg]rep\u0026#39;匹配Grep和grep。 [^] #匹配一个不在指定范围内的字符，如：\u0026#39;[^A-FH-Z]rep\u0026#39;匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。 \\(..\\) #标记匹配字符，如\u0026#39;\\(love\\)\u0026#39;，love被标记为1。 \\\u0026lt; #锚定单词的开始，如:\u0026#39;\\\u0026lt;grep\u0026#39;匹配包含以grep开头的单词的行。 \\\u0026gt; #锚定单词的结束，如\u0026#39;grep\\\u0026gt;\u0026#39;匹配包含以grep结尾的单词的行。 x\\{m\\} #重复字符x，m次，如：\u0026#39;0\\{5\\}\u0026#39;匹配包含5个o的行。 x\\{m,\\} #重复字符x,至少m次，如：\u0026#39;o\\{5,\\}\u0026#39;匹配至少有5个o的行。 x\\{m,n\\} #重复字符x，至少m次，不多于n次，如：\u0026#39;o\\{5,10\\}\u0026#39;匹配5--10个o的行。 \\w #匹配文字和数字字符，也就是[A-Za-z0-9]，如：\u0026#39;G\\w*p\u0026#39;匹配以G后跟零个或多个文字或数字字符，然后是p。 \\W #\\w的反置形式，匹配一个或多个非单词字符，如点号句号等。 \\b #单词锁定符，如: \u0026#39;\\bgrep\\b\u0026#39;只匹配grep。 实例：\n（1）查找指定进程\n1 ps -ef | grep svn （2）查找指定进程个数\n1 ps -ef | grep svn -c （3）从文件中读取关键词\n1 cat test1.txt | grep -f key.log （4）从文件夹中递归查找以grep开头的行，并只列出文件\n1 grep -lR \u0026#39;^grep\u0026#39; /tmp （5）查找非x开关的行内容\n1 grep \u0026#39;^[^x]\u0026#39; test.txt （6）显示包含 ed 或者 at 字符的内容行\n1 grep -E \u0026#39;ed|at\u0026#39; test.txt 27、wc 命令 wc(word count)功能为统计指定的文件中字节数、字数、行数，并将统计结果输出\n命令格式：\n1 wc [option] file.. 命令参数：\n1 2 3 4 -c 统计字节数 -l 统计行数 -m 统计字符数 -w 统计词数，一个字被定义为由空白、跳格或换行字符分隔的字符串 实例：\n（1）查找文件的 行数 单词数 字节数 文件名\n1 wc text.txt 结果：\n1 7 8 70 test.txt （2）统计输出结果的行数\n1 cat test.txt | wc -l ps 命令 ps(process status)，用来查看当前运行的进程状态，一次性查看，如果需要动态连续结果使用 top\nlinux上进程有5种状态:\n运行(正在运行或在运行队列中等待) 中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号) 不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生) 僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放) 停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行) ps 工具标识进程的5种状态码:\n1 2 3 4 5 D 不可中断 uninterruptible sleep (usually IO) R 运行 runnable (on run queue) S 中断 sleeping T 停止 traced or stopped Z 僵死 a defunct (”zombie”) process 命令参数：\n1 2 3 4 5 6 7 8 -A 显示所有进程 a 显示所有进程 -a 显示同一终端下所有进程 c 显示进程真实名称 e 显示环境变量 f 显示进程间的关系 r 显示当前终端运行的进程 -aux 显示所有包含其它使用的进程 实例：\n（1）显示当前所有进程环境变量及进程间关系\n1 ps -ef （2）显示当前所有进程\n1 ps -A （3）与grep联用查找某进程\n1 ps -aux | grep apache （4）找出与 cron 与 syslog 这两个服务有关的 PID 号码\n1 ps aux | grep \u0026#39;(cron|syslog)\u0026#39; 29、top 命令\n显示当前系统正在执行的进程的相关信息，包括进程 ID、内存占用率、CPU 占用率等\n常用参数：\n1 2 3 4 -c 显示完整的进程命令 -s 保密模式 -p \u0026lt;进程号\u0026gt; 指定进程显示 -n \u0026lt;次数\u0026gt;循环显示次数 实例：\n（1）\n1 2 3 4 5 6 7 top - 14:06:23 up 70 days, 16:44, 2 users, load average: 1.25, 1.32, 1.35 Tasks: 206 total, 1 running, 205 sleeping, 0 stopped, 0 zombie Cpu(s): 5.9%us, 3.4%sy, 0.0%ni, 90.4%id, 0.0%wa, 0.0%hi, 0.2%si, 0.0%st Mem: 32949016k total, 14411180k used, 18537836k free, 169884k buffers Swap: 32764556k total, 0k used, 32764556k free, 3612636k cached PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 28894 root 22 0 1501m 405m 10m S 52.2 1.3 2534:16 java 前五行是当前系统情况整体的统计信息区。\n第一行，任务队列信息，同 uptime 命令的执行结果，具体参数说明情况如下：\n14:06:23 — 当前系统时间\nup 70 days, 16:44 — 系统已经运行了70天16小时44分钟（在这期间系统没有重启过的吆！）\n2 users — 当前有2个用户登录系统\nload average: 1.15, 1.42, 1.44 — load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。\nload average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。\n第二行，Tasks — 任务（进程），具体信息说明如下：\n系统现在共有206个进程，其中处于运行中的有1个，205个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。\n第三行，cpu状态信息，具体属性说明如下：\n1 2 3 4 5 6 7 5.9%us — 用户空间占用CPU的百分比。 3.4% sy — 内核空间占用CPU的百分比。 0.0% ni — 改变过优先级的进程占用CPU的百分比 90.4% id — 空闲CPU百分比 0.0% wa — IO等待占用CPU的百分比 0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比 0.2% si — 软中断（Software Interrupts）占用CPU的百分比 **备注：**在这里CPU的使用比率和windows概念不同，需要理解linux系统用户空间和内核空间的相关知识！\n第四行，内存状态，具体信息如下：\n1 2 3 4 32949016k total — 物理内存总量（32GB） 14411180k used — 使用中的内存总量（14GB） 18537836k free — 空闲内存总量（18GB） 169884k buffers — 缓存的内存量 （169M） 第五行，swap交换分区信息，具体信息说明如下：\n1 2 3 4 32764556k total — 交换区总量（32GB） 0k used — 使用的交换区总量（0K） 32764556k free — 空闲交换区总量（32GB） 3612636k cached — 缓冲的交换区总量（3.6GB） 第六行，空行。\n第七行以下：各进程（任务）的状态监控，项目列信息说明如下：\n1 2 3 4 5 6 7 8 9 10 11 12 PID — 进程id USER — 进程所有者 PR — 进程优先级 NI — nice值。负值表示高优先级，正值表示低优先级 VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA SHR — 共享内存大小，单位kb S — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程 %CPU — 上次更新到现在的CPU时间占用百分比 %MEM — 进程使用的物理内存百分比 TIME+ — 进程使用的CPU时间总计，单位1/100秒 COMMAND — 进程名称（命令名/命令行） top 交互命令\n1 2 3 4 5 6 7 h 显示top交互命令帮助信息 c 切换显示命令名称和完整命令行 m 以内存使用率排序 P 根据CPU使用百分比大小进行排序 T 根据时间/累计时间进行排序 W 将当前设置写入~/.toprc文件中 o或者O 改变显示项目的顺序 30、kill 命令 发送指定的信号到相应进程。不指定型号将发送SIGTERM（15）终止指定进程。如果任无法终止该程序可用\u0026quot;-KILL\u0026quot; 参数，其发送的信号为SIGKILL(9) ，将强制结束进程，使用ps命令或者jobs 命令可以查看进程号。root用户将影响用户的进程，非root用户只能影响自己的进程。\n常用参数：\n1 2 3 4 5 -l 信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称 -a 当处理当前进程时，不限制命令名和进程号的对应关系 -p 指定kill 命令只打印相关进程的进程号，而不发送任何信号 -s 指定发送信号 -u 指定用户 实例：\n（1）先使用ps查找进程pro1，然后用kill杀掉\n1 kill -9 $(ps -ef | grep pro1) 31、free 命令 显示系统内存使用情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。\n命令参数：\n1 2 3 4 5 6 -b 以Byte显示内存使用情况 -k 以kb为单位显示内存使用情况 -m 以mb为单位显示内存使用情况 -g 以gb为单位显示内存使用情况 -s\u0026lt;间隔秒数\u0026gt; 持续显示内存 -t 显示内存使用总合 实例：\n（1）显示内存使用情况\n1 2 3 free free -k free -m （2）以总和的形式显示内存的使用信息\n1 free -t （3）周期性查询内存使用情况\n1 free -s 10 文件处理命令 文件处理命令：file、mkdir、grep、dd、find、mv、ls、diff、cat、ln；\nfind 命令 用于在文件树中查找文件，并作出相应的处理。\n命令格式：\n1 find pathname -options [-print -exec -ok ...] 命令参数：\n1 2 3 4 pathname: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。 -print： find命令将匹配的文件输出到标准输出。 -exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为\u0026#39;command\u0026#39; { } \\;，注意{ }和\\；之间的空格。 -ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。 命令选项：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 -name 按照文件名查找文件 -perm 按文件权限查找文件 -user 按文件属主查找文件 -group 按照文件所属的组来查找文件。 -type 查找某一类型的文件，诸如： b - 块设备文件 d - 目录 c - 字符设备文件 l - 符号链接文件 p - 管道文件 f - 普通文件 -size n :[c] 查找文件长度为n块文件，带有c时表文件字节大小 -amin n 查找系统中最后N分钟访问的文件 -atime n 查找系统中最后n*24小时访问的文件 -cmin n 查找系统中最后N分钟被改变文件状态的文件 -ctime n 查找系统中最后n*24小时被改变文件状态的文件 -mmin n 查找系统中最后N分钟被改变文件数据的文件 -mtime n 查找系统中最后n*24小时被改变文件数据的文件 (用减号-来限定更改时间在距今n日以内的文件，而用加号+来限定更改时间在距今n日以前的文件。 ) -maxdepth n 最大查找目录深度 -prune 选项来指出需要忽略的目录。在使用-prune选项时要当心，因为如果你同时使用了-depth选项，那么-prune选项就会被find命令忽略 -newer 如果希望查找更改时间比某个文件新但比另一个文件旧的所有文件，可以使用-newer选项 实例：\n（1）查找 48 小时内修改过的文件\n1 find -atime -2 （2）在当前目录查找 以 .log 结尾的文件。 . 代表当前目录\n1 find ./ -name \u0026#39;*.log\u0026#39; （3）查找 /opt 目录下 权限为 777 的文件\n1 find /opt -perm 777 （4）查找大于 1K 的文件\n1 find -size +1000c 查找等于 1000 字符的文件\n1 find -size 1000c -exec 参数后面跟的是 command 命令，它的终止是以 ; 为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。{} 花括号代表前面find查找出来的文件名。\n实例：\n（5）在当前目录中查找更改时间在10日以前的文件并删除它们(无提醒）\n1 find . -type f -mtime +10 -exec rm -f {} \\; （6）当前目录中查找所有文件名以.log结尾、更改时间在5日以上的文件，并删除它们，只不过在删除之前先给出提示。 按y键删除文件，按n键不删除\n1 find . -name \u0026#39;*.log\u0026#39; mtime +5 -ok -exec rm {} \\; （7）当前目录下查找文件名以 passwd 开头，内容包含 \u0026ldquo;pkg\u0026rdquo; 字符的文件\n1 find . -f -name \u0026#39;passwd*\u0026#39; -exec grep \u0026#34;pkg\u0026#34; {} \\; （8）用 exec 选项执行 cp 命令\n1 find . -name \u0026#39;*.log\u0026#39; -exec cp {} test3 \\; -xargs find 命令把匹配到的文件传递给 xargs 命令，而 xargs 命令每次只获取一部分文件而不是全部，不像 -exec 选项那样。这样它可以先处理最先获取的一部分文件，然后是下一批，并如此继续下去。\n实例：\n（9）查找当前目录下每个普通文件，然后使用 xargs 来判断文件类型\n1 find . -type f -print | xargs file （10）查找当前目录下所有以 js 结尾的并且其中包含 \u0026rsquo;editor\u0026rsquo; 字符的普通文件\n1 2 find . -type f -name \u0026#34;*.js\u0026#34; -exec grep -lF \u0026#39;ueditor\u0026#39; {} \\; find -type f -name \u0026#39;*.js\u0026#39; | xargs grep -lF \u0026#39;editor\u0026#39; （11）利用 xargs 执行 mv 命令\n1 find . -name \u0026#34;*.log\u0026#34; | xargs -i mv {} test4 （12）用 grep 命令在当前目录下的所有普通文件中搜索 hostnames 这个词，并标出所在行：\n1 find . -name \\*(转义） -type f -print | xargs grep -n \u0026#39;hostnames\u0026#39; （13）查找当前目录中以一个小写字母开头，最后是 4 到 9 加上 .log 结束的文件：\n1 find . -name \u0026#39;[a-z]*[4-9].log\u0026#39; -print （14）在 test 目录查找不在 test4 子目录查找\n1 find test -path \u0026#39;test/test4\u0026#39; -prune -o -print （15）实例1：查找更改时间比文件 log2012.log新但比文件 log2017.log 旧的文件\n1 find -newer log2012.log ! -newer log2017.log 使用 depth 选项：\ndepth 选项可以使 find 命令向磁带上备份文件系统时，希望首先备份所有的文件，其次再备份子目录中的文件。\n实例：find 命令从文件系统的根目录开始，查找一个名为 CON.FILE 的文件。 它将首先匹配所有的文件然后再进入子目录中查找\n1 find / -name \u0026#34;CON.FILE\u0026#34; -depth -print ln 命令 功能是为文件在另外一个位置建立一个同步的链接，当在不同目录需要该问题时，就不需要为每一个目录创建同样的文件，通过 ln 创建的链接（link）减少磁盘占用量。\n链接分类：软件链接及硬链接\n软链接：\n1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式 2.软链接可以 跨文件系统 ，硬链接不可以 3.软链接可以对一个不存在的文件名进行链接 4.软链接可以对目录进行链接 硬链接:\n1.硬链接，以文件副本的形式存在。但不占用实际空间。 2.不允许给目录创建硬链接 3.硬链接只有在同一个文件系统中才能创建 需要注意：\n第一：ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化； 第二：ln的链接又分软链接和硬链接两种，软链接就是ln –s 源文件 目标文件，它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接 ln 源文件 目标文件，没有参数-s， 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。 第三：ln指令用在链接文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则会把前面指定的所有文件或目录复制到该目录中。若同时指定多个文件或目录，且最后的目的地并非是一个已存在的目录，则会出现错误信息。 常用参数：\n1 2 3 -b 删除，覆盖以前建立的链接 -s 软链接（符号链接） -v 显示详细处理过程 实例：\n（1）给文件创建软链接，并显示操作信息\n1 ln -sv source.log link.log （2）给文件创建硬链接，并显示操作信息\n1 ln -v source.log link1.log （3）给目录创建软链接\n1 ln -sv /opt/soft/test/test3 /opt/soft/test/test5 ","date":"2025-04-03T00:00:00Z","permalink":"https://sfw003.github.io/p/linux-file-command/","title":"Linux 文件操作命令"},{"content":"文件 在谈文件系统前，首先谈谈什么是文件？\n文件结构体 文件 = 属性 + 内容 同进程PCB，linux也有管理文件属性的结构体\nstruct file：描述文件的打开状态，每次打开文件都会创建一个 file 结构，主要记录与进程操作文件相关的信息（如文件指针位置、打开模式等）。\nstruct inode：描述文件在磁盘或文件系统中的元数据，无论文件是否被打开，inode 都存在。\nstruct stat：用于在用户空间访问文件的属性信息，系统调用通过从 inode 获取属性并填充到 struct stat 中\n本文重点在前2个\n文件的权限 文件权限 每个文件和目录在 Linux 中都有三类权限，分别是：\n所有者（Owner） 所属组（Group） 其他用户（Others） 每类权限又分为三种操作权限：\n读（r，read）：允许查看文件内容或列出目录内容。 写（w，write）：允许修改文件内容或在目录中创建、删除文件。 执行（x，execute）：允许执行文件（如果是可执行程序）或访问目录中的文件。 这些权限被表示为一个 9 位的二进制组合，如下：\nrwxrwxrwx\n前三个字符表示文件的所有者权限。 中间三个字符表示文件的所属组权限。 最后三个字符表示其他用户的权限。 有权限则对应的二进制位为1 例如，文件权限 755 表示：rwxr-xr-x\n文件掩码（umask）用于决定在创建文件或目录时默认权限会被如何设置。它是一个权限的反向屏蔽值，掩码中的位会关闭（去除）文件或目录的默认权限。\n对于文件，默认权限为 666（即只有读和写权限，没有执行权限）。 对于目录，默认权限为 777（即读、写、执行权限全部开放）。 码会从这些默认权限中减去相应的权限。例如： 一个常见的掩码值为 022。这意味着从默认权限中去掉组和其他用户的写权限：\n文件权限：666 - 022 = 644（所有者有读写权限，组和其他用户只有读权限） 目录权限：777 - 022 = 755（所有者有全部权限，组和其他用户有读和执行权限） 1 2 3 4 5 6 7 8 查看当前掩码： umask 临时设置 umask（只对当前会话有效）： umask 002 永久更改 umask 将 umask 命令添加到你的 shell 启动文件中（例如 ~/.bashrc 或 ~/.profile） 文件的状态 文件有2种状态：打开和未打开 对于一个打开的文件，我们重点关注谁打开？谁进行维护？进程！因此要研究进程和文件的关系 对于一个未打开的文件，我们重点关注放在哪里？如何分门别类的放置好？因此我们需要研究linux的文件系统。\n打开的文件 对于打开的文件，我们要研究进程和文件的关系。下面按照如下顺序来讲解：\n进程如何操作文件？研究linux下的文件系统调用 底层是如何将进程和打开的文件联系在一起？研究struct task_struct和struct file Linux下文件的系统调用 linux系统提供的常见文件接口： open write read close\nopen \u0026amp;\u0026amp; close 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; int open(const char *pathname, int flags); int open(const char *pathname, int flags, mode_t mode); #include \u0026lt;unistd.h\u0026gt; int close(int fd); 参数介绍 pathname -- 文件路径 flags -- 文件打开方式 mode -- 文件掩码 flags参数是标志位，告诉open函数是要以读还是以写的方式打开文件。传参内容如下： O_WRONLY：以写的方式打开文件 O_RDONLY：以读的方式打开文件 O_RDWR：以读写的方式打开文件 O_CREAT：当文件不存在时，创建文件 O_APPEND：在文件末尾追加\n疑问：如何传递多个标志位？ 原理如下图，通过位图的方式,每个标志（如 O_RDWR、O_CREAT、O_TRUNC 等）都是一个特定的整数值，其中每个标志都使用一个或多个二进制位来表示。因为这些标志的二进制表示互不重叠（即它们的值在二进制上不冲突），可以通过按位或运算符（|）将它们组合在一起。 如：int fd = open(\u0026quot;example.txt\u0026quot;, O_RDWR | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR); mode参数： 新建文件的权限 使用: int fd = open(\u0026ldquo;sfw.txt\u0026rdquo;, O_WRONLY|O_CREAT, 0666); 最后文件的权限是664，这是由于权限掩码的影响\n返回值：文件描述符 后文会详细介绍，这里就简单认为是为open的文件分配一个id，将这个id作为read和write的参数可以对open的文件进行读写。\nread \u0026amp;\u0026amp; write 1 2 3 #include \u0026lt;unistd.h\u0026gt; ssize_t read(int fd, void *buf, size_t count); ssize_t write(int fd, const void *buf, size_t count); 使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { int fd = open(\u0026#34;log.txt\u0026#34;, O_WRONLY | O_CREAT, 0666); char buf[] = \u0026#34;6666\\n\u0026#34;; write(fd, buf, strlen(buf)); close(fd); } 结果： root@iZbp1inz4ol3gjahpjal9qZ:~/test# ls log.txt t1 t1.c root@iZbp1inz4ol3gjahpjal9qZ:~/test# cat log.txt 6666 root@iZbp1inz4ol3gjahpjal9qZ:~/test# 文件描述符fd和struct file 在Linux系统中用来描述一个打开的文件的结构体是struct file\n1 2 3 4 5 6 7 8 9 10 11 struct file { struct list_head f_list; // 文件对象的链表，用于内核维护打开文件的列表 struct vfsmount *f_path; // 文件路径及挂载点信息 struct dentry *f_dentry; // 文件的目录项 const struct file_operations *f_op; // 文件操作函数指针 atomic_long_t f_count; // 引用计数 unsigned int f_flags; // 文件状态标志（读写、非阻塞等） loff_t f_pos; // 文件当前的读写位置（文件指针） void *private_data; // 文件私有数据（特定文件系统或设备的私有数据） ... }; 进程打开文件的本质即是 task_struct和 file 建立联系。如何联系？如下图 task_struct 有一个成员 struct file_struct* files, 它指向结构体 struct files_struct。在struct files_struct 有个指针数组struct file* fd_array[]，该数组存储struct file* 指针。由次 task_struct 与 file 建立了联系。所谓的文件描述符就是struct file* fd_array[]数组的下标。 内核源代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 struct files_struct { atomic_t count; spinlock_t file_lock; /* Protects all the below members. Nests inside tsk-\u0026gt;alloc_lock */ int max_fds; int max_fdset; int next_fd; struct file ** fd; /* current fd array */ fd_set *close_on_exec; fd_set *open_fds; fd_set close_on_exec_init; fd_set open_fds_init; struct file * fd_array[NR_OPEN_DEFAULT]; }; 那现在打印文件描述符看看：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int main() { int fd1 = open(\u0026#34;log.txt\u0026#34;, O_WRONLY | O_CREAT, 0666); printf(\u0026#34;fd1 = %d\\n\u0026#34;, fd1); int fd2 = open(\u0026#34;log.txt\u0026#34;, O_WRONLY | O_CREAT, 0666); printf(\u0026#34;fd2 = %d\\n\u0026#34;, fd2); int fd3 = open(\u0026#34;log.txt\u0026#34;, O_WRONLY | O_CREAT, 0666); printf(\u0026#34;fd3 = %d\\n\u0026#34;, fd3); close(fd1); close(fd2); close(fd3); } 结果： fd1 = 3 fd2 = 4 fd3 = 5 为什么是从3开始？\n我们在学习C语言的文件操作时，应该会了解：C语言默认打开3个文件流：stdin, stdout, stderr stdin \u0026ndash; 标准输入 \u0026ndash; 对应键盘 stdout \u0026ndash; 标准输出 \u0026ndash; 对应显示器 stderr \u0026ndash; 标准错误输出 \u0026ndash; 对应显示器 其他语言类似。\n实际，这并不是语言的特性，而是操作系统的特性。操作系统默认会打开3个文件描述符 0 \u0026ndash; 标准输入 \u0026ndash; 对应键盘 1 \u0026ndash; 标准输出 \u0026ndash; 对应显示器 2 \u0026ndash; 标准错误输出 \u0026ndash; 对应显示器\n验证：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int main() { char buf[] = \u0026#34;sfsfsf\\n\u0026#34;; write(1, buf, strlen(buf)); write(2, buf, strlen(buf)); } 结果： root@iZbp1inz4ol3gjahpjal9qZ:~/test# ./t1 sfsfsf sfsfsf 文件描述符的分配规则：在files_struct数组当中，找到当前没有被使用的最小的一个下标，作为新的文件描述符。 所以，除去系统默认打开文件，打开的文件的文件描述符默认从3开始。\n小知识：\n文件描述符1，2都指向显示器，那关闭1，2会受影响吗？不会，类比智能指针shared_ptr的引用计数 可以推测，不同语言的文件结构体或者文件类中，一定包含一个成员，文件描述符 重定向 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { close(1); int fd = open(\u0026#34;myfile\u0026#34;, O_WRONLY|O_CREAT, 00644); printf(\u0026#34;fd: %d\\n\u0026#34;, fd); fflush(stdout); close(fd); return 0; } 此时，我们发现，本来应该输出到显示器上的内容，输出到了文件 myfile 当中，其中，fd＝1。这种现象叫做输出重定向。原理如下。 重定向方法 重定向符号 说明 示例 \u0026lt; 将文件内容作为命令的标准输入 command \u0026lt; input_file \u0026gt; 将命令的标准输出重定向到文件（覆盖原文件） command \u0026gt; output_file \u0026gt;\u0026gt; 将命令的标准输出追加到文件末尾 command \u0026gt;\u0026gt; output_file 2\u0026gt; 将命令的标准错误输出重定向到文件 command 2\u0026gt; error_file 2\u0026gt;\u0026gt; 将标准错误追加到文件末尾 command 2\u0026gt;\u0026gt; error_file \u0026amp;\u0026gt; 将标准输出和标准错误同时重定向到文件 command \u0026amp;\u0026gt; output_file \u0026amp;\u0026gt;\u0026gt; 将标准输出和标准错误追加重定向到文件末尾 command \u0026amp;\u0026gt;\u0026gt; output_file 2\u0026gt;\u0026amp;1 将标准错误重定向到标准输出 command \u0026gt; output_file 2\u0026gt;\u0026amp;1 ` tee` 将标准输出显示在终端并写入文件 1 2 3 4 5 6 7 8 9 10 11 12 root@iZbp1inz4ol3gjahpjal9qZ:~/study# ls myfile t1.c root@iZbp1inz4ol3gjahpjal9qZ:~/study# echo \u0026#34;5555\u0026#34; \u0026gt; myfile 将打印到显示器的信息重定向到myfile root@iZbp1inz4ol3gjahpjal9qZ:~/study# cat myfile 5555 root@iZbp1inz4ol3gjahpjal9qZ:~/study# echo \u0026#34;6666\u0026#34; \u0026gt; myfile 重定向会清空文件原有的内容 root@iZbp1inz4ol3gjahpjal9qZ:~/study# cat myfile 6666 root@iZbp1inz4ol3gjahpjal9qZ:~/study# echo \u0026#34;7777\u0026#34; \u0026gt;\u0026gt; myfile 追加重定向不会清空原有内容 root@iZbp1inz4ol3gjahpjal9qZ:~/study# cat myfile 6666 7777 这些操作本质都是通过系统调用dup来实现的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 NAME dup, dup2, dup3 - duplicate a file descriptor SYNOPSIS #include \u0026lt;unistd.h\u0026gt; int dup(int oldfd); int dup2(int oldfd, int newfd); #define _GNU_SOURCE /* See feature_test_macros(7) */ #include \u0026lt;fcntl.h\u0026gt; /* Obtain O_* constant definitions */ #include \u0026lt;unistd.h\u0026gt; int dup3(int oldfd, int newfd, int flags); dup系统调用接口中，最常用的是dup2。 注意它的含义：让newfd对应文件替换为oldfd指向的文件。 简单理解：最后oldfd和newfd都指向oldfd对应的文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; int main() { int fd = open(\u0026#34;./log\u0026#34;, O_CREAT | O_RDWR); if (fd \u0026lt; 0) { perror(\u0026#34;open\u0026#34;); return 1; } close(1); dup2(fd, 1); char buf[1024] = {0}; ssize_t read_size = read(0, buf, sizeof(buf) - 1); if (read_size \u0026lt; 0) { perror(\u0026#34;read\u0026#34;); return 1; } printf(\u0026#34;%s\u0026#34;, buf); fflush(stdout); return 0; } 用户缓冲区 看下面一段代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { const char *msg0=\u0026#34;hello printf\\n\u0026#34;; const char *msg1=\u0026#34;hello fwrite\\n\u0026#34;; const char *msg2=\u0026#34;hello write\\n\u0026#34;; printf(\u0026#34;%s\u0026#34;, msg0); fwrite(msg1, strlen(msg0), 1, stdout); write(1, msg2, strlen(msg2)); fork(); return 0; } 结果：\n1 2 3 4 5 6 7 8 9 10 11 root@iZbp1inz4ol3gjahpjal9qZ:~/study# ./t1 hello printf hello fwrite hello write root@iZbp1inz4ol3gjahpjal9qZ:~/study# ./t1 \u0026gt; myfile root@iZbp1inz4ol3gjahpjal9qZ:~/study# cat myfile hello write hello printf hello fwrite hello printf hello fwrite 为什么打印屏幕上和重定向到文件的结果不一样？\n我们发现 printf 和 fwrite （库函数）都输出了2次，而 write 只输出了一次（系统调用）。为什么呢？肯定和 fork有关！一般C库函数写入文件时是全缓冲的，而写入显示器是行缓冲。printf fwrite 库函数会自带缓冲区，当发生重定向到普通文件时，数据的缓冲方式由行缓冲变成了全缓冲。 而我们放在缓冲区中的数据，就不会被立即刷新，当进程退出之后，会统一刷新，写入文件当中。 但是fork的时候，父子数据会发生写时拷贝，所以当你父进程准备刷新的时候，子进程也就有了同样的 一份数据，随即产生两份数据。write 没有变化，说明没有所谓的缓冲区。 未打开的文件 linux的文件系统 假设现在linux的文件系统要管理一个1000GB的磁盘。 它的第一步便是要对1000GB进行划分，因为太大了，这一过程便是分区。如何分？随便分。对于操作系统，定义一个结构体，里面定义start，end,便可以很容易的记录各个区的起始于结尾，因此分区对于操作系统来说非常简单。此时系统便将管理1000GB的任务 \u0026ndash;\u0026gt; 管理200GB的任务。只要系统将200GB的空间管理好，后面的150GB，120GB同理即可。 200GB对于操作系统还是太大，于是系统可以继续分。直到最后分成一个基本块（block）。 Linux ext2文件系统，上图为磁盘文件系统图（内核内存映像肯定有所不同），磁盘是典型的块设备，硬盘分区被划分为一个个的block。一个block的大小是由格式化的时候确定的，并且不可以更改。例如mke2fs的-b选项可以设定block大小为1024、2048或4096字节。而上图中启动块（Boot Block)的大小是确定的，\nBlock Group：ext2文件系统会根据分区的大小划分为数个Block Group。而每个Block Group都有着相 同的结构组成。政府管理各区的例子 Super Block：存放文件系统本身的结构信息。记录的信息主要有：bolck 和 inode的总量，未使用的block和inode的数量，一个block和inode的大小，最近一次挂载的时间，最近一次写入数据的时间，最近一次检验磁盘的时间等其他文件系统的相关信息。Super Block的信息被破坏，可以说整个文件系统结构就被破坏了 Group Descriptor Table：块组描述符，描述块组属性信息。 Block Bitmap：Block Bitmap中记录着Data Block中哪个数据块已经被占用，哪个数据块没有被占用 inode Bitmap：每个bit表示一个inode是否空闲可用。 inode Table：存放struct inode，存储文件属性。每个inode带有编号 Data blocks：存放Data block，每一个Data block带有编号 介绍一下它们之间的关系： 当我们创建一个新文件时：\n1 2 3 [root@localhost linux]# touch abc [root@localhost linux]# ls -i abc //-i 查看该文件的inode编号 263466 abc 疑问：\n3种情况：\n新建一个文件，系统所做如上 删除一个文件，系统只需要把 block bitmap和inode bitmap中对应位图置0 查找和修改 用户并不知道inode编号，只知道文件名，那系统如何通过文件名找到inode呢？ 目录也是一个文件，它存储的内容是文件名和inode的对应关系。 那目录本身呢？谁存储目的的文件名和inode的对应关系？上一级目录。最后所有目录都会指向一个目录：根目录。因此查找一文件，对系统来说是从根目录递归向下查找。这是不是太慢了？当然，因此要不断访问磁盘。为此，Linux 系统会缓存多种数据以提高性能，包括文件系统的元数据、文件内容以及目录结构。当你访问文件时，系统会将这些数据存储在内存中，以便快速访问，减少磁盘读写操作。 软硬链接 linux下通过ln命令可以为文件创建软硬链接\n1 2 3 4 5 文件 test.txt 创建硬链接 ln 目标文件（不能是目录） 硬链接名 ln test.txt hard_link 创建软链接 ln -s 目标文件 软链接名 ln -s test.txt soft_link 问题1：软硬链接是干什么的？ 答：用于建立文件之间的联系 问题2：软硬链接有什么区别？ 软链接是一个独立的文件，因为它有独立的inode, 硬链接不是一个独立的文件，因为它没有独立的inode.\n通过上面的例子可以看出：test.txt的inode(1050440)与hard_link的inode(1050440)相同，而我们知道，每个文件的inode是唯一的，因此可以推断hard_link不是一个独立的文件，反之，soft_link是一个独立的文件，因为它有独立的inode.\n我们应该如何去理解软硬链接呢？\n对于软链接：它完全等同于windows下创建软件的快捷方式。它存储指向文件的存储路径（地址）\n对于硬链接：硬链接本质是在特定的目录数据块中新增 文件名 和 指向文件的inode编号 的映射关系，就像c++里的引用一样。 通过ls -l命令可以看到文件的硬链接数，如下图红框处。如果你了解引用计数的概念，这个理解起来就很轻松。 假如我们删去test.txt，与文件inode:105040的文件名减少一个，因此引用计数减1，由2变为1，因此下方hard_link前面的数字变为1。而soft_link存储的是test.txt的路径（地址），test.txt文件没了，显然soft_link就失效了， 问题3：软硬链接有哪些应用场景？ 答：软链接就不用说了。硬链接的经典的应用场景便是目录。linux创建一个目录，你会发现它的引用计数是2，说明有一个硬链接指向它，那这个硬链接在哪里呢？ 每个目录创建时，会自动创建两个隐藏文件.和..，它们都是硬链接。 问题4：为什么用户不能给目录设置硬链接？ 循环引用问题：如果允许用户给目录创建硬链接，那么用户可以创建一个目录结构的循环，比如目录A指向目录B，目录B又指向目录A，最终导致无限循环。这种情况会破坏文件系统的层次结构，并使得一些文件系统操作（如遍历文件树）变得复杂和无法实现。\n","date":"2025-04-03T00:00:00Z","permalink":"https://sfw003.github.io/p/linux-file-system/","title":"Linux 文件系统"},{"content":"绘图文件，在linux系列文章:进程管理\n线程与TCB 线程（Thread）是进程内的一个执行分支，线程的执行粒度，要比进程更细。\n如何理解？\nlinux下的线程与pthread库 linux没有真正意义的线程，这在很多教材都提过的观点。究其原因，就如上图所示，让n个PCB来管理一个进程地址空间不就有了线程了。区别windows系统专门设置了TCB结构体，linux选择用PCB来模拟TCB，因此linux可以说没有真正意义的线程，而是叫做轻量级进程。\n你linux搞特殊是吧？我想使用线程，你告诉我说让我使用轻量级进程。这让用户满意吗？于是linux封装了一个库 pthread，让用户可以使用到用户级线程，并不能叫做内核级线程，因为在linux内核中只有轻量级进程。可以通过下图来理解：\n注：\n轻量级进程:用户级线程 = 1:1 用户使用到的TCB结构体并不在内核空间中。 上图中出现了2个名词：线程栈和线程局部存储\n线程栈 每一个线程都有自己的调用链，注定了每个线程都要有调用链对应的栈帧结构，用来存储线程函数中的局部变量、函数参数以及函数调用的返回地址等信息。这一点类似进程的main函数的函数栈帧。这里的线程栈由pthread来维护，有了线程栈，才能在内核里创建执行流，有了新的执行流，才是一个真正的线程。\npthread是如何创建线程栈？\ninux下只有轻量级进程的概念，自然linux会提供轻量级进程的接口，pthread库正是对轻量级进程的接口进行了封装，才在用户层创建了线程的概念。\nlinux下创建轻量级进程的系统接口是clone\n如何验证？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int g_val = 0; void *thread_routine(void* arg) { int* pi = (int*)arg; int i = *pi; int j = 0; while(j \u0026lt; 5) { cout \u0026lt;\u0026lt; \u0026#34;thread-\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;, j=\u0026#34; \u0026lt;\u0026lt; j \u0026lt;\u0026lt; \u0026#34;, \u0026amp;j=\u0026#34; \u0026lt;\u0026lt; \u0026amp;j \u0026lt;\u0026lt; \u0026#34;, g_val=\u0026#34; \u0026lt;\u0026lt; g_val \u0026lt;\u0026lt; \u0026#34;, \u0026amp;g_val=\u0026#34; \u0026lt;\u0026lt; \u0026amp;g_val \u0026lt;\u0026lt; endl; sleep(2); j++, g_val++; } return NULL; } int main() { int i = 0; std:;vector\u0026lt;pthread_t\u0026gt; tids; while(i \u0026lt; 4) { pthread_t tid; pthread_create(\u0026amp;tid, nullptr, thread_routine, (void*)\u0026amp;i); sleep(1); tids.push_back(tid); i++; } for(int j = 0; j \u0026lt; 4; j++){ pthread_join(tids[j], nullptr); sleep(1); } sleep(3); return 0; } 不同的线程，都执行的同一个函数thread_routine，但函数内部的临时变量j，不是共享的，如果是共享的，那么不同的线程的j的地址应该一样。但结果表明，j的地址都不同。这也表明线程有自己独立的栈结构。\n对于全局变量g_val，不同线程是共享的。\n插入一个问题：线程栈由多大？\n在linux系统中使用 ulimit -a可以查看\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 root@hcss-ecs-f8b5:/blog# ulimit -a real-time non-blocking time (microseconds, -R) unlimited core file size (blocks, -c) 0 data seg size (kbytes, -d) unlimited scheduling priority (-e) 0 file size (blocks, -f) unlimited pending signals (-i) 6628 max locked memory (kbytes, -l) 226728 max memory size (kbytes, -m) unlimited open files (-n) 65535 pipe size (512 bytes, -p) 8 POSIX message queues (bytes, -q) 819200 real-time priority (-r) 0 stack size (kbytes, -s) 8192 cpu time (seconds, -t) unlimited max user processes (-u) 6628 virtual memory (kbytes, -v) unlimited file locks (-x) unlimited stack size (kbytes, -s) 8192 约为8M\n线程的局部存储 如果我想线程拥有私有的全局变量呢？这就要使用线程的局部存储。 int g_val = 0 改为 __thread in g_val = 0 此时不同的线程的变量g_val，都是不同的 在变量前加上 __thread， 就可以将该变量改为局部存储。除了这个关键字之外，pthread库中也有一些函数可以实现局部存储。\n__thread 是 GCC 中用于实现线程局部存储（Thread Local Storage，TLS）的关键字。它可以用来声明线程局部变量，这些变量对于每个线程是唯一的，不同线程之间的变量不会相互影响。但是它只能声明内置类型，无法声明自定义类型。 需要注意的是，__thread 关键字是 GCC 的扩展语法，虽然在大多数情况下可以正常工作，但并不是 C 标准的一部分，因此在一些不支持 GCC 扩展语法的编译器中可能无法使用。在 C11 标准中引入了 _Thread_local 关键字，用于实现线程局部存储，具有类似的功能，而且是标准化的语法。\n线程的竞争与协作 进程地址空间存在的意义是什么？扩大地址空间，内存保护、进程隔离。这中间最重要一点的就是进程隔离，它可以放在数据被随意修改。现在多个线程共享一个进程地址空间，不可避免的就会出现数据竞争的问题。\n看下面这段代码：4个线程同时访问全局变量tickets\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int tickets = 1000; void *getTickets(void* arg) { int* pi = (int*)arg; int i = *pi; while(1) { //票大于0才抢 if(tickets \u0026gt; 0) { usleep(1000); printf(\u0026#34;thread-%d, get a ticket: %d\\n\u0026#34;, i, tickets); tickets--; } else { break; } } return nullptr; } int main() { int i = 0; std::vector\u0026lt;pthread_t\u0026gt; tids; while(i \u0026lt; 4) { pthread_t tid; pthread_create(\u0026amp;tid, nullptr, getTickets, (void*)\u0026amp;i); tids.push_back(tid); i++; } for(int j = 0; j \u0026lt; 4; j++) { pthread_join(tids[j], nullptr); } sleep(3); return 0; } 按照抢票的逻辑，票\u0026gt;0才抢，\u0026lt;=0就退出，怎么会出现负数呢？一张票应该属于一个线程，怎么出现了相同数字？问题就出在多线程并发访问。\n多线程执行操作共享变量会导致竞争状态，在执行过程中发生了上下文切换，得到了错误的结果。每次运行都可能得到不同的结果，存在不确定性，为了解决这类问题，我们需要引入同步和互斥\n同步和互斥相关概念 首先了解以下几个概念\n并发：指的是多个事情，在同一时间段内同时发生了。\n并行：指的是多个事情，在同一时间点上同时发生了。只有在多CPU的情况中，才会出现\n共享资源：多个线程之间可以并发访问的资源。\n临界资源：多个线程互斥访问的共享资源。（共享资源 且 同一时间只能由一个线程访问 即为临界资源）\n临界区：每个线程内部，访问临界资源的代码，就叫做临界区\n互斥：任何时刻，互斥保证有且只有一个执行流进入临界区，访问临界资源，通常对临界资源起保护作用\n同步：就是并发进程/线程在一些关键点上可能需要互相等待与互通消息，这种相互制约的等待与互通信息称为进程/线程同步。\n原子性：不会被任何调度机制打断的操作，该操作只有两态，要么完成，要么未完成\n了解完概念，下面的问题是如何实现线程的同步和互斥？\n同步和互斥的实现 操作系统提供实现线程协作的措施和方法，主要的方法有两种：\n锁 POSIX信号量 互斥锁和条件变量 一个线程进入临界区之前，需要申请锁，只有拿了锁，才能执行临界区的代码。锁只有一把，故当一个线程拿了锁后，其他线程在申请锁时就会被阻塞，只有当持有锁的线程执行完临界区代码、进行解锁后，其他线程才可以申请锁。此时便实现了多个线程互斥的访问共享资源。\n锁有2中基本类型：互斥锁（互斥量）和自旋锁，下面以互斥锁为例。\n单纯加锁已经解决了数据资源竞争问题，但是又引出了锁资源竞争的问题。不同线程对锁的竞争能力是不同，这可能导致大部分时间，锁都在某一个线程上，这将导致线程的饥饿问题\n为此，我们需要引入一个同步机制，比如条件变量\n条件变量（Condition Variable）是一种线程同步机制，需要与互斥锁（Mutex）结合使用，用于在线程间传递某个条件的状态并实现线程的等待和唤醒。条件变量允许一个或多个线程在满足特定条件之前进入等待状态，并在条件被满足时被唤醒。\n互斥锁和条件变量的使用（以下采用linux原生API) 互斥锁的原理 锁可以保护临界区被线程互斥访问。但锁同时也是所有线程共享，属于共享资源，那锁自身的互斥问题呢？那必须将申请锁设计成原子的。（不会被任何调度机制打断的操作，该操作只有两态，要么完成，要么未完成） 首先我们要有一个共识：一条汇编语句是原子的。 但加锁的过程不可能仅仅只是一条汇编语句。那是如何实现加锁过程是原子的呢？\n为了实现互斥锁操作,大多数体系结构都提供了swap或exchange指令,该指令的作用是把寄存器和内存单元的数据相交换,由于只有一条指令,保证了原子性,即使是多处理器平台,访问内存的 总线周期也有先后,一个处理器上的交换指令执行时另一个处理器的交换指令只能等待总线周期。\n1 2 3 4 5 6 7 8 9 10 11 12 lock: movb $0, %al xchgb %al, mutex if(al寄存器的内容〉0) { return 0; } else 挂起等待; goto lock; unlock: movb $l,mutex 唤醒等待Mutex的线程； return 0; POSIX信号量 POSIX信号量和SystemV信号量（进程间通信）作用相同，都是用于同步操作，达到无冲突的访问共享资源目的。 但POSIX可以用于线程间同步。\n信号量是什么？信号量本质是个计数器。类似但是绝不等于 int cnt;(这里的绝不等于体现在信号量的++和\u0026ndash;是原子的，但整形变量的++和\u0026ndash;不是原子的）\n那这个计数器记忆什么数据呢？临界资源的数量\n当申请时，信号量会预定临界资源给你。就像电影院买票，只要你买了票，不管你是否去看，电影院一定有你的位置。信号量同理，只要你向信号量申请了临界资源，就一定有可以使用的临界资源（不用担心临界资源是否就绪、是否存在等问题）\n正是这一特性，我们使用信号量就不用像互斥锁一样，加了锁还要用条件变量。\n信号量有2个操作P和V，P表示申请，V表示释放。 使用时的顺序：\n1 2 3 4 5 P(信号量) 使用临界资源 V(信号量） 经典同步问题 生产者消费者模型 生成者消费者模型是一种用于解决多线程或多进程间数据交换与同步的经典问题。 在该模型中，生产者负责生产数据并将其放入共享的缓冲区，而消费者则负责从缓冲区中获取数据并进行处理。这种模型通常用于解决生产者与消费者之间速度不匹配的情况，以及避免因为生产者和消费者之间的竞争条件而导致的数据丢失或不一致的问题。\n这里共享资源准确说是临界资源\n生产者消费者模型的组成：\n3种关系：生产者和生产者，消费者和消费者，生产者和消费者 2种角色：生产者、消费者 1个场所：特定结构的内存空间 从记忆的角度，我们可以简记为“321”原则。\n3种关系：\n生产者与生产者：当一个生产者进行生产时，其他生产者不能生产 \u0026ndash; 互斥（避免争夺同一空间） 消费者与消费者：当一个消费者进行消费时，其他消费者不能消费 \u0026ndash; 互斥 （避免争夺同一资源） 消费者与生产者：当一个生产者进行生产时，消费者不能进行消费 \u0026ndash; 互斥（原因：假如生产者正在生产，消费者这时要进行消费，刚好消费这个生产者生产的资源，哪你怎么知道生产者此时生产好了吗？消费者拿到完整的资源了吗？因此要互斥）。避免生产者向已满的缓冲区中放入数据，或消费者从空的缓冲区中获取数据的情况发生。\u0026ndash; 同步 这个模型的优势在哪？ 一般的结论：\n解耦生产者和消费者\n支持并发：由于生产者与消费者是两个独立的并发体，他们之间是用缓冲区作为桥梁连接，生产者只需要往缓冲区里丢数据，就可以继续生产下一个数据，而消费者只需要从缓冲区了拿数据即可，这样就不会因为彼此的处理速度而发生阻塞。\n支持忙闲不均：当数据制造快的时候，消费者来不及处理，未处理的数据可以暂时存在缓冲区中。 等生产者的制造速度慢下来，消费者再慢慢处理掉。这平衡了生产和消费速率\n高效\n这里重点说说高效，生产者消费者模型高效在哪？注意：前面提到3种关系都包含互斥，互斥决定了在共享资源中是串行访问，串行访问一点也不高效。\n这里高效体现在非临界区上：\n对于生产者：我们仅仅提到了它生产数据，它能凭空产生吗？一定需要它去获取“原材料”。因此在生产数据前，还有获取数据。\n对于消费者：前文我们指的消费，仅仅表示它把数据拿走了，但它拿走之后呢？一定要进行数据的加工和处理。因此在消费数据后，还有数据的加工和处理。\n临界区的代码是串行的，谈不上高效，但是生产者和消费者的非临界区是可以并发访问。而非临界区的并发访问才是生产者消费者模型高效的部分。\n基于阻塞队列的生产消费模型 在多线程编程中阻塞队列(Blocking Queue)是一种常用于实现生产者和消费者模型的数据结构。其与普通的队列区别：当队列为空时，从队列获取元素的操作将会被阻塞，直到队列中被放入了元素；当队列满时，往队列里存放元素的操作也会被阻塞，直到有元素被从队列中取出(以上的操作都是基于不同的线程来说的，线程在对阻塞队列进程操作时会被阻塞)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #pragma once #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;pthread.h\u0026gt; template\u0026lt;class T\u0026gt; class blockqueue { static const int defaultnum = 10; // 加锁 - 等待 - 唤醒 - 解锁 public: blockqueue(int maxcap = defaultnum):maxcap_(maxcap) { pthread_mutex_init(\u0026amp;mutex_, nullptr); pthread_cond_init(\u0026amp;p_cond_, nullptr); pthread_cond_init(\u0026amp;c_cond_, nullptr); } ~blockqueue() { pthread_mutex_destroy(\u0026amp;mutex_); pthread_cond_destroy(\u0026amp;c_cond_); pthread_cond_destroy(\u0026amp;p_cond_); } T pop() { pthread_mutex_lock(\u0026amp;mutex_); while(q_.empty()) //为什么不用if来判断？ { pthread_cond_wait(\u0026amp;c_cond_, \u0026amp;mutex_); } T out = q_.front(); q_.pop(); pthread_cond_signal(\u0026amp;p_cond_); // 消费后，唤醒生产者 pthread_mutex_unlock(\u0026amp;mutex_); return out; } void push(const T\u0026amp; in) { pthread_mutex_lock(\u0026amp;mutex_); while(q_.size() == maxcap_) { pthread_cond_wait(\u0026amp;p_cond_, \u0026amp;mutex_); } q_.push(in); pthread_cond_signal(\u0026amp;c_cond_); // 生产后，唤醒消费者 pthread_mutex_unlock(\u0026amp;mutex_); } private: std::queue\u0026lt;T\u0026gt; q_; int maxcap_; pthread_mutex_t mutex_; pthread_cond_t c_cond_; pthread_cond_t p_cond_; }; 细节：为什么在判断条件时，用while循环？ 操作系统层面的条件变量（如 pthread_cond_wait）在实现上可能因某些原因（如信号中断或内核调度）导致线程被意外唤醒，即使没有其他线程显式调用 pthread_cond_signal。即 伪唤醒\n在上面代码就会导致一个问题，同时唤醒的生产者/消费者线程可能不止一个。\n如下图：假设a是被正常唤醒，b，c是伪唤醒\n使用while循环后，伪唤醒的b还会先判断以下 q_.size() == maxcap_\n锁 * 锁的种类 互斥锁和自旋锁 互斥锁和自旋锁是并发编程中最基础的两种锁，其核心区别在于等待锁时的行为\n互斥锁：通过休眠让出CPU，减少资源占用，但引入上下文切换开销 自旋锁：通过忙等待避免切换，适合短临界区，但可能浪费CPU周期 互斥锁加锁失败时，会从用户态陷入到内核态，让内核帮我们切换线程，虽然简化了使用锁的难 度，但是存在一定的性能开销成本。 那这个开销成本是什么呢？会有两次线程上下文切换的成本： ·当线程加锁失败时，内核会把线程的状态从「运行」状态设置为「睡眠」状态，然后把CPU切换给其 他线程运行； ·接着，当锁被释放时，之前「睡眠」状态的线程会变为「就绪」状态，然后内核会在合适的时间，把 CPU 切换给该线程运行。\n读写锁 读写锁由两把锁组成，读锁和写锁。它的应用场景：能明确区分读操作和写操作，且读操作 多于 写操作。\n死锁 * 什么是死锁？比如当两个线程为了保护两个不同的共享资源而使用了两个互斥锁，那么这两个互斥锁应用不当的时候，可能会造成两个线程都在等待对方释放锁，在没有外力的作用下，这些线程会一直相互等待，就没办法继续运行，这种情况就是发生了死锁。\n死锁有四个必要条件\n互斥条件：多个线程不能同时使用同一个资源。 请求与保持条件：线程因请求资源而阻塞时，对已获得的资源保持不放 不剥夺条件：线程已获得的资源，在末使用完之前，不能强行剥夺 循环等待条件：多个线程之间形成一种头尾相接的循环等待资源的关系 如何破坏死锁？打破4个条件的其中一个就行，最常见的就是打破循环等待条件，核心就是理清资源的获取和释放顺序。\n","date":"2025-04-03T00:00:00Z","permalink":"https://sfw003.github.io/p/linux-thread/","title":"Linux 线程"},{"content":" 以下内容基于Qt 5.15 LTS 官方文档整理\nQt Core 提供多种容器类，满足不同的数据存储和操作需求。\n字符串 Qt中与字符的核心类\nQChar：存放文本数据 QByteArray：这个用来存放原始数据（图片、文件的二进制） QString： QString存储一串16 位QChar，其中每个QChar对应一个UTF-16 代码单元。（代码值大于65535的Unicode字符使用代理项对存储，即两个连续的QChar。\nUnicode是一种国际标准，支持当今使用的大多数书写系统。它是US-ASCIl（ANSIX3.4-1986）和Latin-1（IS08859-1）的超集，所有US- ASCll/Latin-1字符都可以在相同的代码位置使用。\n在幕后，QString 使用隐式共享（写时复制）来减少内存使用并避免不必要的数据复制。这也有助于减少存储16 位字符而不是8 位字符的固有开销。\n除了QString之外，Qt还提供了QByteArray类来存储原始字节和传统的8位以\\0\u0026rsquo;结尾的字符串。在大多数情况下，QString 是您要使用的类。它在整个QtAPI 中使用，如果您想在某个时候扩大应用程序的市场，Unicode支持可确保您的应用程序易于翻译。QByteArray适用的两种突出情况是需要存储原始二进制数据时，以及内存节省至关重要时（如在嵌入式系统中），\n初始化 初始化QString的一种方法是将const char *传递给其构造函数。例如，以下代码创建了一个包含数据 “Hello”、大小为 5 的QString：\n1 QString str = \u0026#34;Hello\u0026#34;; QString会使用fromUtf8()函数将const char * 数据转换为 Unicode。 在所有接受const char * 参数的QString函数中，const char * 被解释为经典的 C 风格以\u0026rsquo;\\0\u0026rsquo;结尾的字符串。除非函数名明确表明采用其他编码，否则这类const char *参数都假定为 UTF-8 编码。 你也可以将字符串数据作为QChar数组提供：\n可以将字符串数据作为QChar数组提供：\n1 2 static const QChar data[4] = { 0x0055, 0x006e, 0x10e3, 0x03a3 }; QString str(data, 4); QString会对QChar数据进行深拷贝，所以你之后修改原数据不会产生副作用。如果不想对字符数据进行深拷贝，可以使用QStringView或QString::fromRawData()。\n此时会采用原始数据，如果你仍然修改了数据，它在修改时自动创建副本（深拷贝）\n1 2 3 4 5 6 7 8 9 10 QRegularExpression pattern(\u0026#34;\\u00A4\u0026#34;); static const QChar unicode[] = { 0x005A, 0x007F, 0x00A4, 0x0060, 0x1009, 0x0020, 0x0020}; qsizetype size = sizeof(unicode) / sizeof(QChar); QString str = QString::fromRawData(unicode, size); if (str.contains(pattern) { // ... } 其他访问QString的数据，可以使用 operator和at()，这和c++的string使用方式一样。\nQString可以嵌入\u0026rsquo;\\0\u0026rsquo;字符（QChar::Null）。size()函数始终返回整个字符串的大小，包括嵌入的\u0026rsquo;\\0\u0026rsquo;字符。调用resize()函数后，新分配的字符具有未定义的值。要将字符串中的所有字符设置为特定值，可以使用fill()函数。\n你也可以将字符串字面量传递给接受QString作为参数的函数，这会调用QString(const char * )构造函数。类似地，你可以使用qPrintable()宏将QString传递给接受const char * 参数的函数，该宏会将给定的QString作为const char *返回，这等效于调用\u0026lt;QString\u0026gt;.toLocal8Bit().constData()。\n操作字符串数据 QString 提供了以下用于修改字符数据的基本函数：append()（追加）、prepend()（前置添加）、insert()（插入）、replace()（替换）和remove()（删除）等等 如果你逐步构建一个 QString，并且事先大致知道该 QString 会包含多少字符，可以调用reserve()函数，让 QString 预先分配一定量的内存。你还可以调用capacity()函数来查看 QString 实际分配了多少内存。 replace()和remove()函数的前两个参数分别是开始删除的位置和应删除的字符数。如果你想将某个子字符串的所有出现都替换为另一个子字符串，可以使用带有两个参数的replace()重载函数。\n一个常见的需求是从字符串中删除空白字符（如\u0026rsquo;\\n\u0026rsquo;、\u0026rsquo;\\t\u0026rsquo;、\u0026rsquo; \u0026lsquo;等）。如果你想删除 QString 两端的空白字符，可以使用trimmed()函数。如果你想删除两端的空白字符，并且将字符串中多个连续的空白字符替换为单个空格字符，可以使用simplified()函数。\n如果你想在 QString 中查找某个特定字符或子字符串的所有出现位置，可以使用indexOf()或lastIndexOf()函数。前者从给定的索引位置开始向前搜索，后者向后搜索。如果找到字符或子字符串，这两个函数都会返回其索引位置；否则，返回 -1。例如，下面是一个典型的循环，用于查找某个特定子字符串的所有出现位置：\n1 2 3 4 5 6 QString str = \u0026#34;We must be \u0026lt;b\u0026gt;bold\u0026lt;/b\u0026gt;, very \u0026lt;b\u0026gt;bold\u0026lt;/b\u0026gt;\u0026#34;; int j = 0; while ((j = str.indexOf(\u0026#34;\u0026lt;b\u0026gt;\u0026#34;, j)) != -1) { qDebug() \u0026lt;\u0026lt; \u0026#34;Found \u0026lt;b\u0026gt; tag at index position\u0026#34; \u0026lt;\u0026lt; j; ++j; } QString 提供了许多用于将数字转换为字符串以及将字符串转换为数字的函数。例如arg()函数、setNum()函数、number()静态函数，以及toInt()、toDouble()等类似函数。 要获取字符串的大写或小写版本，可以使用toUpper()或toLower()函数。 字符串列表由QStringList类处理。你可以使用split()函数将一个字符串拆分为字符串列表，并使用QStringList::join()函数通过一个可选的分隔符将字符串列表合并为一个字符串。你还可以使用QStringList::filter()函数从字符串列表中获取包含特定子字符串或匹配特定QRegExp（正则表达式）的字符串列表。\n查询字符串数据 如果你想查看一个QString是否以某个特定子字符串开头或结尾，可以使用startsWith()或endsWith()函数。如果你只是想检查一个QString是否包含某个特定字符或子字符串，可以使用contains()函数。如果你想知道某个特定字符或子字符串在字符串中出现的次数，可以使用count()函数。\n要获取指向实际字符数据的指针，可以调用data()或constData()函数。这些函数返回一个指向QChar数据开头的指针。在对QString调用非const函数之前，该指针保证有效。\n比较字符串 QStrings可以使用诸如operator\u0026lt;()、operator\u0026lt;=()、operator==()、operator\u0026gt;=()等重载运算符进行比较。请注意，这种比较完全基于字符的数字Unicode值。它速度非常快，但不符合人类的预期；在可用的情况下，QString::localeAwareCompare()函数通常是对用户界面字符串进行排序的更好选择。\n在类Unix平台（包括Linux、macOS和iOS）上，当Qt与ICU库链接时（通常是这样），会使用其区域设置感知排序。否则，在macOS和iOS上，localeAwareCompare()会根据“国际”偏好面板中的“排序列表顺序”设置进行比较。在没有ICU的其他类Unix系统上，比较会回退到系统库的strcoll()函数，当strcoll()认为字符串相等时，再回退到QString的（不区分区域设置的）比较，如上文所述。\n在8位字符串和Unicode字符串之间转换 QString提供了以下三个函数，用于将字符串以QByteArray的形式返回为const char *版本：toUtf8()、toLatin1()和toLocal8Bit()。\ntoLatin1()返回一个Latin - 1（ISO 8859 - 1）编码的8位字符串。 toUtf8()返回一个UTF - 8编码的8位字符串。UTF - 8是US - ASCII（ANSI X3.4 - 1986）的超集，通过多字节序列支持整个Unicode字符集。 toLocal8Bit()返回一个使用系统本地编码的8位字符串。 为了从这些编码之一进行转换，QString提供了fromLatin1()、fromUtf8()和fromLocal8Bit()函数。其他编码可通过QTextCodec类支持。\n如上文所述，QString提供了许多函数和运算符，使其与const char *字符串的互操作变得容易。但这种功能是一把双刃剑：如果所有字符串都是US - ASCII或Latin - 1，它会使QString使用起来更方便，但始终存在从const char *进行隐式转换或转换为const char *时使用错误的8位编码的风险。为了最小化这些风险，你可以通过定义以下一些预处理器符号来关闭这些隐式转换：\nQT_NO_CAST_FROM_ASCII禁用从C字符串字面量和指针到Unicode的自动转换。 QT_RESTRICTED_CAST_FROM_ASCII允许从C字符和字符数组进行自动转换，但禁用从字符指针到Unicode的自动转换。 QT_NO_CAST_TO_ASCII禁用从QString到C字符串的自动转换。 然后，你需要显式调用fromUtf8()、fromLatin1()或fromLocal8Bit()从8位字符串构造QString，或者使用轻量级的QLatin1String类，例如：\n1 QString url = QLatin1String(\u0026#34;http://www.unicode.org/\u0026#34;); 同样，你必须显式调用toLatin1()、toUtf8()或toLocal8Bit()将QString转换为8位字符串。（其他编码可通过QTextCodec类支持。）\n给C程序员的注意事项 由于C++的类型系统以及QString是隐式共享的这一事实，QStrings可能会被当作int或其他基本类型来对待。例如：\n1 2 3 4 5 6 7 8 9 QString Widget::boolToString(bool b) { QString result; if (b) result = \u0026#34;True\u0026#34;; else result = \u0026#34;False\u0026#34;; return result; } result变量是一个在栈上分配的普通变量。当调用return时，由于我们是按值返回，复制构造函数会被调用并返回字符串的一个副本。由于隐式共享，实际上并不会发生复制。\n空字符串和NULL字符串的区别 由于历史原因，QString区分空字符串和NULL字符串。NULL字符串是使用QString的默认构造函数或通过将(const char *)0传递给构造函数初始化的字符串。空字符串是任何长度为0的字符串。NULL字符串总是空的，但空字符串不一定是NULL：\n1 2 3 4 5 6 QString().isNull(); // 返回true QString().isEmpty(); // 返回true QString(\u0026#34;\u0026#34;).isNull(); // 返回false QString(\u0026#34;\u0026#34;).isEmpty(); // 返回true QString(\u0026#34;abc\u0026#34;).isNull(); // 返回false QString(\u0026#34;abc\u0026#34;).isEmpty(); // 返回false 除了isNull()函数外，所有函数都将NULL字符串与空字符串同等对待。例如，toUtf8().constData()会为NULL字符串返回一个指向'\\0'字符的有效指针（不是nullptr ）。我们建议始终使用isEmpty()函数并避免使用isNull()。\n参数格式 在可以指定参数格式的成员函数（例如arg()、number() ）中，参数格式可以是以下之一：\n格式 含义 e 格式化为`[-]9.9e[+ E 格式化为`[-]9.9E[+ f 格式化为[-]9.9 g 使用e或f格式，以更简洁者为准 G 使用E或f格式，以更简洁者为准 参数格式中还会指定精度。对于'e'、'E'和'f'格式，精度表示小数点后的位数。对于'g'和'G'格式，精度表示最大有效位数（省略尾随零）。\n更高效的字符串构建 许多字符串在编译时就已知。但是，简单的构造函数QString(\u0026quot;Hello\u0026quot;)会将字符串内容视为Latin - 1并进行复制。为避免这种情况，可以使用QStringLiteral宏在编译时直接创建所需的数据。这样，从字面量构造QString在运行时不会产生任何开销。\n一种效率稍低的方法是使用QLatin1String。这个类包装一个C字符串字面量，在编译时预先计算其长度，因此与普通C字符串字面量相比，它可以更快地与QStrings进行比较并转换为QStrings。\n使用QString的+运算符，可以轻松地从多个子字符串构造一个复杂的字符串。你可能经常编写这样的代码：\n1 2 3 4 5 QString foo; QString type = \u0026#34;long\u0026#34;; foo-\u0026gt;setText(QLatin1String(\u0026#34;vector\u0026lt;\u0026#34;) + type + QLatin1String(\u0026#34;\u0026gt;::iterator\u0026#34;)); if (foo.startsWith(\u0026#34;(\u0026#34; + type + \u0026#34;) 0x\u0026#34;)) // ... 这些字符串构造方式本身没有问题，但存在一些隐藏的低效之处。从Qt 4.6开始，可以消除这些问题。\n首先，多次使用+运算符通常意味着多次内存分配。当连接n个子字符串（n \u0026gt; 2）时，可能会调用多达n - 1次内存分配器。\n在Qt 4.6中，添加了一个内部模板类QStringBuilder以及一些辅助函数。这个类被标记为内部类，不会出现在文档中，因为不应该在代码中实例化它。它的使用是自动的，如下所述。如果你想查看它，可以在src/corelib/tools/qstringbuilder.cpp中找到这个类。\nQStringBuilder使用表达式模板并重新实现了%运算符，因此当使用%而不是+进行字符串连接时，多个子字符串的连接将被推迟，直到最终结果即将分配给QString。此时，已知最终结果所需的内存量。然后调用一次内存分配器来获取所需的空间，并将子字符串逐个复制到其中。\n通过内联和减少引用计数（从QStringBuilder创建的QString通常引用计数为1，而QString::append()需要额外的测试），可以进一步提高效率。\n有两种方法可以使用这种改进的字符串构建方法。一种直接的方法是在需要使用的地方包含QStringBuilder，并在连接字符串时使用%运算符而不是+运算符：\n1 2 3 4 5 6 #include \u0026lt;QStringBuilder\u0026gt; QString hello(\u0026#34;hello\u0026#34;); QStringRef el(\u0026amp;hello, 2, 3); QLatin1String world(\u0026#34;world\u0026#34;); QString message = hello % el % world % QChar(\u0026#39;!\u0026#39;); QStringBuilder类则通过表达式模板和重新实现%操作符来解决这一问题。它推迟子字符串的拼接，直到确定最终结果所需内存量后，再一次性分配内存并完成拼接，同时通过内联和减少引用计数进一步提升效率。\n另一种更全局的方法，也是最方便但并非完全源兼容的方法，是在.pro文件中进行如下定义：\n1 DEFINES *= QT_USE_QSTRINGBUILDER 这样，+操作符在任何地方都会自动像QStringBuilder的%操作符一样工作。\n如果采用cmake来管理的话则添加\n1 2 启用 QStringBuilder 优化 target_compile_definitions(my_app PRIVATE QT_USE_QSTRINGBUILDER) 字符串编码问题 在使用vs运行qt程序遇到这样的问题\n1 2 3 // vs2019 界面显示为乱码 // vs2022 直接在编译时报错：常量中有换行符 ui-\u0026gt;label-\u0026gt;setText(\u0026#34;森林是否是发顺丰砍伐\u0026#34;); 问题的根源：纯文本文件却不会记录自己采用的编码 比如我采用UTF8编码保存文件，用某软件打开时，并不知道该用什么编码方式去打开，只能靠猜。 以 GBK 编码文件在不同软件中的表现为例：\nLinux 下的 gedit： 默认仅支持 UTF-8，打开 GBK 文件会显示乱码。需通过修改 gedit 配置，将 GBK 添加到自动检测列表。\nWindows 记事本： 会优先尝试 UTF-8，失败后回退到本地编码（GBK），但此行为不稳定，可能误判为其他编码（如 ISO-8859-1）\n疑问：那如果我采用 UTF8 with BOM 呢？ BOM文件确实会通过文件头 EF BB BF 隐式声明编码，但此方式不被所有系统兼容。 VS编译器可以识别BOM文件，但是即使知道文件的编码方式，依然有问题。\n1 2 3 4 5 6 // 文件编码：UTF-8 with BOM const char* str = \u0026#34;我是汉字\u0026#34;; // 实际链路： // 1. 编译器按 UTF-8 解析源码 → \u0026#34;我是汉字\u0026#34; 的 UTF-8 字节为 [0xE6...] // 2. 编译器将字符串隐式转码为本地编码（GBK）→ 字节变为 [0xCE, 0xD2...] // 结果：str 的内容是 GBK 编码，而非 UTF-8 字符串常量会经过2次解析，原因在于 cl.exe 的 /execution-charset 默认值为本地代码页（如 GBK），导致 char* 字符串最终被转码为 GBK。\nGBK编码下的 const char * str = \u0026ldquo;我是汉字\u0026rdquo; 等价于 const char * str = \u0026ldquo;\\xce\\xd2\\xca\\xc7\\xba\\xba\\xd7\\xd6\u0026rdquo;;\n前文提到，QString 默认选择Latin-1，\\xce\\xd2\\xca\\xc7\\xba\\xba\\xd7\\xd6则会被当作Latin-1编码，再转为unicode，所以最后显示为乱码。\n解决方式：核心是要告诉 QString 你的str是何种编码\n场景：UTF-8 with BOM文件，之前出错的原因是因为字符串常量会经过2次解析，我们可以使用QStringLiteral 跳过第2次解析。（这个适合静态字符串，即已经确定字符串的内容） 如果文件为UTF-8编码，没有BOM，上面操作则会出问题，因为没有bom，编译器不知道文件的编码方式，只能采用默认的。因此为了统一，可以开启vs编译器的 /utf8选项，此时编译器会默认采用utf-8来解码。 如果需要动态转换，参考在8位字符串和Unicode字符串之间转换章节\n其他 QList， QVector， QMap等等，这些去看一下成员函数，就知道如何使用了。\nQVariant Qt 的容器类，我个人认为最重点的就是QString和QVariant。\nQVariant类类似于C++的联合（union）数据类型，它不仅能够保存很多Qt类型的值，包括QColor、QBrush、QFont、QPen、QRect、QString和QSize等，也能够存放Qt的容器类型的值。Qt的很多功能都是建立在QVariant基础上的，如Qt的对象属性及数据库功能等。\n之后再写\n","date":"2025-04-02T00:00:00Z","permalink":"https://sfw003.github.io/p/qt-core_02_container_and_algorithm/","title":"【Qt Core 02】容器类和算法"},{"content":" 以下内容基于Qt 5.15 LTS 官方文档整理\n事件驱动 事件：事件是用户和应用软件间产生的一个交互操作，由用户操作产生或者系统内部产生，通过事件循环对事件进行处理，事件也可以用来在对象间进行信息交互。 事件驱动架构(Event-Driven Architecture)是一种用于设计应用的软件架构和模型，程序的执行流由外部事件来决定 事件队列(event queue)：接收事件的入口，存储待处理事件 分发器(event mediator)：将不同的事件分发到不同的业务逻辑单元 事件通道(event channel)：分发器与处理器之间的联系渠道 事件处理器(event processor)：实现业务逻辑，处理完成后会发出事件，触发下一步操作 事件驱动模型的特点:\n可维护性高：事件驱动模型使得应用程序的代码结构更加清晰，并且易于维护和调试。每个事件都有相应的处理函数，使得代码更加模块化 可扩展性强：采用事件驱动模型可以方便地添加新的事件处理函数，并且可以轻松地扩展应用程序的功能。 并发性好：事件驱动模型可以方便管理多个事件，并且可以在处理事件时执行异步操作,使得应用程序具有更好的并发性 可移植性好：采用事件驱动模型可以使应用程序更容易地在不同的操作系统和平台上移植，从而提高了应用程序的可移植性。 Qt事件框架 用户操作与 GUI 应用程序交互之后,系统内核获取用户动作，产生 OS 消息 系统内核会将 OS 消息传递给 Qt 事件处理框架,会转换 事件对象 QEvent,并讲转换后的事件发送给QObject。 QObject 调用 QObject::event 函数来接收事件，并分发，默认是在当前调用该事件的组件对象接收，若是该组件对象不做任何操作，则可以转给它的父对象来接收。最后会按照事件类型来调用不同的事件处理函数 调用 事件处理函数,在事件处理函数中可进行信号的发送 调用 槽函数(信号需要与槽函数进行关联) 自定义事件处理 Qt 用户自定义处理事件方式\n按照 Qt 事件处理流程,用户自定义处理事件方式如下:\n重写特定事件函数mousePressEvent()，keyPressEvent()，paintEvent() 重写实现 Q0bject::event0 安装事件过滤器 在 QApplication 上安装事件过滤器 重新实现 QApplication 的 notify()方法 在实际应用的过程中,采用 重写特定事件函数 和 安装事件过滤器 的方式居多 其实还有一种方式：自定义事件（继承 QEvent 并发送） 原理：应用程序可通过QCoreApplication::sendEvent()和QCoreApplication::postEvent()发送自定义事件。sendEvent()会立即处理事件，返回时事件已被处理；postEvent()将事件放入队列，在 Qt 主事件循环下次运行时进行调度，且会对一些事件（如多个resize事件、paint事件）进行优化。在对象初始化期间常使用postEvent()，因为对象初始化完成后事件通常会很快被调度。创建自定义事件时，需定义大于QEvent::User的事件编号，可能还需子类化QEvent来传递特定信息。\n重写特定事件函数 重写特定事件函数是最常用的自定义事件处理方式，下面是案例\n1 2 3 4 5 6 7 8 void CustomButton::mousePressEvent(QMouseEvent* e) { // 自定义处理 if (event-\u0026gt;button() == Qt::LeftButton) { // handle left mouse button here } return QPushButton::mousePressEvent(e);// 调用父类的 mousePressEvent 函数 } 这里有1点注意：在结束时需要调用父类的事件处理函数，如果是故意不写，也应该加上注释\n如果不加，会导致事件传播链中断： Qt 的事件处理机制中，若子类重写事件函数后未调用父类实现，相当于隐式调用了 event-\u0026gt;accept()，事件将停止传播。这可能导致父组件或上层逻辑无法响应事件。 示例：若按钮被放置在父窗口的特定区域，父窗口可能依赖于事件传播实现拖拽等功能，但事件被截断后这些功能将失效。\nqt的事件忽略\n1 2 void QEvent::ignore() // 表示当前对象忽略事件，该事件会继续传递给父对象 void QEvent::accept() // 表示事件在当前对象中已经处理，不会继续传递到父对象 Qt的事件过滤器 Qt事件过滤器是一种机制，用于在Qt应用程序中拦截、处理和转发事件。 事件过滤器的作用是在 目标对象接收事件之前，对事件进行拦截和处理。 通过安装事件过滤器，可以对目标对象的事件进行修改、过滤、转发或者记录，这样可以很方便地实现一些自定义的功能。 事件过滤器的优点是可以在不修改目标对象的代码的情况下，对其进行功能扩充 事件过滤器的使用\n给目标对象安装过滤器,这里调用 installEventFilter 函数 1 ui-\u0026gt;textEdit-\u0026gt;installEventFilter(this); // 在父窗口中监控textEdit的事件[1](@ref) 在事件过滤器对象中实现事件过滤器逻辑，这里需要重写 eventFilter 函数 1 2 3 4 5 6 7 8 9 10 11 12 bool Widget::eventFilter(QObject *obj, QEvent *event) { if (obj == ui-\u0026gt;textEdit) { if (event-\u0026gt;type() == QEvent::Wheel) { // 拦截滚轮事件，阻止传递 return true; } } // 其他事件交给默认处理 return QWidget::eventFilter(obj, event); } //return true：事件被拦截，不再传递给目标对象。 //return false：事件继续传递至目标对象或其父类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 自定义过滤器类 class KeyMouseFilter : public QObject { protected: bool eventFilter(QObject *obj, QEvent *event) override { if (event-\u0026gt;type() == QEvent::KeyPress) { QKeyEvent *keyEvent = static_cast\u0026lt;QKeyEvent*\u0026gt;(event); qDebug() \u0026lt;\u0026lt; \u0026#34;Key pressed:\u0026#34; \u0026lt;\u0026lt; keyEvent-\u0026gt;key(); return true; // 拦截按键 } else if (event-\u0026gt;type() == QEvent::MouseButtonPress) { qDebug() \u0026lt;\u0026lt; \u0026#34;Mouse clicked on\u0026#34; \u0026lt;\u0026lt; obj-\u0026gt;objectName(); } return false; } }; // 安装到控件 KeyMouseFilter *filter = new KeyMouseFilter; ui-\u0026gt;lineEdit-\u0026gt;installEventFilter(filter); ","date":"2025-04-02T00:00:00Z","permalink":"https://sfw003.github.io/p/qt-core_03_event_mechanism/","title":"【Qt Core 03】事件机制"},{"content":"准备 编码：vscode debug: vs2019 + Qt vs Tools 插件 c++包管理工具：vcpkg 项目构建：cmake\n安装好上述工具后。\n第一步：安装Qt5 库 使用vcpkg\n1 PS D:\\cppsoft\\vcpkg\u0026gt; .\\vcpkg.exe install qt5 第二步：编写CMakeLists.txt 项目结构：\n1 2 3 4 5 6 7 8 9 10 11 12 13 PS D:\\MyProject\\qt-code\\Qt5Demo\u0026gt; tree /F 卷 系统文件 的文件夹 PATH 列表 卷序列号为 67C3-157C D:. │ CMakeLists.txt │ main.cpp │ mainwindow.cpp │ mainwindow.h │ mainwindow.ui │ resource.qrc │ └─resource └─image 参考下面的案例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 cmake_minimum_required(VERSION 3.10) #cmake版本最低3.10 # 设置CMAKE工具链 set(CMAKE_TOOLCHAIN_FILE \u0026#34;D:/cppsoft/vcpkg/scripts/buildsystems/vcpkg.cmake\u0026#34;) # 获取当前子CMake文件所在目录的完整路径 get_filename_component(CURRENT_DIR_PATH \u0026#34;${CMAKE_CURRENT_LIST_DIR}\u0026#34; ABSOLUTE) # 从完整路径中提取目录名称 get_filename_component(CURRENT_DIR_NAME \u0026#34;${CURRENT_DIR_PATH}\u0026#34; NAME) # 设置项目名称 project(${CURRENT_DIR_NAME}) set(CMAKE_CXX_STANDARD 11) if(MSVC) add_compile_options(/Zc:__cplusplus) endif() # 自动包含当前目录 SET(CMAKE_INCLUDE_CURRENT_DIR ON) # 自动生成moc文件 SET(CMAKE_AUTOMOC ON) # 自动生成rcc文件 SET(CMAKE_AUTORCC ON) # 自动生成uic文件 SET(CMAKE_AUTOUIC ON) # 查找Qt5库 find_package(Qt5 COMPONENTS Core Widgets Gui REQUIRED) file(GLOB UI_FILES \u0026#34;${CMAKE_CURRENT_SOURCE_DIR}/*.ui\u0026#34;) file(GLOB RCC_FILES \u0026#34;${CMAKE_CURRENT_SOURCE_DIR}/*qrc\u0026#34;) file(GLOB HEADER_FILES \u0026#34;${CMAKE_CURRENT_SOURCE_DIR}/*.h\u0026#34; \u0026#34;${CMAKE_CURRENT_BINARY_DIR}/*.h\u0026#34;) file(GLOB CPP_FILES \u0026#34;${CMAKE_CURRENT_SOURCE_DIR}/*.cpp\u0026#34;) qt5_wrap_ui(UI_HEADERS ${UI_FILES}) source_group(\u0026#34;Form Files\u0026#34; FILES ${UI_FILES}) source_group(\u0026#34;Resource Files\u0026#34; FILES ${RCC_FILES}) # win32表示关闭控制台窗口 add_executable(${PROJECT_NAME} WIN32 ${HEADER_FILES} ${CPP_FILES} ${UI_FILES} ${RCC_FILES}) # 链接库 target_link_libraries(${PROJECT_NAME} Qt5::Widgets Qt5::Core Qt5::Gui ) 第三步：编写批处理文件 编写好CMakeLists.txt后可以使用cmake构建，但为了更方便控制，我们可以再编写一个批处理文件来运行cmake命令 案例：这里call后需要改为你的vs2019的vcvarsamd64_x86.bat路径\n1 2 3 4 5 6 mkdir build cd build call \u0026#34;C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Auxiliary\\Build\\vcvarsamd64_x86.bat\u0026#34; cmake -G \u0026#34;Visual Studio 16 2019\u0026#34; -A x64 -DCMAKE_BUILD_TYPE=Debug .. cd ../ pause 运行批处理文件后，便可以再build目录下找到 .sln （vs工程） 这里打开后可能还需要将项目设置为启动项。 到这里一个Qt 工程就创建好了。\n其他 配置Qt VS Tools 再vs2019扩展商店里搜索Qt，下载下面这个插件（如果没有魔法，连不上扩展商店，找其他方式下载） 点击Qt VS Tools的options 将这些选项设为true（如果你之后不想使用Qt Designer也可以不使用） 此时便可以使用Qt Designer打开 .ui 文件 （如果打开失败，原因估计是找不到Qt Desinger，右键 \u0026ndash;\u0026gt; 打开方式，自己配置一个Qt Desinger，这里是Qt Desinger需要自己去官网或其他地方下载） qt 源码调试配置 在开发过程中，如果想通过断点进入到 qt 源码中，我们可以配置pdb文件。\nPDB文件（Program Database File）是Microsoft Visual Studio编译生成的调试信息文件，主要用于存储程序的符号信息（如函数名、变量名、行号等），使调试器能将机器代码与源代码对应，从而辅助开发人员定位问题。\n右键点击vs 2019 解决方案 进入属性中,添加相应的源码路径\n然后设置pdb文件，pdb文件需要使用Debug编译生成。由于我们使用vcpkg安装了qt5，它已经生成了pdb文件\n路径：D:\\cppsoft\\vcpkg\\installed\\x64-windows\\debug\\bin 点击工具 \u0026ndash;\u0026gt; 选项 \u0026ndash;\u0026gt; 调试 \u0026mdash;\u0026gt; 符号\n到这里就可以通过断点进入源码。\n疑问 初始的.ui, .qrc文件如何生成？ Qt Creator 左上角新建 .ui文件，qrc同理使用 Qt Resource Editor\n当然可以自己手动编写ui文件\n","date":"2025-04-02T00:00:00Z","permalink":"https://sfw003.github.io/p/qt-env-setup-01/","title":"【Qt 环境搭建 01】cmake搭建Qt VS2019开发环境"},{"content":"设置github action 远程新建发布仓库，命名为：username.github.io。这里的username是github的用户名，必须保持一致！\n配置hugo.yaml\n1 baseurl: https://sfw003.github.io ","date":"2025-04-02T00:00:00Z","permalink":"https://sfw003.github.io/p/blog_hugo-series_part1/","title":"Hugo建站教程"},{"content":"one thread one loop reactor-server\n","date":"2025-04-02T00:00:00Z","permalink":"https://sfw003.github.io/p/one-thread-one-loop-reactor-server/","title":"one thread one loop reactor-server"},{"content":"传输层 端口号 端口的由来：\n在操作系统中，不同的进程是通过进程标识符(pid)进行区分。不同的操作系统使用的pid的格式不尽相同，但在网络里我们需要采用统一的格式进行区分。因此端口号诞生了。它采用统一的格式来标识进程。\n端口号的格式：TCP/IP： 16bit位的正整数\nc++：uint16_t\n在TCP/IP协议中, 用 \u0026ldquo;源IP\u0026rdquo;, \u0026ldquo;源端口号\u0026rdquo;, \u0026ldquo;目的IP\u0026rdquo;, \u0026ldquo;目的端口号\u0026rdquo;, \u0026ldquo;协议号\u0026rdquo; 这样一个五元组来标识一个通信。\n端口的分类 服务端使用的端口号\n熟知端口号: 里面一些端口固定绑定某些应用程序：1-1023\n应用程序 HTTP SSH FTP 端口号 80 22 21 登记端口号：\n客户端端口号：49152-65535，客户端运行时，操作系统动态绑定，通信时自动绑定，通信结束自动回收\n端口号的理解 传输层的协议由TCP/UDP，这里2个协议能公用一个端口号？可以\n首先我们要理解端口号对于传输层的作用：区分同一个主机上不同应用程序的数据包\n当主机收到一个IP数据包，根据IP数据包里的协议号分辨是TCP还是UDP，然后根据这一信息，交给系统中的TCP或UDP模块进行处理，然后TCP或UDP模块再端口号转发给对应的应用程序。\nUDP(user datagram protocol) 用户数据报协议\nUDP特点： 无连接 不可靠，尽最大努力交付，因此数据可能丢失、乱序 面向数据报，每次读取都是完整的报文，且发多少个数据报，就要收到多少个数据报 UDP没有拥塞控制，因此网络拥塞不会降低发送速率 UDP支持一对一，一对多，多对一和多对多通信 UDP首部开销小：8字节 UDP是全双工 UDP缓存区 UDP没有真正意义上的 发送缓冲区. 调用sendto会直接交给内核, 由内核将数据传给网络层协议进行后 续的传输动作;\nUDP具有接收缓冲区. 但是这个接收缓冲区不能保证收到的UDP报的顺序和发送UDP报的顺序一致; 如果 缓冲区满了, 再到达的UDP数据就会被丢弃，而且也不会通知你。\nUDP格式 源端口号（选用）：在需要对方回信时选用，不需要则全0 目的端口号：终点交付报文时必用 长度：整个报文长度(大小), 最小为8字节 校验：检查报文传输中是否损坏 如果我们需要传输的数据超过64K, 2^16bit, 则需要手动拆解数据。\nUDP的应用场景 NFS: 网络文件系统\nTFTP: 简单文件传输协议\nDHCP: 动态主机配置协议\nBOOTP: 启动协议(用于无盘设备启动)\nDNS: 域名解析协议\n直播，视频\nUDP的使用 在Linux系统中，对UDP头部的定义\n1 2 3 4 5 6 struct udphdr { __be16 source; /* 源端口 */ __be16 dest; /* 目标端口 */ __be16 len; /* UDP数据包长度 */ __sum16 check; /* 校验和 */ }; 对UDP的缓存区的定义\n1 2 3 4 5 6 7 8 9 10 11 12 struct sk_buff { struct sk_buff *next; /* 下一个缓冲区 */ struct sk_buff *prev; /* 上一个缓冲区 */ struct sk_buff_head *list; /* 缓冲区链表 */ struct sock *sk; /* 相关的套接字 */ unsigned char *data; /* 数据指针 */ unsigned int len; /* 数据长度 */ unsigned int data_len; /* 数据部分长度 */ unsigned int truesize; /* 真实大小 */ struct udphdr *udp; /* UDP头指针 */ /* 其他成员 */ }; TCP(Transmission Control Protocol) 传输控制协议\nTCP的特点 基于连接 可靠交付（无差错，不丢失，不重复） 面向字节流 全双工 一对一通信 TCP的格式 TCP的数据我们称为数据段（报文段）\n注：同一份数据，在传输层称为数据段，网络层称为数据包，数据链路层称为数据帧\n源/目的端口号: 表示数据是从哪个进程来, 到哪个进程去;\n32位序号/32位确认号: 保障有序性\n4位TCP报头长度: 表示该TCP头部有多少个32位bit(有多少个4字节); 所以TCP头部最大长度是15 * 4 = 60\n6位标志位:TCP报文是有类型的，比如一个TCP报文可能是通信报文，也可以是建立连接的报文，也可以是关闭连接的报文，因此需要用标志来区分。\n​\tURG: 紧急指针是否有效\n​\tACK: 确认号是否有效，当该报文是应答类型的报文，该标志置1\n​\tPSH: 提示接收端应用程序立刻从TCP缓冲区把数据读走\n​\tRST: 对方要求重新建立连接; 我们把携带RST标识的称为复位报文段\n​\tSYN: 请求建立连接; 我们把携带SYN标识的称为同步报文段\n​\tFIN: 通知对方, 本端要关闭了 , 我们称携带FIN标识的为结束报文段\n16位窗口大小: 16位窗口大小最大为2^16-1 = 65532 字节 16位校验和: 发送端填充, CRC校验. 接收端校验不通过, 则认为数据有问题. 此处的检验和不光包含TCP首部, 也包含TCP数据部分. 16位紧急指针: 标识哪部分数据是紧急数据。只有当URG标志为1，才有效。紧急指针的本质是紧急数据在TCP报文里的偏移量。 40字节头部选项: 暂时忽略; TCP的连接管理 TCP建立连接，需要进行3次握手和4次挥手\n3次握手和4次挥手 为什么是3次握手？1次，2次为什么不行？ 3次握手的目的：确认双方的通信能力和可达性，同步双方的序列号\n​\t第一次：客户端发送报文给服务器，服务器接受到报文：服务器知道客户端发送能力正常\n​\t第二次：服务器做出应答，客户端接受到报文：客户端知道服务器的接受和发送能力正常\n​\t第三次：客户端做出应答，服务器接受到报文：服务器知道客户端的接受能力正常\n但是这个回答是比较片面的，RFC 793：首要原因是为了防止旧的重复连接初始化造成混乱。\n例：在网络拥堵情况下，客户端连续发送多次SYN建立连接的报文，3次握手可以防止历史连接的干扰。如下图：\n2次握手为什么解决不了上面的情况，原因在于：服务端没有中间状态（SYN RCVD）给客户端来阻止历史连接。 2次握手下，服务器收到SYN，就会进入ESTABUSHED.\n4次挥手能合成为3次挥手？ 问题：为什么要4次挥手，第2次挥手和第3次挥手为什么不能采用捎带应答的方式合成一次？\n答：服务器收到FIN后，会发送ACK，进入CLOSE_WAIT，CLOSE_WAIT会处理一些未来得及处理的数据，处理完成后，再发送FIN. 如果缓冲区本身没有数据需要处理，那么可以将第2次和第3次合为捎带应答 ==\u0026gt; FIN + ACK\n因此4次挥手可以合成为3次挥手\nTCP的可靠传输 TCP核心是可靠传输，而可靠传输体现在3个方面：无差错，无丢失，无重复\n无差错：16位校验号\n无丢失：自动重传机制（ARQ）, 超时重传机制（Retransmission Timeout)，滑动窗口\n无重复：序列号、确认号、确认应答机制\n下面一个一个介绍：\n确认应答(ACK)机制 要想确定一个报文是否有效，需要对方做出应答。但应答的有效性无法验证（验证应答的有效性会陷入循环），因此我们规定不用对 应答 做出 应答。对方发出应答就默认我收到了应答。\n捎带应答：多数情况下，单纯发出应答效率不高，而且根据规定，对方发出应答就默认我收到了应答。因此为了提高效率，对方发出的报文 = 应答 + 数据。\n序列号（Sequence number） TCP通信时，并不是发一个，应答一个。这样效率低下。而是一次发多个数据，发送多个数据存在乱序问题，而乱序是不可靠的一种。\nTCP保证有序是通过序列号来实现（TCP报文里的32位序号）。每个报文都带有序号，对方收到多个报文，会根据序号进行排序。如何理解这个序号？\nTCP是面向字节流的，因此我们可以抽象的认为TCP的缓存区是一个 char类型的数组，数组的元素天然带有一个编号（数组下标）\nTCP 报文头中的 32 位序号字段用于标识 TCP 连接中每个数据包的顺序。**这个序号表示了数据包中的第一个字节在整个数据流中的位置。**序号的增长是根据发送的数据量而定的，每发送一个字节，序号就增加一个。这样，接收端就可以根据序号来确定接收到的数据包的顺序，并进行重组。\n如果发送方发送了第一个TCP段，包含100字节数据，且这个TCP段的序列号为1000。 接下来发送第二个TCP段时，它的序列号将是1100（1000 + 100），因为第一个段包含了100个字节。 初始的序列号如何生成？\n起始ISN是基于时钟的，每4微秒+1，转一圈要4.55个小时。 RFC793提到\n​\t初始化序列号ISN随机生成算法：ISN = M + F(localhost,localport,remotehost,remoteport)。\nM是一个计时器，这个计时器每隔4微秒加1。\nF是一个Hash 算法，根据源IP、目的IP、源端口、目的端口生成一个随机数值。要保证 Hash 算法不能被外部轻易推算得出，用MD5算法是一个比较好的选择。 可以看到，随机数是会基于时钟计时器递增的，基本不可能会随机成一样的初始化序列号。\n确认号 接受方收到一个序列号为N报文后，需要应答。该应答需要告诉对方，自己接受到了序号为N，因此要返回一个序号为M确认序号，**规定：确认序号 = 最后一个已成功接收的数据字节的序列号 + 1， 即 M = N+1 **。通知发送方可以从M处开始发数据了。\n当发送方收到序号为M的应答后，规定：发送方可以认为小于序号M的所有报文，接受方全部收到。这样，我们可以允许少量应答丢失。\n那为什么一个报文同时带有确认号和序列号？确认号 \u0026ndash; 应答， 序列号 \u0026ndash; 数据，由于存在捎带应答的情况，一个报文即是应答又是数据，因此需要同时带上确认号和序列号。\n流量控制 接收端处理数据的速度是有限的. 如果发送端发的太快, 导致接收端的缓冲区被打满, 这个时候如果发送端继续发送,就会造成丢包, 继而引起丢包重传等等一系列连锁反应. 因此TCP支持根据接收端的处理能力, 来决定发送端的发送速度. 这个机制就叫做流量控制(Flow Control);\n流量控制是通过接收端抑制发送端发送数据的速率，以使接收端来得及接收。是点对点通信量的控制，是个端到端的问题。\n流量控制的手段：滑动窗口\n接收端将自己可以接收的缓冲区大小放入 TCP 首部中的 \u0026ldquo;窗口大小\u0026rdquo; 字段, 通过ACK端通知发送端;\n窗口大小字段越大, 说明网络的吞吐量越高;\n接收端一旦发现自己的缓冲区快满了, 就会将窗口大小设置成一个更小的值通知给发送端;\n发送端接受到这个窗口之后, 就会减慢自己的发送速度;\n如果接收端缓冲区满了, 就会将窗口置为0; 这时发送方不再发送数据, 但是需要定期发送一个窗口探测数据段, 使接收端把窗口大小告诉发送端.\n滑动窗口\n刚才我们讨论了确认应答策略, 对每一个发送的数据段, 都要给一个ACK确认应答. 收到ACK后再发送下一个数据段.\n这样做有一个比较大的缺点, 就是性能较差. 尤其是数据往返的时间较长的时候。因此为了提高效率，我们需要一次发送多段报文，而TCP使用滑动窗口来管理多段数据的发送。\n窗口越大, 网络吞吐量就越大, 传输效率就越高.\n问题：滑动窗口在哪里？发送缓存区的一部分\n滑动窗口将发送缓存区分为了3部分：\n具体如下：\n滑动窗口如何解决丢包问题？\nACK丢了 根据确认序号的定义：该序号之前的数据已经全部接受。\n因此少量的丢包不会影响。\n数据包丢了\n现在：发送方：1000 2000 3000 4000 其中2000丢了 接受方没有接受到2000，但接受到了3000 4000，但根据确认序列号的定义，接受方只能发送ACK = 1001\n拥塞控制 虽然TCP有了滑动窗口这个大杀器, 能够高效可靠的发送大量的数据. 但是如果在刚开始阶段就发送大量的数据, 仍然可能引发问题. 因为网络上有很多的计算机, 可能当前的网络状态就已经比较拥堵. 在不清楚当前网络状态下, 贸然发送大量的数据,是很有可能引起雪上加霜的. 因此TCP引入了拥塞控制。\n拥塞控制的目的是防止过多的数据注入到网络中，避免网络中的路由器或链路过载。是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。\nTCP 进行拥塞控制的算法有四种\n慢开始（slow-start) 拥塞避免(congestion avoidance) 快重传(fast retransmit) 快恢复(fast recovery) 此外引入2个概念：拥塞窗口(cwnd：congestion window)和慢开始门限 (ssthresh)\n拥塞窗口：初始为1，根据拥塞控制算法进行修改，它的作用：16位窗口大小 = min(cwnd, rwnd)\n慢开始门限：为了防止拥塞窗口 cwnd 增长过大引起网络拥塞，还需要设置一个慢开始门限。具体来说，它用来控制什么情况下执行哪一种拥塞控制算法。\n算法思想如下：cwnd 初始置1\n刚开始执行慢开始算法，cwnd成指数增长\n当cwnd \u0026gt; ssthresh，执行拥塞避免算法（特殊情况：cwnd == ssthresh，执行慢开始、拥塞避免都可以），开始进行线性增长\n当出现下面2种情况：\n情况1：超时，发送方长时间未收到接受方的ACK，判定为网络拥塞。则cwnd置1，ssthresh变为超时时的cwnd的一半。进入慢开始阶段\n情况2：快重传，发送方收到接受方3个相同的ACK。则cwnd == ssthresh == 快重传时cwnd的一半，进入快恢复阶段\n理解：为什么分2种情况？\n答：有时，个别报文段会在网络中意外丢失，但实际上网络并未发生拥塞。如果发送方迟迟收不到确认，就会产生超时，并误认为网络发生了拥塞。这就导致发送方错误地启动慢开始，把拥塞窗口 cwnd 又设置为 1，因而不必要地降低了传输效率。因而引入快重传算法\n快重传机制 快重传算法规定，发送力只要一连收到3个重复确认，就可知道现在并未出现网络拥塞，而只是接收方少收到一个报文段 M3 ，因而立即进行重传M3 (即“快重传”)。使用快重传可以使整个网络的吞吐坟提高约 20%.\n超时重传机制 主机A发送给主机B的数据可能因为网络问题而丢失，或者主机B由于某些原因，收到了报文，但没有应答。\n如果主机A在一定时间内没有收到主机B的应答，则会重发。\n问题：\n主机B可能收到多个相同的报文，如何去重？ 根据序列号\n“超时时间”是如何规定的？当网络良好时，超时时间太长，会导致效率低下，同理当网络不好时，超时时间太小，也会导致效率低下。\nLinux中(BSD Unix和Windows也是如此), 超时以500ms为一个单位进行控制, 每次判定超时重发的超时\n时间都是500ms的整数倍.\n如果重发一次之后, 仍然得不到应答, 等待 2*500ms 后再进行重传.\n如果仍然得不到应答, 等待 4*500ms 进行重传. 依次类推, 以指数形式递增.\n累计到一定的重传次数, TCP认为网络或者对端主机出现异常, 强制关闭连接.\nTCP异常情况分析 SYN洪水 .\n","date":"2025-04-02T00:00:00Z","permalink":"https://sfw003.github.io/p/transport-layer/","title":"传输层"},{"content":"高并发内存池\n","date":"2025-04-02T00:00:00Z","permalink":"https://sfw003.github.io/p/high-concurrent-memory-pool/","title":"高并发内存池"},{"content":"一、内网穿透的基本原理 内网穿透的核心目标是让外网设备访问内网资源，而内网设备通常位于NAT（网络地址转换）或防火墙之后，无法直接被外网访问。其原理主要分为两类：\n端口映射（NAT转发）\n通过路由器将内网设备的某个端口映射到公网IP的指定端口，外网用户通过公网IP+端口访问内网服务。例如，将内网服务器192.168.1.100的80端口映射到公网IP的8080端口，外网访问公网IP:8080即可访问内网服务。\n• 适用场景：家庭网络、小型企业等有公网IP的环境。 • 局限性：需手动配置路由器，且依赖公网IP，若运营商未分配公网IP则无法使用。\n代理服务器中转\n利用第三方服务器（如花生壳、frp）作为“桥梁”，内网设备主动连接服务器建立通道，外网请求通过服务器转发至内网。例如：内网设备向服务器发送心跳包保持连接，外网用户访问服务器时，数据通过已建立的通道传输。\n• 适用场景：无公网IP、需动态域名解析（DDNS）或跨运营商访问。 • 优势：无需公网IP，支持动态IP环境；缺点是带宽受限于中转服务器。\n二、实现方式对比 1. 端口转发的操作流程（基础方案） • 步骤：\n① 登录路由器管理界面（如192.168.1.1）；\n② 找到“端口转发”或“虚拟服务器”选项；\n③ 配置规则：内网IP、内网端口、公网端口（如将公网8080映射到内网80端口）；\n④ 保存并重启路由器。\n• 适用性：适合有公网IP且路由器支持NAT转发的场景，例如家庭NAS对外共享文件。\n2. 第三方工具（进阶方案） • 服务器中转工具（如frp、花生壳）：\n在公网服务器部署服务端，内网设备运行客户端，建立隧道转发请求。例如frp通过配置frps.ini（服务端）和frpc.ini（客户端）实现HTTP/TCP穿透。\n• 优势：支持无公网IP、跨网络穿透；\n• 缺点：需额外服务器资源，配置复杂度较高。\n• P2P穿透（如UDP打洞）：\n通过中间服务器协助，让两个NAT后的设备直接通信。例如：客户端A和B通过服务器交换地址信息后，尝试直接发送UDP包穿透NAT网关。\n• 适用场景：视频会议、P2P下载等低延迟需求场景；\n• 限制：受NAT类型影响（对称型NAT穿透难度大）。\n三、端口转发的局限性 虽然端口转发是基础手段，但实际应用中存在以下问题：\n依赖公网IP：多数家庭宽带无固定公网IP，需结合DDNS（动态域名解析）。 安全性风险：直接暴露端口可能被攻击，需配合防火墙规则（如仅允许特定IP访问）。 协议兼容性：某些协议（如FTP、VoIP）需要额外处理NAT穿透逻辑。 ","date":"2025-04-02T00:00:00Z","permalink":"https://sfw003.github.io/p/intranet-penetration/","title":"内网穿透"},{"content":"了解完网络层，我们知道了数据报是如何跨网络进行传输的，数据报通过一次又一次的”跳“，最后到达目的主机。但具体的一次”跳”是怎么完成的呢？由数据链路层完成，下面介绍数据链路层。\n数据链路层 数据链路层负责通过一条链路从一个结点向另一个物理链路直接相连的相邻结点传送数据报。\n链路：网络中两个结点之间的物理通道，链路的传输介质主要有双绞线、光纤和微波。分为有线链路、无线链路。 数据链路：网络中两个结点之间的逻辑通道，把实现控制数据传输协议的硬件和软件加到链路上就构成数据链路。 数据链路层在物理层提供服务的基础上向网络层提供服务。\n对上：将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。 对下：加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造成为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。 数据链路层负责两个设备(同一种数据链路节点)之间进行传递。通常情况下，同一数据链接即二者处于同一局域网内，因此首先要了解局域网内是如何通信的。\n注：局域网和数据链路的关系\n虽然在许多情况下，处于同一数据链路的设备确实位于同一个局域网内，但有些网络拓扑和配置可能导致例外情况：\n虚拟局域网（VLAN）：VLAN允许在同一个物理网络基础设施上创建多个逻辑隔离的网络。不同VLAN的设备尽管连接到同一个交换机，但处于不同的逻辑数据链路和广播域中。 网桥和交换机：现代交换机能够隔离冲突域，但不隔离广播域。因此，连接到同一交换机不同端口的设备可以认为在同一数据链路上，但仍处于同一局域网中。 子网划分和路由：在一些复杂网络中，可能会通过子网划分和路由策略，使得不同子网的设备在逻辑上看似处于不同数据链路，但实际上共享同一个物理介质。 局域网通信 局域网通信的技术：以太网，令牌环网, 无线LAN等\n下面主要介绍以太网。\n以太网 以太网（Ethernet）是一种广泛使用的局域网（LAN）技术，用于在局域网内设备之间进行数据通信。它定义了数据帧的格式、传输协议、物理连接标准和介质访问控制方法。以太网因其高效性、可靠性和易于实现而成为最常用的有线网络技术。\n\u0026ldquo;以太网\u0026rdquo; 不是一种具体的网络, 而是一种技术标准; 既包含了数据链路层的内容, 也包含了一些物理层的内容. 例如: 规定了网络拓扑结构, 访问控制方式, 传输速率等;例如以太网中的网线必须使用双绞线; 传输速率有10M, 100M, 1000M等;\n以太网是当前应用最广泛的局域网技术; 和以太网并列的还有令牌环网, 无线LAN等;\n以太网会将网络层的IP数据报封装为以太网帧，然后进行通信。那以太网帧的格式是什么呢？\n数据帧 封装成帧 封装成帧就是在一段数据的前后部分添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。\n首部和尾部包含许多的控制信息，他们的一个重要作用:定界(确定帧的界限)。\n帧同步:接收方应当能从接收到的二进制比特流中区分出帧的起始和终止。\n组帧的四种方法:\n字符计数法， 字符(节)填充法 零比特填充法 违规编码法。 透明传输 差错检验 差错的来源：\n全局性 1.由于线路本身电气特性所产生的随机噪声(热噪声)，是信道固有的，随机存在的。 解决办法:提高信噪比来减少或避免干扰。(对传感器下手) 局部性 2.外界特定的短暂原因所造成的冲击噪声，是产生差错的主要原因。 解决办法:通常利用编码技术来解决。\n差错体现的方面：\n差错的检测和解决\n奇偶检验码：\n局限：奇效验码只能检测奇数个1的错误，50%\n循环冗余检验 CRC (Cyclic Redundancy Check)\n举例:\n总结：\n在数据链路层仅仅使用循环冗余检验CRC差错检测技术，只能做到对的无差错接收，即“凡是接收端数据链路层接受的帧，我们都能以非常接近于1的概率认为这些帧在传输过程中没有产生差错”。接收端丢弃的帧虽然曾收到了，但是最终还是因为有差错被丢弃。“凡是接收端数据链路层接收的帧均无差错”\n注意：无差错 \u0026lt; 可靠传输（无差错，不丢失，不重复）\n数据链路层的流量控制 它和TCP的流量控制的区别：\n传输层的流量控制是 端到端\n数据链路层的流量控制是 点到点\n都是通过滑动窗口来控制，但是数据链路层的滑动窗口的大小是固定的，而传输层不是固定的。\n问题：由来传输层的流量控制，为什么还需要数据链路层的流量控制？\n答：早期网络并不完善，让数据链路层进行流量控制，但现在随着技术发展，现代网络中的流量控制和错误恢复功能主要由传输层（如 TCP）来处理，而数据链路层更多地专注于差错检测和基本的帧传输。但在一些特定的网络场景中，数据链路层仍然会实现一些流量控制机制，例如：以太网流量控制，无线局域网。\n以太网帧（MAC帧） MAC地址 MAC地址用来识别数据链路层中相连的节点;\n长度为48位, 及6个字节. 一般用16进制数字加上冒号的形式来表示(例如: 08:00:27:03:fb:19)\n在网卡出厂时就确定了, 不能修改. mac地址通常是唯一的(虚拟机中的mac地址不是真实的mac地址, 可能会冲突; 也有些网卡支持用户配置mac地址).\n它和IP地址有什么关系？\nIP地址和MAC地址 IP地址\n描述路途总体的 起点 和 终点; 它是逻辑层面的地址 MAC地址\n描述的是路途上的每一个区间的起点和终点; 它是物理层的地址 问题：为什么要分别用IP地址和MAC地址来作为逻辑层面和物理层面的地址，不能用MAC地址作为统一的地址吗？\n答：\n基于分层设计和职责分离的原则：计算机网络协议栈采用分层设计，每层具有不同的功能。MAC地址用于数据链路层，负责在同一局域网内传输数据包；IP地址用于网络层，负责跨网络的路由和传输。分层设计使得每层可以独立发展和优化，增强了整个网络系统的灵活性和可扩展性。 兼容性：不同的网络技术（如以太网、Wi-Fi、光纤、卫星等）都有自己独特的物理层和数据链路层协议。通过在网络层使用统一的IP地址，可以在各种不同底层技术上实现互操作性和兼容性，促进不同网络之间的无缝通信。 我们在IP报文如果太大需要分片，这里的“大”是相对数据链路层而言，具体来说是相对于MTU\nMTU 网络链路上的最大传输单元（MTU，Maximum Transmission Unit）：不同的网络类型有不同的MTU，最常用的以太网就规定其 MTU 值是 1500 字节。如果一个数据包从以太网路由到拨号链路上,数据包长度大于拨号链路的MTU了,则需要对数据包进行分片(fragmentation。\n以太网帧中的数据长度规定最小46字节,最大1500字节\n注：ARP数据包的长度不够46字节,要在后面补填充位;\nMTU对IP层的影响 由于数据链路层MTU的限制, 对于较大的IP数据包要进行分包.\n将较大的IP包分成多个小包, 并给每个小包打上标签;\n每个小包IP协议头的 16位标识(id) 都是相同的;\n每个小包的IP协议头的3位标志字段中, 第2位置为0, 表示允许分片, 第3位来表示结束标记(当前是否是最\n后一个小包, 是的话置为1, 否则置为0);\n到达对端时再将这些小包, 会按顺序重组, 拼装到一起返回给传输层;\n一旦这些小包中任意一个小包丢失, 接收端的重组就会失败. 但是IP层不会负责重新传输数据;\nMTU对UDP和TCP的影响 让我们回顾一下UDP协议:\n一旦UDP携带的数据超过1472(1500 - 20(IP首部) - 8(UDP首部)), 那么就会在网络层分成多个IP数据报.\n这多个IP数据报有任意一个丢失, 都会引起接收端网络层重组失败. 那么这就意味着, 如果UDP数据报在\n网络层被分片, 整个数据被丢失的概率就大大增加了.\n让我们再回顾一下TCP协议:\nTCP的一个数据报也不能无限大, 还是受制于MTU. TCP的单个数据报的最大消息长度, 称为MSS(Max Segment Size);\nTCP在建立连接的过程中, 通信双方会进行MSS协商.\n最理想的情况下, MSS的值正好是在IP不会被分片处理的最大长度(这个长度仍然是受制于数据链路层的MTU), 双方在发送SYN的时候会在TCP头部写入自己能支持的MSS值.然后双方得知对方的MSS值之后, 选择较小的作为最终MSS.\nMSS的值就是在TCP首部的40字节变长选项中(kind=2);\n如果MTU = 1500, 则max有效载荷 = 1500-20((P)) - 20(TCP) = 1460\n源地址和目的地址是指网卡的硬件地址(也叫MAC地址), 长度是48位,是在网卡出厂时固化的; 帧协议类型字段有三种值,分别对应IP、ARP、RARP; 数据 = 网络层的数据报 帧末尾是CRC校验码 介绍完MAC帧，下面具体看看MAC帧是如何进行局网络通信的。\nMAC帧在局域网通信 场景：主机A想发送消息给主机D\n过程：\n主机A封装好MAC帧，在目的地址填入主机D的MAC地址 主机A将消息发送到广播信道（共享信道）里，于是所有主机都会收到消息 然后主机会在数据链路层会检测MAC帧里的目的地址，如果不符合则直接丢弃，符合则向上层传递。 碰撞冲突 局域网通信，一台发送的消息，其他主机都会收到。如果多台主机同时发送消息，那么消息就会产生冲突。这就是碰撞冲突。\n为了减少碰撞的发生，局域网通常会采用一些措施，如使用碰撞避免算法，交换机。\n碰撞避免算法是从软件层面上\n交换机则是从硬件层面上：\n在数据链路层，主要采用2种信道：广播信道和点对点信道\n(l) 点对点信道。这种信道使用一对一的点对点通信方式。\n(2) 广播信道。这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送。\n广播信道存在碰撞冲突问题。\n交换机(switch)：支持点对点和广播\n局域网瘫痪（小知识） 一台主机不断发送垃圾消息到局域网内。\n前文我们了解，具体某一跳在局域网是如何进行的，下面我们从局域网道广域网来整体看待这个过程。\n从局域网到广域网 MAC帧在广域网通信 在网络传输的过程，MAC帧不断解包、丢弃、封包，这样每一跳就和前文描述的一样。\n但现在有个问题：前文提到的局域网通信地址都是MAC地址，但实际我们在通信过程使用的是IP地址，如何理解二者在数据传输过程的关系？\nARP协议 虽然我们在这里介绍ARP协议, 但是需要强调, ARP不是一个单纯的数据链路层的协议, 而是一个介于数据链路层和网络层之间的协议;\nARP协议的作用 ARP协议建立了主机 IP地址 和 MAC地址 的映射关系.\n在网络通讯时,源主机的应用程序知道目的主机的IP地址和端口号,却不知道目的主机的硬件地址;数据包首先是被网卡接收到再去处理上层协议的,如果接收到的数据包的硬件地址与本机不符,则直接丢弃;因此在通讯前必须获得目的主机的硬件地址;\n源主机发出ARP请求,询问“IP地址是192.168.0.1的主机的硬件地址是多少”, 并将这个请求广播到本地网段(以太网帧首部的硬件地址填FF:FF:FF:FF:FF:FF表示广播);\n主机1的ARP缓存表中不存在主机2的MAC地址，所以主机1会发送ARP Request来获取目的MAC地址。 •ARP Request报文封装在以太帧里。帧头中的源MAC地址为发送端主机1的MAC地址。此时，由于主机1不知道主机2的MAC地址，所以目的MAC地址为广播地址FF-FF-FF-FF-FF-FF。 •ARP Request报文中包含发送端MAC地址、发送端IP地址、目的端MAC地址（未知）、目的端IP地址（已知），其中目的端MAC地址的值为0。ARP Request报文会在整个网络上传播，该网络中所有主机包括网关都会接收到此ARP Request报文。并对报文进行泛洪操作。\n总结：以太帧帧头中目的地址为FF-FF-FF-FF-FF-FF（广播地址）则所有端口都会接受此报文。 以太帧里封装着的ARP Request报文中目的地址为00-00-00-00-00-00 那么网络中的所有主机和网关接收到这帧数据，都会检查它的目的端IP地址字段与自身的IP地址是否匹配。如果匹配，该主机会将ARP请求报文中的发送端MAC地址和发送端IP地址信息记录到自己的ARP缓存表中，然后通过ARP Reply报文进行响应。如果不匹配，主机将不会响应此报文。\n每台主机都维护一个ARP缓存表,可以用arp -a命令查看。缓存表中的表项有过期时间(一般为20分钟),如果20分钟内没有再次使用某个表项,则该表项失效,下次还要发ARP请求来获得目的主机的硬件地址\nARP数据报格式 注意到源MAC地址、目的MAC地址在以太网首部和ARP请求中各出现一次,对于链路层为以太网的情况是多余的,但如果链路层是其它类型的网络则有可能是必要的。\n硬件类型指链路层网络类型,1为以太网;\n协议类型指要转换的地址类型,0x0800为IP地址;\n硬件地址长度对于以太网地址为6字节;\n协议地址长度对于和IP地址为4字节;\nop字段为1表示ARP请求,op字段为2表示ARP应答。\nARP请求过程：\n主机A向信道内发送APR请求，其余主机都会收到 非目的主机，如主机c：收到ARP请求后，进行有效载荷的分离。1. 检查以太网目的地址，为全F，表明是广播地址，因此需要进行处理。2. 查看帧类型，为1，传到ARP层。3. 查看op字段，为1，表示为ARP请求。 4. 查看目的IP地址，为ipB, 与主机C的ipC不同, 因此丢弃 目的主机，如主机B：经过2的流程后，主机B需要做出ARP应答，填充格式如图。 ARP应答过程：\n非目的主机收到ARP应答后，在数据链路层比对目的MAC地址时，就会丢弃。 目的主机收到ARP应答后，会生成一组 IP:MAC 的映射关系 ARP协议相关的周边问题 ARP缓存为什么要有时间限制？ip:mac的映射关系可能会更改，\n多次ARP请求以最新一次为准\nARP欺骗：ARP欺骗（ARP Spoofing），也称为ARP中毒（ARP Poisoning），是一种网络攻击技术，通过发送伪造的ARP（地址解析协议）消息，使目标设备更新其ARP缓存中的IP地址与MAC地址的对应关系，从而将流量误导到攻击者的设备上。这种攻击可以导致多种安全问题，如数据窃取、中间人攻击（Man-in-the-Middle Attack）、网络瘫痪等。\n","date":"2025-04-02T00:00:00Z","permalink":"https://sfw003.github.io/p/data-link-layer/","title":"数据链路层"},{"content":"网络层（网际层） 作用：负责跨网络传输，并在传输过程中选择最合适的路径。\n设计方案：网络层要设计得尽量简单，向其上层只提供简单灵活的无连接的、尽最大努力交付的数据报服务\n网络层最重要的任务是路由选择和分组转发\n要想将数据送到网络世界的某一台主机，首先必须要用一个唯一的标识符来标识主机。网络层给出的解决方式是用IP地址来区别主机。\nIP地址 IP地址的设计可分为两个主要版本：IPv4和IPv6。\nIPv4 格式 IPv4地址是32位的二进制数，通常表示为四个十进制数，即点分十进制，每个数取值范围为0到255，用点号分隔（例如：192.168.0.1）。 问题1：为什么设计成这样？\n以一个生活中例子来讲解：有个计院的学生，他的学号为0101，现在他捡到了一个校园卡，校园卡上标注的学号为0202。他想将校园卡交给失主，该怎么做？\n学校人那么多，不可能自己慢慢找，于是他将校园卡交给了计院的学生会 计院的学生会首先查看学号的前2位：02，而计院学生的学号开头统一为01，因此不可能为计院的学生。于是计院学生会在学校学生会群里询问。 经院学生会发现，02与经院学号开头匹配，表明该校园卡属于经院的学生。于是拿走了校园卡 然后经院学生会根据学号的后两位：02，找到了失主。 网络查找主机的方式，类似于上面找失主的例子，只是网络的层次更多。\nIP地址相当于学号，众所周知，学号是被划分的，即前n位代表学院，后m位代表该学院的某个学生，IP地址有划分吗? 有！\nIPv4地址的划分 分类划分法 IP地址分为两个部分, 网络号和主机号\n网络号: 保证相互连接的两个网段具有不同的标识;\n主机号: 用于标识网络和网络中的具体设备，同一网段内, 主机之间具有相同的网络号, 但是必须有不同的主机号;\n不同的子网其实就是把网络号相同的主机放到一起.如果在子网中新增一台主机, 则这台主机的网络号和这个子网的网络号一致, 但是主机号必须不能和子网中的其他主机重复.\n初始设计中，地址被分为A、B、C、D和E类，以不同的方式划分网络和主机部分：\n这种划分称为分类划分法。\n随着Internet的飞速发展,这种划分方案的局限性很快显现出来,大多数组织都申请B类网络地址, 导致B类地址很快就分配完了, 而A类却浪费了大量地址;例如, 申请了一个B类地址, 理论上一个子网内能允许6万5千多个主机. A类地址的子网内的主机数更多. 然而实际网络架设中, 不会存在一个子网内有这么多的情况. 因此大量的IP地址都被浪费掉了\n针对这种情况提出了新的划分方案, 称为CIDR(Classless Interdomain Routing):无分类域间路由选择\n无分类域间路由选择-CIDR 引入一个额外的子网掩码(subnet mask)来区分网络号和主机号;\n子网掩码也是一个32位的正整数. 通常用一串 \u0026ldquo;0\u0026rdquo; 来结尾;\n将IP地址和子网掩码进行 \u0026ldquo;按位与\u0026rdquo; 操作, 得到的结果就是网络号;\n网络号和主机号的划分与这个IP地址是A类、B类还是C类无关;\n此时IP地址 = {\u0026lt;网络前缀\u0026gt;，\u0026lt;主机号\u0026gt;}\n子网掩码(地址掩码)：分类的IP地址划分的主要问题就是网络号和主机号的比例只有3类：7:24, 14:16, 21:8，我们想要的根据实际情况，动态更改网络号和主机号的比例。子网掩码可以解决这个问题。\n那如何求子网掩码呢？\n定长子网掩码\n不定长子网掩码\nCIDR在一定程度上缓解了IP地址不够用的问题(提高了利用率, 减少了浪费, 但是IP地址的绝对上限并没有增加), 仍然\n不是很够用. 这时候有三种方式来解决:\n动态分配IP地址: 只给接入网络的设备分配IP地址. 因此同一个MAC地址的设备, 每次接入互联网中, 得到的IP地址不一定是相同的;\nNAT技术\nIPv6: IPv6并不是IPv4的简单升级版. 这是互不相干的两个协议, 彼此并不兼容; IPv6用16字节128位来表示一个IP地址; 但是目前IPv6还没有普及;\n特殊的IP地址 NAT技术 公网IP和私网IP 如果一个组织内部组建局域网,IP地址只用于局域网内的通信,而不直接连到Internet上,理论上 使用任意的IP地址都可以,但是RFC 1918规定了用于组建局域网的私有IP地址\n10.*,前8位是网络号,共16,777,216个地址\n172.16.* 到 172.31.*,前12位是网络号,共1,048,576个地址\n192.168.*,前16位是网络号,共65,536个地址\n包含在这个范围中的, 都成为私有IP, 其余的则称为全局IP(或公网IP);\n问题1:为什么要分公网和私网？公网IP和私网IP是如何工作的？\n主要是因为IPv4地址不够，因此我们需要复用一些IP地址，一台主机的IP地址不是唯一的吗？怎么还能复用。\n工作原理如下：\n一台主机的IP的地址是在联网时由路由器进行分配，为私有IP地址，在不同的局域网内，私有IP地址可能相同。主机发送请求到路由器，如果主机访问的IP不属于该路由器的局域网内，则路由器会更改数据报里的源IP地址，更改为路由器的WAN口IP，向上一级转发。也就是说，数据报在传输过程，源IP地址一直在变化。这样我们只需要给部分路由器赋予唯一的公网IP，而这些路由器下的子网使用私网IP进行管理。\n这种技术就是NAT技术（网络地址转换）：私网IP地址通常在内部网络中使用，并通过网络地址转换（NAT）设备（如路由器）将私网IP映射到一个或多个公网IP地址。NAT允许多个设备共享一个公网IP地址访问互联网，有效地减少了对公网IP地址的需求。\n一个路由器可以配置两个IP地址, 一个是WAN口IP, 一个是LAN口IP(子网IP).\n路由器LAN口连接的主机, 都从属于当前这个路由器的子网中.\n不同的路由器, 子网IP其实都是一样的(通常都是192.168.1.1). 子网内的主机IP地址不能重复. 但是子网之间的IP地址就可以重复了.\n每一个家用路由器, 其实又作为运营商路由器的子网中的一个节点. 这样的运营商路由器可能会有很多级,\n最外层的运营商路由器, WAN口IP就是一个公网IP了.\n子网内的主机需要和外网进行通信时, 路由器将IP首部中的IP地址进行替换(替换成WAN口IP), 这样逐级替换, 最终数据包中的IP地址成为一个公网IP. 这种技术称为NAT(Network Address Translation，网络地址转换).\n如果希望我们自己实现的服务器程序, 能够在公网上被访问到, 就需要把程序部署在一台具有外网IP的服务器上. 这样的服务器可以在阿里云/腾讯云上进行购买.\n那现在有个问题：主机通过私有IP访问互联网时，路由器会不断更改源IP地址，那么目的主机，也就是服务器，服务器的响应该怎么返回呢？\n答：当设备在私有网络中访问互联网时，路由器使用NAT将设备的私有IP地址替换为路由器的公网IP地址，**并记录这个映射关系。**这样当服务器返回的响应到路由器后，会根据映射关系跳到下一级路由器，最后到主机。\n了解完IP地址，那有个问题：谁给主机设置IP地址？\nIP地址的分配 静态配置 人手动配置\n动态配置 - DHCP（应用层协议） 动态主机配置协议DHCP是应用层协议，使用客户/服务器方式，客户端和服务端通过广播方式进行交互，基于UDP。 DHCP提供即插即用联网的机制，主机可以从服务器动态获取IP地址、子网掩码、默认网关、DNS服务器名称与IP地址, 允许地址重用，支持移动用户加入网络，支持在用地址续租。\n1.主机广播DHCP发现报文 2.DHCP服务器广播DHCP提供报文 3.主机广播DHCP请求报文 4.DHCP服务器广播DHCP确认报文\n那IP地址与数据是如何包装的？\n网际协议IP IP报文格式 4位版本号(version):指定IP协议的版本,对于IPv4来说,就是4. 4位头部长度(header length): IP头部的长度是多少个32bit,也就是 length * 4 的字节数4bit表示最大的数字是15,因此IP头部最大长度是60字节. 8位服务类型(Type of Service): 3位优先权字段(已经弃用),4位TOS字段 和1位保留字段(必须置为0).4位TOS分别表示: **最小延时,最大吞吐量,最高可靠性,最小成本,**这四者相互冲突,只能选择一个，需要根据不同的情况选择不同的对于ssh/telnet这样的应用程序,最小延时比较重要; 对于ftp这样的程序,最大吞吐量比较重要. 16位总长度(totallength): IP数据报整体占多少个字节. 16位标识(id): 唯一的标识主机发送的报文.如果IP报文在数据链路层被分片了,那么每一个片里面的这个id都是相同的. 3位标志字段: 第一位保留(保留的意思是现在不用,但是还没想好说不定以后要用到)第二位置为1表示禁止分片,这时候如果报文长度超过MTU,IP模块就会丢弃报文,第三位表示\u0026quot;更多分片”,如果分片了的话最后一个分片置为1，其他是0.类似于一个结束标记. 13位分片偏移(framegament offset): 是分片相对于原始IP报文开始处的偏移.其实就是在表示当前分片在原报文中处在哪个位置实际偏移的字节数是这个值*8 得到的.因此，除了最后一个报文之外,其他报文的长度必须是8的整数倍(否则报文就不连续了). 8位生存时间(Time To Live, TTL): 数据报到达目的地的最大报文跳数,一般是64.每次经过一个路由,TTL-= 1，一直减到0还没到达,那么就丢弃了.这个字段主要是用来防止出现路由循环 8位协议: 表示上层协议的类型 16位头部校验和: 使用CRC进行校验,来鉴别头部是否损坏. 32位源地址和32位目标地址: 表示发送端和接收端 选项字段(不定长,最多40字节): 略 IP层的分组转发 IP（Internet Protocol）报文有时会由于其大小超过了数据链路层的最大传输单元（MTU，Maximum Transmission Unit）而需要进行分片（fragmentation）。\n控制分片的字段是IP报头里的3位标志和13位片偏移。\n3位标志\n第0位（保留位，Reserved Bit，RB）： 始终为0，保留为将来使用。 在处理IP报文时，应忽略这个位的值。 第1位（不分片位，Don\u0026rsquo;t Fragment，DF）： 如果设置为1，则表示不允许对该IP报文进行分片。如果报文大小超过MTU，则报文将被丢弃并返回ICMP错误消息。 如果设置为0，则表示允许对该IP报文进行分片。 第2位（更多分片位，More Fragments，MF）： 如果设置为1，则表示后面还有更多的分片。 如果设置为0，则表示这是最后一个分片或者报文没有被分片。 13位片偏移：片偏移指出：较长的分组在分片后，某片在原分组中的相对付置，也就是说，相对于用户数据字段的起点，该片从何处开始。片偏移以8个字节为偏移单位。这就是说，除最后一个数据报片外，其他每个分片的长度一定是8字节 (64 位）的整数倍。\n分片过程：\n（1）广播地址是网络地址中主机号全l的地址（主机号全0的地址代表网络本身）。销售部和技术部均分配了192.168.1.0/24的IP地址空间，IP地址的前24位为子网的网络号。于是在后8位中划分部门的子网，选择前1位作为部门子网的网络号。令销售部子网的网络号为0，技术部子网的网络号为1，则技术部子网的完整地址为192.168.1.128；令销售部子网的主机号全1，可以得到该部门的广播地址为192.168.1.127。每个主机仅分配一个IP地址，计算目前还可以分配的主机数，用技术部可以分配的主机数减去已分配的主机数，技术部总共可以分配给计算机的主机数为27-2=126(减去全0和全l的主机号）。已经分配了208-129+1=80个，此外还有1个IP地址分配给了路由器的端口(192.168.1.254)，因此还可以分配126-80-1=45台。\n（2）判断分片的大小，需要考虑各个网段的MTU，而且注意分片的数据长度必须是8B的整数倍。由题可知，在技术部子网内，MTU=800B，IP分组头部长20B，最大1P分片封装数据的字节数为L[(800-20)/8]*8=776。至少需要的分片数[(1500-20)/776=2。第1个分片的偏移量为0；第2个分片的偏移量为776/8=97。\n丢片问题：\n第一个丢了：找不到片偏移=0 ==\u0026gt; 第一个丢了 中间丢了：根据片偏移和报文大小进行计算，可以得出。比如上面收到1和3，但3片偏移=2000，而1只有1000字节，因此少了1000字节 ==\u0026gt; 2丢了 最后一个丢了：找不到MF=0的报文 ==\u0026gt; 最后一个丢了 推荐分片吗？ 不推荐。增加了丢包概率，少一个分片都要重发。\nICMP协议 为了更有效地转发 IP 数据报和提高交付成功的机会，在网际层使用了网际控制报文协ICMP (Internet Control Message Protocol) 。\nICMP协议是一个 网络层协议，它的位置在IP协议上方，简单来说，ICMP的数据是包装在IP报文里。\n”为了更有效地转发 IP 数据报和提高交付成功的机会“， 那ICMP如何提高效率？\n首先，在发送数据之前，先探探路。\n因此ICMP报文分为了2种：ICMP 差错报告报文和 ICMP 询间报文。\nICMP报文的种类 差错报文的种类 (I) 终点不可达\n当路由器或主机不能交付数据报时就向源点发送终点不可达报文。\n(2) 时间超过\n当路由器收到生存时间为零的数据报时，除丢弃该数据报外，还要向\n源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，\n就把已收到的数据报片都丢弃，并向源点发送时间超过报文。\n(3) 参数问题\n当路由器或目的主机收到的数据报的首部中有的字段的伯不正确时，\n就丢弃该数据报，并向源点发送参数问题报文。\n(4) 改变路由（重定向）\n路由器把改变路由报文发送给主机，让主机知道下次应将\n数据报发送给另外的路由器（也就是说，找到了更好的路由）。\n询问报文的种类 在应用层有个工具：Ping，它是之间跨过\nICMP的应用 PING 前文描述了一个数据报通过NAT技术不断转发的过程，那么具体的某一次转发过程是什么样子的呢？\n路由的过程, 就是这样一跳一跳(Hop by Hop) \u0026ldquo;问路\u0026rdquo; 的过程.\n所谓 \u0026ldquo;一跳\u0026rdquo; 就是数据链路层中的一个区间. 具体在以太网中指从源MAC地址到目的MAC地址之间的帧传输区间.\nIP数据包的传输过程也和问路一样.\n当IP数据包, 到达路由器时, 路由器会先查看目的IP;\n路由器决定这个数据包是能直接发送给目标主机, 还是需要发送给下一个路由器;\n依次反复, 一直到达目标IP地址;\n那么如何判定当前这个数据包该发送到哪里呢?\n不同网络中的两个主机之间的通信，要经过若干个路由器转发分组来完成，分组查找路由器中的转发表，从指明的按口转发到下个路由器。但转发表是怎样得出的呢？是从路由表导出的。而路山表又是由互联网中许多的路由器，按照共同选定的路由选择协议，通过许多次的相互交换路由信息而产生的。\n路由 因此路由器传输的信息可以分为两类：\n数据 路由信息 在计算机网络种，将2这抽象为数据平面和控制平面。\n数据\u0026ndash;数据平面 \u0026ndash;根据转发表进行转发，时间短，直接用硬件解决\n路由信息\u0026ndash;控制平面 \u0026ndash;根据路由算法得出，时间长，用软件解决\n控制平面有2种方式：\n传统方法：每个路由器都有控制平面和数据平面，路由器自己计算路由选择算法。\nSDN（software-Defined Networking) 方法：控制平面在远程控制器，然后远程控制器分发给各路由器。\n路由算法 路由选择协议 \u0026ndash; 动态路由 路由选择分层:\n互联网太大：如果让所们的路由器知道所付的网络应怎样到达，则这种路由器将非常大，处理起来也太花时间 许多单位也不愿意暴露自己单位网络的细节给外界。 为此，可以把整个互联网划分为许多较小的自治系统(autonomous system), 一般都记为AS 。\nRIP协议 RIP(Routing Information Protocol) 是一种分布式的基于距离向量的路由选择协议，是因特网的协议标准，最大优点是简单。 RIP协议要求网络中每一个路由器都维护从它自己到其他每一个目的网络的唯一最佳距离记录(即一组距离)。\n距离:通常为“跳数”，即从源端口到目的端口所经过的路由器个数，经过一个路由器跳数+1。\n特别的，从一路由器到直接连接的网络距离为1。\nRIP允许一条路由最多只能包含15个路由器，因此距离为16表示网络不可达。这就表明RIP协议只适用于小互联网。\n路由器如何维护这个最佳距离？路由器刚开始就知道这个最佳距离吗？不知道，它需要去“询问”，准确来说“交换”，与其他路由器交换各自的路由信息。\n问题：和谁交换？何时交换？如何根据交换的路由信息更新自己的路由信息？\n和谁交换信息：仅和相邻路由器交换信息 交换什么信息：自己的路由表 何时交换信息：周期性交换(例如每30秒) 路由器刚开始工作时，只知道自己到直连网络的距离为1，经过若干次交换和更新后，每个路由器都知道到达本AS内各网络的最短距离和下一跳地址，这一过程称为收敛。\n具体的更新方式：\nRIP协议的格式 现在较新的 RIP 版本是 1998 11 月公布的 RlP2 [RFC 2453, STD57], 新版本协议本身并无多大变化，但性能上有些改进。 RIP2 可以支持九分类域间路由选择 CIDR 。此外，RIP2 还提供简单的鉴别过程支持多插。\nRIP 报义由首部和路由部分组成。在路由部分要填入自治系统号 ASN (Autonomous System Number)，这是考虑使 RIP 有可能收到本自治系统以外的路由选择信息。还要指出目的网络地址（包括网络的子网掩码）、下一跳路由器地址以及到此网络的距离。一个 RIP报文最多可包括 25 个路由。如超过，必须再用一个 RIP报文来传送。\nRIP的缺点 RTP 存在的一个问题是当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器。我们可以用图 4-41 的简单例子来说明。设三个网络通过两个路由器互连起来，并且都已建寸了各自的路由表。图中路由器交换的信息只给出了我们感兴趣的一行内容。路\n路由器 R, 中的 “Net 1,1, 直接”表示”到网 Net1的距离是 I, 直接交付\n路由器 R2 中的\u0026quot;Net 1,2, R1\u0026quot; 表示”到网 Net1的距离是 2, 下一跳经过 R1\n现在假定路由器R1到Net1的线路出问题了，因R1更新自己的路由信息并发送：Net1的距离改为 16, 表示不可达。因而传输的路由表中的相应项目变为 “Net1, 16, 直接“ 。但是，很可能要经过 30 秒钟后才把更新信息发送给 R2 。然而 R2 可能已经先把自己的路由表发送给了 R1，其中有 “Net1, 2, R1\u0026quot; 这一项。\nR1收到 R2 的更新报文后，便将“Net1, 2, R1\u0026quot; \u0026ndash;\u0026gt; “Net1, 3, R2”，误认为可以通过R2到达Net1，于是又更新自己的路由表。\n而此时，R2收到了R1不可达Net1的信息,更新了自己路由表。但是R1却认为R2可达Net1。之后二者便互相交换信息，都以为对方可以到达Net1, 由于每次交换都会使路由表中的Net1的距离增加。这样的更新一直继续下去，直到 R1 R2 到Net1 的距离都增大到 16 时，R1和R2才知道原来网 Ne 是不可达的。\n协议 RIP 的这一特点叫作：好消息传播得快，而坏消息传播得慢。网络出故障的传播时间往往较长（例如数分钟）。这是 RIP 的一个主要缺点。\n但如果一个路由器发现了更短的路由，那么这种更新信息就传播得很快。\n路由表 路由表的转发 路由器转发分组的算法: 1.提取目的IP地址 2.是否直接交付 3.特定主机路由 4.检测路由表中有无路径 5.默认路由 0.0.0.0 6.丢弃，报告转发分组出错\n网络层设备 路由器 ","date":"2025-04-02T00:00:00Z","permalink":"https://sfw003.github.io/p/network-layer/","title":"网络层"},{"content":"家庭网络环境（光猫+路由器架构） 光猫拨号模式（路由模式） 流程：\n光猫拨号：光猫通过PPPoE协议向运营商认证，获取公网IP（如 218.207.128.66）。 内网分配：光猫内置DHCP服务器，为下级设备（如路由器）分配内网IP（如 192.168.1.2）。 路由器二次分配：路由器开启NAT功能，为终端设备（手机、电脑）分配二级内网IP（如 192.168.0.100）。\n• 特点：\n• 设备通过两次NAT访问公网，可能影响P2P连接和端口映射。\n• 光猫需支持路由功能，常见于家庭宽带场景。 光猫桥接模式（路由器拨号） 流程：\n光猫透传：光猫仅作为信号转换设备，不参与拨号（模式由运营商或用户修改）。 路由器拨号：路由器通过PPPoE拨号获取公网IP，并直接分配内网IP（如 192.168.0.0/24 网段）。\n• 特点：\n• 减少网络层级，提升性能（如游戏延迟降低）。\n• 需路由器支持PPPoE拨号功能。 校园网环境（集中式DHCP架构） 有线接入流程 步骤：\n物理连接：设备通过网线直连宿舍/教室的网络接口。 自动获取IP：校园网DHCP服务器分配内网IP（如 10.30.199.235，子网掩码 255.255.0.0）。 认证跳转：浏览器自动弹出认证页面（如 https://network.nbu.edu.cn），输入学号/密码完成登录。\n• 特点：\n• 禁止使用私人路由器，防止网络环路。\n• IP地址动态分配，租约时间通常为8天。 无线接入流程 • 步骤：\n连接无线信号（如 nbu-wireless）。 自动获取IP后，通过统一身份认证访问外网。\n• 特点：\n• 多终端支持（通常允许3台设备同时在线）。\n• 校内资源（如图书馆数据库）无需认证即可访问。 ","date":"2025-04-02T00:00:00Z","permalink":"https://sfw003.github.io/p/modern-internet-access-process/","title":"现代上网流程"},{"content":"应用层 DNS DNS的由来 TCP/IP中使用IP地址和端口号来确定网络上的一台主机的一个程序. 但是IP地址不方便记忆.\n于是人们发明了一种叫主机名的东西, 是一个字符串, 并且使用hosts文件来描述主机名和IP地址的关系. 。\n最初, 通过互连网信息中心(SRI-NIC)来管理这个hosts文件的.\n如果一个新计算机要接入网络, 或者某个计算机IP变更, 都需要到信息中心申请变更hosts文件. 其他计算机也需要定期下载更新新版本的hosts文件才能正确上网 这样就太麻烦了, 于是产生了DNS系统.\n一个组织的系统管理机构, 维护系统内的每个主机的IP和主机名的对应关系. 如果新计算机接入网络, 将这个信息注册到数据库中;\n用户输入域名的时候, 会自动查询DNS服务器, 由DNS服务器检索数据库, 得到对应的IP地址.\n域名的组成 通常我们称形如\u0026quot;www.sina.com.cn\u0026quot;是一个域名，但从严格意义上讲，\u0026ldquo;sina.com.cn\u0026quot;才被称为域名(全球唯一)，而\u0026quot;www\u0026quot;是主机名。\u0026ldquo;主机名.域名\u0026quot;称为完全限定域名(FQDN)。一个域名下可以有多个主机，域名全球唯一，那么\u0026quot;主机名.域名\u0026quot;肯定也是全球唯一的。\n顶级域名（TLD） 这是域名的最高级部分，位于最右边。顶级域名有几种类型：\n通用顶级域名（gTLD）：如.com、.org、.net、.info、.biz等。 国家和地区顶级域名（ccTLD）：如.cn（中国）、.us（美国）、.uk（英国）等。 行业和专业领域的（gTLD）：如.edu（教育机构）、.gov（政府机构）、.mil（军事机构）、.int（国际组织）。 新通用顶级域名（new gTLD）：如.app、.tech、.xyz、.shop等。 二级域名（SLD） 位于顶级域名的左边，是域名的一部分，通常代表组织或公司的名称。例如，在example.com中，example是二级域名。\n子域名 这是在二级域名的左边，可以有多个层级，用于更具体的组织和管理。例如，在blog.example.com中，blog是子域名。子域名可以进一步分层，如support.blog.example.com。\n主机名 主机名指向特定的设备或服务器，通常是子域名中的最左边部分。例如，在mail.example.com中，mail是主机名，指向邮件服务器。\nDNS查询 DNS服务器采用分层的结构，整体看上去像一颗树。为什么采用分层的结构？在启用域名功能之前，单凭主机名还无法完全管理IP地址，因为在不同的组织机构中不允许有同名的主机。然而，当出现了带有层次结构的域名之后，每一个组织机构就可以自由地为主机命名了。\n当在浏览器输入一个域名，查询顺序如下：\n（1）查看浏览器缓存\n当用户通过浏览器访问某域名时，本地DNS解析器首先会在浏览器的缓存中查找是否有该域名对应的 IP 地址（若曾经访问过该域名且没有清空缓存便存在）。\n（2）查看hosts文件\n由于hosts 文件是一个静态配置文件，系统会首先查找这个文件中的条目。任何匹配的域名都会直接使用hosts 文件中的IP地址，而不会进行后续查询。\nwindows: C:\\Windows\\System32\\drivers\\etc\\hosts\n（3）查看系统DNS缓存\n如果hosts文件里没有，检测系统DNS缓存。windows主机查询DNS缓存的命令：ipconfig /displaydns , ipconfig /flushdns命令用于清除系统的DNS缓存\n（4）查看路由器缓存\n路由器通常配置为DNS中继器，转发DNS查询请求，某些路由器可能有DNS缓存功能，如果有，则会检测路由器缓存\n（5）查看ISP DNS 缓存\n当在用户客服端查找不到域名对应 IP 地址，则将进入 ISP DNS 缓存中进行查询。比如你用的是电信的网络，则会进入电信的 DNS 缓存服务器中进行查找。\n（6）递归\\迭代查询\n询问根域名服务器 当以上均未完成，则进入根服务器进行查询。全球仅有 13 台根域名服务器，1 个主根域名服务器，其余 12 为辅根域名服务器。根域名收到请求后会查看区域文件记录，若无则将其管辖范围内顶级域名（如.com、.cn等）服务器 IP 告诉本地 DNS 服务器。\n询问顶级域名服务器 顶级域名服务器收到请求后查看区域文件记录，若无记录则将其管辖范围内权威域名服务器的 IP 地址告诉本地 DNS 服务器。\n询问权威域名（主域名）服务器 权威域名服务器接收到请求后查询自己的缓存，如果没有则进入下一级域名服务器进行查找，并重复该步骤直至找到正确记录。\n递归查询一般不常用，而是将递归和迭代相结合的形式：\n实验：修改hosts文件，修改www.baidu.com 对应的ip，导致浏览器无法访问百度\n以谷歌浏览器为例：\n首先清除谷歌的DNS缓存 谷歌浏览器输入：chrome://net-internals/#sockets 在出现的页面中分别点击\n「DNS」-\u0026gt;「Clear host cache」 「Socket」-\u0026gt;「Flush socket pools」 以管理员身份运行记事本，修改hosts, windows系统下hosts文件路径 C:\\Windows\\System32\\drivers\\etc\\hosts 添加：\n1 2 3 192.0.2.1 baidu.com 192.0.2.1 www.baidu.com #为注释 刷新本地缓存：ipconfig /flushdns 此时在谷歌浏览器输入www.baidu.com则进不去。\nURL URL: （Uniform Resource Locator，统一资源定位符）是互联网上用于指定资源位置的标准格式。 协议 登录信息：现在一般很少见到，多数的登录信息会通过登录界面来解决。 服务器地址：可以直接使用IP地址，也可以使用域名。一般情况我们看到的是域名。 端口号：一般情况下我们看不到。多数协议是有固定的端口号的。比如：http \u0026ndash; 80端口， ftp \u0026ndash; 21。因此浏览器会自动根据协议确定端口号。当然也可以手动添加。 文件路径：指定了资源在服务器上的位置。路径由斜杠（/）分隔成多个部分，每个部分表示资源在服务器文件系统中的一个目录或文件。这个路径可以是绝对路径，也可以是相对路径。具体的实现方式在后文讲解。 查询字符串：可选的部分，用于向服务器传递参数。查询字符串以问号（?）开头，参数的形式为key=value，即形式为参数=参数值，不同参数之间用和号（\u0026amp;）连接。 片段标识符：可选的部分，指定了资源中的特定片段或位置。片段标识符以井号（#）开头。 一个典型的URL如下： https://www.example.com/path/to/resource?param1=value1\u0026amp;param2=value2#section1 特殊字符：在标准的URL是有一些特殊字符的，如: . / ? #等。 这些字符是有特殊含义的，如果用户输入的信息也包含特殊字符呢？ https://www.baidu.com/s?ie=utf-8\u0026amp;f=8\u0026amp;rsv_bp=1\u0026amp;tn=44004473_8_oem_dg\u0026amp;wd=%2F%2F%2F%2F%3F%3F%3F%3F\u0026amp;oq=%25E5%25BE%25AE%25E4%25BF%25A1\u0026amp;rsv_pq=9096029e0051298e\u0026amp;rsv_t=9c9fTtRQZn57sCTrXfNf5Nd12s3mvBMGfVc9IDGDaHxz%2FHsJqX5ofYHt5v9i5psyTgxUV%2BXp6wU\u0026amp;rqlang=cn\u0026amp;rsv_enter=1\u0026amp;rsv_dl=tb\u0026amp;rsv_sug3=16\u0026amp;rsv_sug1=6\u0026amp;rsv_sug7=100\u0026amp;bs=%E5%BE%AE%E4%BF%A1\n显然不能直接将带有特殊字符的内容传参到URL里面，因此要进行编码（encode）。\nurlencode：编码 urldecode：解码 浏览器会将用户的搜索信息进行编码，发给服务器，服务器再进行解码。\n转义的规则如下: 将需要转码的字符转为16进制，然后从右到左，取4位(不足4位直接处理)，每2位做一位，前面加上%，编码成%XY\n如：\n1 2 3 4 5 6 + %2B / %2F ? %3F % %25 # %23 \u0026amp; %26 HTTP协议 Web的应用层协议是超文本传输协议（HyperText TransferProtocol，HTTP），它是Web的核心，在[RFC1945］和[RFC2616］中进行了定义。HTTP由两个程序实现：一个客户程序和一个服务器程序。客户程序和服务器程序运行在不同的端系统中，通过交换HTTP报文进行会话。HTTP定义了这些报文的结构以及客户和服务器进行报文交换的方式。\nHTTP请求 request Method GET和POST是安全和幂等的吗？\n先说明下安全和幂等的概念：\n在HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。 所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。 如果从 RFC 规范定义的语义来看:\nGET方法就是安全且幂等的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的， 且每次的结果都是相同的。所以，可以对GET请求的数据做缓存，这个缓存可以做到浏览器本身上 （彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中GET请求可以保存为书 签。 POST因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。所以，浏览器一般不会缓存POST请求，也不能把POST请求保存为书签。 做个简要的小结。 GET的语义是请求获取指定的资源。GET方法是安全、幂等、可被缓存的。 POST的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。 POST不安全，不幂等，（大部分实现）不可缓存。 注意，上面是从 RFC 规范定义的语义来分析的。 但是实际过程中，开发者不一定会按照 RFC 规范定义的语义来实现 GET 和 POST方法。比如： ·可以用GET方法实现新增或删除数据的请求，这样实现的GET方法自然就不是安全和幂等。 ·可以用POST方法实现查询数据的请求，这样实现的POST方法自然就是安全和幂等。\nGET请求主要用于从服务器获取实体资源，资源可被缓存，可以记录历史记录\nPOST请求主要用于向服务器提交表单数据，因此POST请求不会被缓存，POST请求不会保留在浏览器历史记录当中，POST请求不能被保存为书签，POST请求对数据长度没有要求\nPUT方法请求服务器去把请求里的实体存储在请求URI（Request-URI）标识下。\n如果请求URI（Request-URI）指定的的资源已经在源服务器上存在，那么此请求里的实体应该被当作是源服务器关于此URI所指定资源实体的最新修改版本。 如果请求URI（Request-URI）指定的资源不存在，并且此URI被用户代理定义为一个新资源，那么源服务器就应该根据请求里的实体创建一个此URI所标识下的资源。如果一个新的资源被创建了，源服务器必须能向用户代理（user agent） 发送201（已创建）响应。如果已存在的资源被改变了，那么源服务器应该发送200（Ok）或者204（无内容）响应 请求头选项 格式：key: value\nConnection：指明长短连接\nclose 表示短连接 keep-alive表示长连接 Content-Type：用于告诉客户实际返回的内容的内容类型或者说编码类型\n比如 Content-Type: text/html; charset=utf-8 用于表示正文是 text/html文档类型，字符集为utf-8\nContent-Language：用于表示用户希望采用的语言或语言组合\n比如 Content-Language: de-DE 表示该文件为说德语的人提供，但是要注意者不代表文件内容就是德语的。\n这里理解 Content-Type 和 Content-Language 区别： Content-Language更多表示上层语言的表示， 而Content-Type用于底层数据编码的表示。因此在响应报文头部设置字符编码是在Content-Type中设置charset属性，大小写不敏感\ncookie：cookie的中文翻译是曲奇，小甜饼的意思。cookie其实就是一些数据信息，类型为“小型文本文件”，存储于电脑上的文本文件中。\n为什么有cookie?\nHTTP里的Cookie是一种用于在客户端（如浏览器）和服务器之间存储和交换信息的小数据片段。Cookie的主要作用是保持状态信息，因为HTTP协议本身是无状态的，其无状态性主要体现在每个请求都是独立的，服务器不会自动保存任何关于客户端的上下文信息。这种设计简化了协议，但也带来了一些挑战，需要其他机制来管理会话和状态。Cookie可以用于各种用途，如用户身份验证、会话管理、用户偏好保存等。\n下面为cookie用作会话管理的示意图：\ncookie不能直接存放用户的邮箱和密码，这会有安全问题，因此会用sessionID来替代用户的邮箱和密码。\nsessionID通常实验token，一串字符串。\nHTTP响应 response 状态码 1xx-接受的请求正在处理 2xx - 请求正常处理完毕 200: ok\n3xx - 需要进行附加操作以完成请求 301：\n301 状态码表明目标资源被永久的移动到了一个新的 URI，任何未来对这个资源的引用都应该使用新的 URI。 302：\n302 状态码表示目标资源临时移动到了另一个 URI 上。由于重定向是临时发生的，所以客户端在之后的请求中还应该使用原本的 URI。 由于历史原因，用户代理可能会在重定向后的请求中把 POST 方法改为 GET方法。如果不想这样，应该使用 307（Temporary Redirect） 状态码 303：\n303 状态码表示服务器要将浏览器重定向到另一个资源。从语义上讲，重定向到的资源并不是你所请求的资源，而是对你所请求资源的一些描述。 比如303 常用于将 POST 请求重定向到 GET 请求，比如你上传了一份个人信息，服务器发回一个 303 响应，将你导向一个“上传成功”页面。 307：\n307 的定义实际上和 302 是一致的，唯一的区别在于，307 状态码不允许浏览器将原本为 POST 的请求重定向到 GET 请求上。 308：\n308 的定义实际上和 301 是一致的，唯一的区别在于，308 状态码不允许浏览器将原本为 POST 的请求重定向到 GET 请求上。 4xx-服务器无法处理请求-客户端的问题 403：\n禁止访问，服务器理解请求客户端的请求，但是拒绝执行此请求（比如权限不足，ip被拉黑。。。等一系列原因）\n404：NOT FOUND\n表示客户端请求的资源不存在\n5xx-服务器处理出错-服务器的问题 503 由于临时的服务器维护或者过载，服务器当前无法处理请求。. 这个状况是临时的，并且将在一段时间以后恢复。\nHTTP Header http的请求报头和响应报头的内容是一些key:value的参数。 常见有以下几个：\nContent-Type: 数据类型(text/html等) Content-Length: Body的长度 Host: 客户端告知服务器, 所请求的资源是在哪个主机的哪个端口上; User-Agent: 声明用户的操作系统和浏览器版本信息; referer: 当前页面是从哪个页面跳转过来的; location: 搭配3xx状态码使用, 告诉客户端接下来要去哪里访问; Cookie: 用于在客户端存储少量信息. 通常用于实现会话(session)的功能; 下面介绍一下cookie: 我们平时访问某些网站，会观察到以下现象：第一次访问，它会要求你进行登录，但在之后的几天内进行访问，它会自动登录，又过了几天后，它又会要求你重新输入账号密码进行登录。 这是为什么呢？ 首先我要明确一个概念：http协议默认是无状态的。它并不会关心你以前访问哪些资源，比如我们刷新一次网页，浏览器便会再次提交http请求。（当然，现在的浏览器可能会进行在本地缓存，但对http协议本身来说，是需要再次提交请求） 这就导致当我们登录网站后，刷新一下页面或者访问网站的资源，又会要求我们输入账号和密码，这显然对用户很不友好。而cookie便可以解决这个问题。\n第一次登录后，网站会响应一个Set Cookie给浏览器，浏览器会将Set Cookie的信息保存到一个文件里，这个文件我们叫作Cookie文件。之后再次进行访问时，浏览器会自动将Cookie文件的信息发给网站，自动完成登录。 如何验证？以edge浏览器为例。 Location：重定向\n目的资源改变了路径，但是保持原链接依然可用，或者用于将客户端资源请求导向新的URL，通过3xx状态码表示重定向，通过头部字段中设定新的请求URL\n301：表示永久重定向 302：表示临时重定向 HTTPS HTTPS 也是⼀个应⽤层协议. 是在 HTTP 协议的基础上引⼊了⼀个加密层\n对称加密和非对称加密 对称加密其实就是通过同一个\u0026quot;密钥”，把明文加密成密文，并且也能把密文解密成明文. 一个简单的对称加密，按位异或 假设明文a=1234，密钥key=8888 则加密a^key得到的密文b为9834. 然后针对密文9834再次进行运算b^key，得到的就是原来的明文1234. （对于字符串的对称加密也是同理，每一个字符都可以表示成一个数字) 当然，按位异或只是最简单的对称加密.HTTPS中并不是使用按位异或.\n但事情没这么简单.服务器同一时刻其实是给很多客户端提供服务的.这么多客户端，每个人用的秘钥都必须是不同的（如果是相同那密钥就太容易扩散了，黑客就也能拿到了）.因此服务器就需要维护每个客户端和每个密钥之间的关联关系，这也是个很麻烦的事情～\n比较理想的做法，就是能在客户端和服务器建立连接的时候，双方协商确定这次的密钥是啥～\n但是如果直接把密钥明文传输，那么黑客也就能获得密钥了~～此时后续的加密操作就形同虚设了， 因此密钥的传输也必须加密传输！ 但是要想对密钥进行对称加密，就仍然需要先协商确定一个“密钥的密钥\u0026quot;这就成了\u0026quot;先有鸡还是先有 蛋”的问题了.此时密钥的传输再用对称加密就行不通了，\n再引入非对称密钥\n非对称加密要用到两个密钥，一个叫做“公钥\u0026rdquo;，一个叫做\u0026quot;私钥\u0026rdquo; 公钥和私钥是配对的.最大的缺点就是运算速度非常慢，比对称加密要慢很多，\n通过公钥对明文加密，变成密文 通过私钥对密文解密，变成明文 也可以反着用\n通过私钥对明文加密，变成密文 通过公钥对密文解密，变成明文 客户端在本地生成对称密钥，通过公钥加密，发送给服务器， 由于中间的网络设备没有私钥，即使截获了数据，也无法还原出内部的原文，也就无法获取到对称密钥 服务器通过私钥解密，还原出客户端发送的对称密钥.并且使用这个对称密钥加密给客户端返回的响应数据. 后续客户端和服务器的通信都只用对称加密即可.由于该密钥只有客户端和服务器两个主机知道，其他主机/设备不知道密钥即使截获数据也没有意义，\n由于对称加密的效率比非对称加密高很多，因此只是在开始阶段协商密钥的时候使用非对称加密，后续的传输仍然使用对称加密，\n但问题来了：服务器生成公钥和私钥\n客户端如何获取到公钥？ 客户端如何确定这个公钥不是黑客伪造的？ 正是存在这个问题，可以使用中间人攻击。\n中间人攻击 服务器具有非对称加密算法的公钥S，私钥S' 中间人具有非对称加密算法的公钥M，私钥M' 客户端向服务器发起请求，服务器明文传送公钥S给客户端 中间人劫持数据报文，提取公钥S并保存好，然后将被劫持报文中的公钥S替换成为自己的公钥M，并将伪造报文发给客户端 客户端收到报文，提取公钥M(自己当然不知道公钥被更换过了)，自己形成对称秘钥X，用公钥M加密X，形成报文发送给服务器 中间人劫持后，直接用自己的私钥M\u0026rsquo;进行解密，得到通信秘钥X，再用曾经保存的服务端公钥S加密后，将报文推送给服务器 服务器拿到报文，用自己的私钥S\u0026rsquo;解密，得到通信秘钥X 双方开始采用X进行对称加密，进行通信。但是一切都在中间人的掌握中，劫持数据，进行窃听甚 至修改，都是可以的 这个问题的关键在于：客户端无法分辨服务器发送公钥是否被调包。\n因此可以引入一个第三方结构，通过第三方结构来作证客户端收到的公钥是正确的。\n引入证书 服务端在使用HTTPS前，需要向CA机构申领一份数字证书，数字证书里含有证书申请者信息、公钥信息等。服务器把证书传输给浏览器，浏览器从证书里获取公钥就行了，证书就如身份证，证明服务端公钥的权威性\n这个证书可以理解成是一个结构化的字符串，里面包含了以下信息：\n证书发布机构 证书有效期 公钥 证书所有者 签名 需要注意的是：申请证书的时候，需要在特定平台生成查，会同时生成一对儿密钥对儿，即公钥和私钥。这对密钥对儿就是用来在网络通信中进行明文加密以及数字签名的。\n数字签名 解决中间人攻击 在客户端和服务器刚一建立连接的时候，服务器给客户端返回一个响应（包含证书、服务器信息）. 这个证书包含了刚才的公钥，也包含了网站的身份信息 当客户端获取到这个证书之后，会对证书进行校验(防止证书是伪造的). 判定证书的有效期是否过期 判定证书的发布机构是否受信任(操作系统中已内置的受信任的证书发布机构). 验证证书是否被篡改：从操作系统中拿到该证书发布机构的公钥，对签名解密，得到一个hash值（称为数据摘要)，设为hash1.然后计算整个证书的hash值，设为hash2.对比hash1和hash2是否相等.如果相等，则说明证书是没有被篡改过的， 由此可以判断证书没有被更改，没有被更改，可以保证收到的是服务器发送的消息，从中获取公钥。\n问题：中间人不能伪造证书吗？\n中间人有没有可能篡改该证书？\n中间人篡改了证书的明文 由于他没有CA机构的私钥，所以无法hash之后用私钥加密形成签名，那么也就没法办法对篡改后 的证书形成匹配的签名 如果强行篡改，客户端收到该证书后会发现明文和签名解密后的值不一致，则说明证书已被篡改， 证书不可信，从而终止向服务器传输信息，防止信息泄露给中间人 中间人整个掉包证书？\n因为中间人没有CA私钥，所以无法制作假的证书(为什么？） 所以中间人只能向CA申请真证书，然后用自己申请的证书进行掉包 这个确实能做到证书的整体掉包，但是别忘记，证书明文中包含了域名等服务端认证信息，如果整 体掉包，客户端依旧能够识别出来。 永远记住：中间人没有CA私钥，所以对任何证书都无法进行合法修改，包括自己的 但还是有漏洞，受信任的证书发布机构是内置在操作系统中，如果黑客伪装为一个证书发布机构，将自己的证书公钥下载到客户端的操作系统中，还是会出问题。\nFTP协议和TFTP 基于TCP的FTP和基于UDP的TFTP,它们都是文件共享协议的一大类，即复制整个文件。\n特点：若要存取一个文件，就必须先获得一个本地的文件副本。如果要修改文件，只能对文件的副本进行修改，然后再将修改后的文件副本传回到原节点。\nFTP 使用客户-服务器方式。\nFTP的服务器进程由2大部分组成：\n1个主进程，负责接受新的请求 n个从属进程，负责处理单个请求 工作流程：client向server发起建立连接的请求，通过FTP熟知的端口号21，找到server进程，同时告诉server自己的IP:PORT. 服务器用FTP进行数据传输的端口号20与client告知的IP:PORT找到client，建立数据传送连接。\n总结：\nFTP会建立2个TCP连接：控制连接 + 数据传送连接 控制连接在整个会话期间保持打开，数据传送连接在传送完毕后关闭 TFTP 的主要优点有两个。第一， TFTP 可用于 UDP 环境。例如，当需要将程序或文件同\n时向许多机器下载时就往往衙要使用 TFTP 。第二， TFTP 代码所占的内存较小。这对较小的\n计算机或某些特殊用途的设备是很重要的\nTFTP 的工作很像停止等待协议。发送完一个文件块后就等待对方\n的确认，确认时应指明所确认的块编号。发完数据后在规定时间内收不到确认就要重发数据\nPDU 。发送确认 PDU 的一方若在规定时间内收不到下一个文件块，也要重发确认 PDU 。这\n样就可保证文件的传送不致因某一个数据报的丢失而告失败。\n电子邮件格式 电子邮件相关协议 SMTP \u0026ndash; 发送邮件 POP3/IMAP \u0026ndash; 接受邮件 MIME \u0026ndash; 扩充邮件内容 前面所述的电子邮件协议 SMTP 有以下缺点：\nSMTP 不能传送可执行文件或其他的二进制对象。人们曾试图将二进制文件转换为SMTP 使用的 ASCII 文本，例如流行的 UNIX UUencode/UUdecode 方案，但这些均未形成正式标准或事实上的标准。 SMTP 限于传送 位的 ASCII 码。许多其他非英语国家的文字（如中文、俄文，甚至带呕音符号的法文或德文）就无法传送。即使在 SMTP 网关将 EBCDIC 码（即扩充的二／十进制交换码）转换为 ASCII 码，也会遇到一些麻烦. SMTP 服务器会拒绝超过一定长度的邮件。 某些 SMTP 的实现并没有完全按照 SMTP 的互联网标准。常见的问题如下： 回车、换行的删除和增加；\n超过 76 个字符时的处理；截断或自动换行；\n后面多余空格的删除；\n将制表符tab 转换为若干个空格。\nMIME（多用途互联网邮件扩展）\nTCP/IP 体系的电子邮件系统规定电子\n基于万维网的电子邮件 基于万维网的电子邮件系统是指通过网页浏览器来访问和管理电子邮件的系统。邮件传输：SMTP协议，用户访问邮件服务器：HTTP协议\n","date":"2025-04-02T00:00:00Z","permalink":"https://sfw003.github.io/p/application-layer/","title":"应用层"}]