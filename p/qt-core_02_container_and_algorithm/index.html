<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="容器类和算法"><title>【Qt Core 02】容器类和算法</title>
<link rel=canonical href=https://sfw003.github.io/p/qt-core_02_container_and_algorithm/><link rel=stylesheet href=/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css><meta property='og:title' content="【Qt Core 02】容器类和算法"><meta property='og:description' content="容器类和算法"><meta property='og:url' content='https://sfw003.github.io/p/qt-core_02_container_and_algorithm/'><meta property='og:site_name' content='石某人'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='Qt Core'><meta property='article:published_time' content='2025-04-02T00:00:00+00:00'><meta property='article:modified_time' content='2025-04-02T00:00:00+00:00'><meta name=twitter:title content="【Qt Core 02】容器类和算法"><meta name=twitter:description content="容器类和算法"></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu_a0516c4ce0480f39.jpg width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>石某人</a></h1><h2 class=site-description>成为一名强大的程序员</h2></div></header><ol class=menu-social><li><a href=https://blog.csdn.net/ProcedureStone target=_blank title=CSDN rel=me><svg class="icon icon-tabler icon-tabler-brand-csdn" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M3 12c0 4.97 4.03 9 9 9s9-4.03 9-9-4.03-9-9-9-9 4.03-9 9z"/><path d="M12 8c-2.21.0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4z"/><path d="M12 12m-2 0a2 2 0 104 0 2 2 0 10-4 0"/></svg></a></li><li><a href=https://gitee.com/sfw003 target=_blank title=Gitee rel=me><svg class="icon icon-tabler icon-tabler-brand-gitee" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 2c5.523.0 10 4.477 10 10s-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2z"/><path d="M12 6c-3.314.0-6 2.686-6 6s2.686 6 6 6 6-2.686 6-6-2.686-6-6-6z"/><path d="M12 10c-1.105.0-2 .895-2 2s.895 2 2 2 2-.895 2-2-.895-2-2-2z"/></svg></a></li><li><a href=https://github.com/sfw003 target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>主页</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>关于</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>归档</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>搜索</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>友情链接</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#字符串>字符串</a><ol><li><a href=#初始化>初始化</a></li><li><a href=#操作字符串数据>操作字符串数据</a></li><li><a href=#查询字符串数据>查询字符串数据</a></li><li><a href=#比较字符串>比较字符串</a></li><li><a href=#在8位字符串和unicode字符串之间转换>在8位字符串和Unicode字符串之间转换</a></li><li><a href=#给c程序员的注意事项>给C程序员的注意事项</a></li><li><a href=#空字符串和null字符串的区别>空字符串和NULL字符串的区别</a></li><li><a href=#参数格式>参数格式</a></li><li><a href=#更高效的字符串构建>更高效的字符串构建</a></li><li><a href=#字符串编码问题>字符串编码问题</a></li></ol></li><li><a href=#其他>其他</a><ol><li><a href=#qvariant>QVariant</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/qt/ style=background-color:#2a9d8f;color:#fff>Qt</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/qt-core_02_container_and_algorithm/>【Qt Core 02】容器类和算法</a></h2><h3 class=article-subtitle>容器类和算法</h3></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Apr 02, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 3 分钟</time></div></footer></div></header><section class=article-content><blockquote><p>以下内容基于Qt 5.15 LTS 官方文档整理</p></blockquote><p>Qt Core 提供多种容器类，满足不同的数据存储和操作需求。</p><h2 id=字符串>字符串</h2><p>Qt中与字符的核心类</p><ul><li>QChar：存放文本数据</li><li>QByteArray：这个用来存放原始数据（图片、文件的二进制）</li><li>QString：</li></ul><p>QString存储一串16 位QChar，其中每个QChar对应一个<strong>UTF-16</strong> 代码单元。（代码值大于65535的Unicode字符使用代理项对存储，即两个连续的QChar。</p><p>Unicode是一种国际标准，支持当今使用的大多数书写系统。它是US-ASCIl（ANSIX3.4-1986）和Latin-1（IS08859-1）的超集，所有US-
ASCll/Latin-1字符都可以在相同的代码位置使用。</p><p>在幕后，QString 使用隐式共享（写时复制）来减少内存使用并避免不必要的数据复制。这也有助于减少存储16 位字符而不是8 位字符的固有开销。</p><p>除了QString之外，Qt还提供了QByteArray类来存储原始字节和传统的8位以\0&rsquo;结尾的字符串。在大多数情况下，QString 是您要使用的类。它在整个QtAPI 中使用，如果您想在某个时候扩大应用程序的市场，Unicode支持可确保您的应用程序易于翻译。QByteArray适用的两种突出情况是需要存储原始二进制数据时，以及内存节省至关重要时（如在嵌入式系统中），</p><h3 id=初始化>初始化</h3><p>初始化QString的一种方法是将const char *传递给其构造函数。例如，以下代码创建了一个包含数据 “Hello”、大小为 5 的QString：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>QString</span> <span class=n>str</span> <span class=o>=</span> <span class=s>&#34;Hello&#34;</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>QString会使用<code>fromUtf8()</code>函数将const char * 数据转换为 Unicode。
在所有接受const char * 参数的QString函数中，const char * 被解释为经典的 C 风格以&rsquo;\0&rsquo;结尾的字符串。除非函数名明确表明采用其他编码，否则这类const char *参数都假定为 UTF-8 编码。
你也可以将字符串数据作为QChar数组提供：</p><p>可以将字符串数据作为QChar数组提供：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>static</span> <span class=k>const</span> <span class=n>QChar</span> <span class=n>data</span><span class=p>[</span><span class=mi>4</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span> <span class=mh>0x0055</span><span class=p>,</span> <span class=mh>0x006e</span><span class=p>,</span> <span class=mh>0x10e3</span><span class=p>,</span> <span class=mh>0x03a3</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>QString</span> <span class=nf>str</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=mi>4</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>QString会对QChar数据进行深拷贝，所以你之后修改原数据不会产生副作用。如果不想对字符数据进行深拷贝，可以使用QStringView或QString::fromRawData()。</p><p>此时会采用原始数据，如果你仍然修改了数据，它在修改时自动创建副本（深拷贝）</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>QRegularExpression</span> <span class=nf>pattern</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\u00A4</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>const</span> <span class=n>QChar</span> <span class=n>unicode</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=mh>0x005A</span><span class=p>,</span> <span class=mh>0x007F</span><span class=p>,</span> <span class=mh>0x00A4</span><span class=p>,</span> <span class=mh>0x0060</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=mh>0x1009</span><span class=p>,</span> <span class=mh>0x0020</span><span class=p>,</span> <span class=mh>0x0020</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>qsizetype</span> <span class=n>size</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>unicode</span><span class=p>)</span> <span class=o>/</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>QChar</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>QString</span> <span class=n>str</span> <span class=o>=</span> <span class=n>QString</span><span class=o>::</span><span class=n>fromRawData</span><span class=p>(</span><span class=n>unicode</span><span class=p>,</span> <span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>str</span><span class=p>.</span><span class=n>contains</span><span class=p>(</span><span class=n>pattern</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>其他访问QString的数据，可以使用 operator<a class=link href></a>和at()，这和c++的string使用方式一样。</p><p>QString可以嵌入&rsquo;\0&rsquo;字符（QChar::Null）。size()函数始终返回整个字符串的大小，包括嵌入的&rsquo;\0&rsquo;字符。调用resize()函数后，新分配的字符具有未定义的值。要将字符串中的所有字符设置为特定值，可以使用fill()函数。</p><p>你也可以将字符串字面量传递给接受QString作为参数的函数，这会调用QString(const char * )构造函数。类似地，你可以使用<code>qPrintable()</code>宏将QString传递给接受const char * 参数的函数，该宏会将给定的QString作为const char *返回，这等效于调用<code>&lt;QString>.toLocal8Bit().constData()</code>。</p><h3 id=操作字符串数据>操作字符串数据</h3><p>QString 提供了以下用于修改字符数据的基本函数：append()（追加）、prepend()（前置添加）、insert()（插入）、replace()（替换）和remove()（删除）等等
如果你逐步构建一个 QString，并且事先大致知道该 QString 会包含多少字符，可以调用reserve()函数，让 QString 预先分配一定量的内存。你还可以调用capacity()函数来查看 QString 实际分配了多少内存。
replace()和remove()函数的前两个参数分别是开始删除的位置和应删除的字符数。如果你想将某个子字符串的所有出现都替换为另一个子字符串，可以使用带有两个参数的replace()重载函数。</p><p>一个常见的需求是从字符串中删除空白字符（如&rsquo;\n&rsquo;、&rsquo;\t&rsquo;、&rsquo; &lsquo;等）。如果你想删除 QString 两端的空白字符，可以使用trimmed()函数。如果你想删除两端的空白字符，并且将字符串中多个连续的空白字符替换为单个空格字符，可以使用<code>simplified()</code>函数。</p><p>如果你想在 QString 中查找某个特定字符或子字符串的所有出现位置，可以使用indexOf()或lastIndexOf()函数。前者从给定的索引位置开始向前搜索，后者向后搜索。如果找到字符或子字符串，这两个函数都会返回其索引位置；否则，返回 -1。例如，下面是一个典型的循环，用于查找某个特定子字符串的所有出现位置：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>QString</span> <span class=n>str</span> <span class=o>=</span> <span class=s>&#34;We must be &lt;b&gt;bold&lt;/b&gt;, very &lt;b&gt;bold&lt;/b&gt;&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=p>((</span><span class=n>j</span> <span class=o>=</span> <span class=n>str</span><span class=p>.</span><span class=n>indexOf</span><span class=p>(</span><span class=s>&#34;&lt;b&gt;&#34;</span><span class=p>,</span> <span class=n>j</span><span class=p>))</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>qDebug</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Found &lt;b&gt; tag at index position&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>++</span><span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>QString 提供了许多用于将数字转换为字符串以及将字符串转换为数字的函数。例如arg()函数、setNum()函数、number()静态函数，以及toInt()、toDouble()等类似函数。
要获取字符串的大写或小写版本，可以使用toUpper()或toLower()函数。
字符串列表由QStringList类处理。你可以使用split()函数将一个字符串拆分为字符串列表，并使用QStringList::join()函数通过一个可选的分隔符将字符串列表合并为一个字符串。你还可以使用QStringList::filter()函数从字符串列表中获取包含特定子字符串或匹配特定QRegExp（正则表达式）的字符串列表。</p><h3 id=查询字符串数据>查询字符串数据</h3><p>如果你想查看一个QString是否以某个特定子字符串开头或结尾，可以使用<code>startsWith()</code>或<code>endsWith()</code>函数。如果你只是想检查一个QString是否包含某个特定字符或子字符串，可以使用<code>contains()</code>函数。如果你想知道某个特定字符或子字符串在字符串中出现的次数，可以使用<code>count()</code>函数。</p><p>要获取指向实际字符数据的指针，可以调用<code>data()</code>或<code>constData()</code>函数。这些函数返回一个指向QChar数据开头的指针。在对QString调用非const函数之前，该指针保证有效。</p><h3 id=比较字符串>比较字符串</h3><p>QStrings可以使用诸如<code>operator&lt;()</code>、<code>operator&lt;=()</code>、<code>operator==()</code>、<code>operator>=()</code>等重载运算符进行比较。请注意，这种比较完全基于字符的数字Unicode值。它速度非常快，但不符合人类的预期；在可用的情况下，<code>QString::localeAwareCompare()</code>函数通常是对用户界面字符串进行排序的更好选择。</p><p>在类Unix平台（包括Linux、macOS和iOS）上，当Qt与ICU库链接时（通常是这样），会使用其区域设置感知排序。否则，在macOS和iOS上，<code>localeAwareCompare()</code>会根据“国际”偏好面板中的“排序列表顺序”设置进行比较。在没有ICU的其他类Unix系统上，比较会回退到系统库的<code>strcoll()</code>函数，当<code>strcoll()</code>认为字符串相等时，再回退到QString的（不区分区域设置的）比较，如上文所述。</p><h3 id=在8位字符串和unicode字符串之间转换>在8位字符串和Unicode字符串之间转换</h3><p>QString提供了以下三个函数，用于将字符串以QByteArray的形式返回为<code>const char *</code>版本：<code>toUtf8()</code>、<code>toLatin1()</code>和<code>toLocal8Bit()</code>。</p><ul><li><code>toLatin1()</code>返回一个Latin - 1（ISO 8859 - 1）编码的8位字符串。</li><li><code>toUtf8()</code>返回一个UTF - 8编码的8位字符串。UTF - 8是US - ASCII（ANSI X3.4 - 1986）的超集，通过多字节序列支持整个Unicode字符集。</li><li><code>toLocal8Bit()</code>返回一个使用系统本地编码的8位字符串。</li></ul><p>为了从这些编码之一进行转换，QString提供了<code>fromLatin1()</code>、<code>fromUtf8()</code>和<code>fromLocal8Bit()</code>函数。其他编码可通过<code>QTextCodec</code>类支持。</p><p>如上文所述，QString提供了许多函数和运算符，使其与<code>const char *</code>字符串的互操作变得容易。但这种功能是一把双刃剑：如果所有字符串都是US - ASCII或Latin - 1，它会使QString使用起来更方便，但始终存在从<code>const char *</code>进行隐式转换或转换为<code>const char *</code>时使用错误的8位编码的风险。为了最小化这些风险，你可以通过定义以下一些预处理器符号来关闭这些隐式转换：</p><ul><li><code>QT_NO_CAST_FROM_ASCII</code>禁用从C字符串字面量和指针到Unicode的自动转换。</li><li><code>QT_RESTRICTED_CAST_FROM_ASCII</code>允许从C字符和字符数组进行自动转换，但禁用从字符指针到Unicode的自动转换。</li><li><code>QT_NO_CAST_TO_ASCII</code>禁用从QString到C字符串的自动转换。</li></ul><p>然后，你需要显式调用<code>fromUtf8()</code>、<code>fromLatin1()</code>或<code>fromLocal8Bit()</code>从8位字符串构造QString，或者使用轻量级的<code>QLatin1String</code>类，例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>QString</span> <span class=n>url</span> <span class=o>=</span> <span class=n>QLatin1String</span><span class=p>(</span><span class=s>&#34;http://www.unicode.org/&#34;</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>同样，你必须显式调用<code>toLatin1()</code>、<code>toUtf8()</code>或<code>toLocal8Bit()</code>将QString转换为8位字符串。（其他编码可通过<code>QTextCodec</code>类支持。）</p><h3 id=给c程序员的注意事项>给C程序员的注意事项</h3><p>由于C++的类型系统以及QString是隐式共享的这一事实，QStrings可能会被当作<code>int</code>或其他基本类型来对待。例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>QString</span> <span class=n>Widget</span><span class=o>::</span><span class=n>boolToString</span><span class=p>(</span><span class=kt>bool</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>QString</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span> <span class=o>=</span> <span class=s>&#34;True&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span> <span class=o>=</span> <span class=s>&#34;False&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>result</code>变量是一个在栈上分配的普通变量。当调用<code>return</code>时，由于我们是按值返回，复制构造函数会被调用并返回字符串的一个副本。由于隐式共享，实际上并不会发生复制。</p><h3 id=空字符串和null字符串的区别>空字符串和NULL字符串的区别</h3><p>由于历史原因，QString区分空字符串和NULL字符串。NULL字符串是使用QString的默认构造函数或通过将<code>(const char *)0</code>传递给构造函数初始化的字符串。空字符串是任何长度为0的字符串。NULL字符串总是空的，但空字符串不一定是NULL：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>QString</span><span class=p>().</span><span class=n>isNull</span><span class=p>();</span>               <span class=c1>// 返回true
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>QString</span><span class=p>().</span><span class=n>isEmpty</span><span class=p>();</span>              <span class=c1>// 返回true
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>QString</span><span class=p>(</span><span class=s>&#34;&#34;</span><span class=p>).</span><span class=n>isNull</span><span class=p>();</span>             <span class=c1>// 返回false
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>QString</span><span class=p>(</span><span class=s>&#34;&#34;</span><span class=p>).</span><span class=n>isEmpty</span><span class=p>();</span>            <span class=c1>// 返回true
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>QString</span><span class=p>(</span><span class=s>&#34;abc&#34;</span><span class=p>).</span><span class=n>isNull</span><span class=p>();</span>          <span class=c1>// 返回false
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>QString</span><span class=p>(</span><span class=s>&#34;abc&#34;</span><span class=p>).</span><span class=n>isEmpty</span><span class=p>();</span>         <span class=c1>// 返回false
</span></span></span></code></pre></td></tr></table></div></div><p>除了<code>isNull()</code>函数外，所有函数都将NULL字符串与空字符串同等对待。例如，<code>toUtf8().constData()</code>会为NULL字符串返回一个指向<code>'\0'</code>字符的有效指针（不是<code>nullptr</code> ）。我们建议始终使用<code>isEmpty()</code>函数并避免使用<code>isNull()</code>。</p><h3 id=参数格式>参数格式</h3><p>在可以指定参数格式的成员函数（例如<code>arg()</code>、<code>number()</code> ）中，参数格式可以是以下之一：</p><div class=table-wrapper><table><thead><tr><th>格式</th><th>含义</th></tr></thead><tbody><tr><td><code>e</code></td><td>格式化为`[-]9.9e[+</td></tr><tr><td><code>E</code></td><td>格式化为`[-]9.9E[+</td></tr><tr><td><code>f</code></td><td>格式化为<code>[-]9.9</code></td></tr><tr><td><code>g</code></td><td>使用<code>e</code>或<code>f</code>格式，以更简洁者为准</td></tr><tr><td><code>G</code></td><td>使用<code>E</code>或<code>f</code>格式，以更简洁者为准</td></tr></tbody></table></div><p>参数格式中还会指定精度。对于<code>'e'</code>、<code>'E'</code>和<code>'f'</code>格式，精度表示小数点后的位数。对于<code>'g'</code>和<code>'G'</code>格式，精度表示最大有效位数（省略尾随零）。</p><h3 id=更高效的字符串构建>更高效的字符串构建</h3><p>许多字符串在编译时就已知。但是，简单的构造函数<code>QString("Hello")</code>会将字符串内容视为Latin - 1并进行复制。为避免这种情况，可以使用<code>QStringLiteral</code>宏在编译时直接创建所需的数据。这样，从字面量构造QString在运行时不会产生任何开销。</p><p>一种效率稍低的方法是使用<code>QLatin1String</code>。这个类包装一个C字符串字面量，在编译时预先计算其长度，因此与普通C字符串字面量相比，它可以更快地与QStrings进行比较并转换为QStrings。</p><p>使用QString的<code>+</code>运算符，可以轻松地从多个子字符串构造一个复杂的字符串。你可能经常编写这样的代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>QString</span> <span class=n>foo</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>QString</span> <span class=n>type</span> <span class=o>=</span> <span class=s>&#34;long&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>foo</span><span class=o>-&gt;</span><span class=n>setText</span><span class=p>(</span><span class=n>QLatin1String</span><span class=p>(</span><span class=s>&#34;vector&lt;&#34;</span><span class=p>)</span> <span class=o>+</span> <span class=n>type</span> <span class=o>+</span> <span class=n>QLatin1String</span><span class=p>(</span><span class=s>&#34;&gt;::iterator&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>foo</span><span class=p>.</span><span class=n>startsWith</span><span class=p>(</span><span class=s>&#34;(&#34;</span> <span class=o>+</span> <span class=n>type</span> <span class=o>+</span> <span class=s>&#34;) 0x&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span></code></pre></td></tr></table></div></div><p>这些字符串构造方式本身没有问题，但存在一些隐藏的低效之处。从Qt 4.6开始，可以消除这些问题。</p><p>首先，多次使用<code>+</code>运算符通常意味着多次内存分配。当连接n个子字符串（n > 2）时，可能会调用多达n - 1次内存分配器。</p><p>在Qt 4.6中，添加了一个内部模板类<code>QStringBuilder</code>以及一些辅助函数。这个类被标记为内部类，不会出现在文档中，因为不应该在代码中实例化它。它的使用是自动的，如下所述。如果你想查看它，可以在<code>src/corelib/tools/qstringbuilder.cpp</code>中找到这个类。</p><p><code>QStringBuilder</code>使用表达式模板并重新实现了<code>%</code>运算符，因此当使用<code>%</code>而不是<code>+</code>进行字符串连接时，多个子字符串的连接将被推迟，直到最终结果即将分配给QString。此时，已知最终结果所需的内存量。然后调用一次内存分配器来获取所需的空间，并将子字符串逐个复制到其中。</p><p>通过内联和减少引用计数（从<code>QStringBuilder</code>创建的QString通常引用计数为1，而<code>QString::append()</code>需要额外的测试），可以进一步提高效率。</p><p>有两种方法可以使用这种改进的字符串构建方法。一种直接的方法是在需要使用的地方包含<code>QStringBuilder</code>，并在连接字符串时使用<code>%</code>运算符而不是<code>+</code>运算符：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;QStringBuilder&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>    <span class=n>QString</span> <span class=nf>hello</span><span class=p>(</span><span class=s>&#34;hello&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>QStringRef</span> <span class=nf>el</span><span class=p>(</span><span class=o>&amp;</span><span class=n>hello</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>QLatin1String</span> <span class=nf>world</span><span class=p>(</span><span class=s>&#34;world&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>QString</span> <span class=n>message</span> <span class=o>=</span>  <span class=n>hello</span> <span class=o>%</span> <span class=n>el</span> <span class=o>%</span> <span class=n>world</span> <span class=o>%</span> <span class=n>QChar</span><span class=p>(</span><span class=sc>&#39;!&#39;</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>QStringBuilder类则通过表达式模板和重新实现%操作符来解决这一问题。它推迟子字符串的拼接，直到确定最终结果所需内存量后，再一次性分配内存并完成拼接，同时通过内联和减少引用计数进一步提升效率。</p><p>另一种更全局的方法，也是最方便但并非完全源兼容的方法，是在.pro文件中进行如下定义：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>DEFINES *= QT_USE_QSTRINGBUILDER
</span></span></code></pre></td></tr></table></div></div><p>这样，+操作符在任何地方都会自动像QStringBuilder的%操作符一样工作。</p><p>如果采用cmake来管理的话则添加</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>启用 QStringBuilder 优化
</span></span><span class=line><span class=cl>target_compile_definitions(my_app PRIVATE QT_USE_QSTRINGBUILDER)
</span></span></code></pre></td></tr></table></div></div><h3 id=字符串编码问题>字符串编码问题</h3><p>在使用vs运行qt程序遇到这样的问题</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// vs2019 界面显示为乱码
</span></span></span><span class=line><span class=cl><span class=c1>// vs2022 直接在编译时报错：常量中有换行符
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ui</span><span class=o>-&gt;</span><span class=n>label</span><span class=o>-&gt;</span><span class=n>setText</span><span class=p>(</span><span class=s>&#34;森林是否是发顺丰砍伐&#34;</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>问题的根源：<strong>纯文本文件却不会记录自己采用的编码</strong>
比如我采用UTF8编码保存文件，用某软件打开时，并不知道该用什么编码方式去打开，只能靠猜。
以 GBK 编码文件在不同软件中的表现为例：</p><ul><li><p>Linux 下的 gedit：
默认仅支持 UTF-8，打开 GBK 文件会显示乱码。需通过修改 gedit 配置，将 GBK 添加到自动检测列表。</p></li><li><p>Windows 记事本：
会优先尝试 UTF-8，失败后回退到本地编码（GBK），但此行为不稳定，可能误判为其他编码（如 ISO-8859-1）</p></li></ul><p>疑问：那如果我采用 UTF8 with BOM 呢？
BOM文件确实会通过文件头 EF BB BF 隐式声明编码，但此方式不被所有系统兼容。
VS编译器可以识别BOM文件，但是即使知道文件的编码方式，依然有问题。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=o>//</span> <span class=err>文件编码：</span><span class=n>UTF</span><span class=o>-</span><span class=mi>8</span> <span class=n>with</span> <span class=n>BOM</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=n>char</span><span class=o>*</span> <span class=nb>str</span> <span class=o>=</span> <span class=s2>&#34;我是汉字&#34;</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=o>//</span> <span class=err>实际链路：</span>
</span></span><span class=line><span class=cl><span class=o>//</span> <span class=mf>1.</span> <span class=err>编译器按</span> <span class=n>UTF</span><span class=o>-</span><span class=mi>8</span> <span class=err>解析源码</span> <span class=err>→</span> <span class=s2>&#34;我是汉字&#34;</span> <span class=err>的</span> <span class=n>UTF</span><span class=o>-</span><span class=mi>8</span> <span class=err>字节为</span> <span class=p>[</span><span class=mh>0xE6</span><span class=o>...</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=o>//</span> <span class=mf>2.</span> <span class=err>编译器将字符串隐式转码为本地编码（</span><span class=n>GBK</span><span class=err>）→</span> <span class=err>字节变为</span> <span class=p>[</span><span class=mh>0xCE</span><span class=p>,</span> <span class=mh>0xD2</span><span class=o>...</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=o>//</span> <span class=err>结果：</span><span class=nb>str</span> <span class=err>的内容是</span> <span class=n>GBK</span> <span class=err>编码，而非</span> <span class=n>UTF</span><span class=o>-</span><span class=mi>8</span>
</span></span></code></pre></td></tr></table></div></div><p>字符串常量会经过2次解析，原因在于 cl.exe 的 /execution-charset 默认值为本地代码页（如 GBK），导致 char* 字符串最终被转码为 GBK。</p><p>GBK编码下的 const char * str = &ldquo;我是汉字&rdquo;
等价于
const char * str = &ldquo;\xce\xd2\xca\xc7\xba\xba\xd7\xd6&rdquo;;</p><p>前文提到，QString 默认选择Latin-1，\xce\xd2\xca\xc7\xba\xba\xd7\xd6则会被当作Latin-1编码，再转为unicode，所以最后显示为乱码。</p><p><strong>解决方式</strong>：核心是要告诉 QString 你的str是何种编码</p><p>场景：UTF-8 with BOM文件，之前出错的原因是因为字符串常量会经过2次解析，我们可以使用QStringLiteral 跳过第2次解析。（这个适合静态字符串，即已经确定字符串的内容）
<img src=/p/qt-core_02_container_and_algorithm/image/c2b2ca422f4c496f819f7a7917d1d18c.png width=816 height=183 srcset="/p/qt-core_02_container_and_algorithm/image/c2b2ca422f4c496f819f7a7917d1d18c_hu_2f7e5156029d3a2b.png 480w, /p/qt-core_02_container_and_algorithm/image/c2b2ca422f4c496f819f7a7917d1d18c_hu_da54049174d2bd38.png 1024w" loading=lazy alt=在这里插入图片描述 class=gallery-image data-flex-grow=445 data-flex-basis=1070px></p><blockquote><p>如果文件为UTF-8编码，没有BOM，上面操作则会出问题，因为没有bom，编译器不知道文件的编码方式，只能采用默认的。因此为了统一，可以开启vs编译器的 /utf8选项，此时编译器会默认采用utf-8来解码。
<img src=/p/qt-core_02_container_and_algorithm/image/f977b34a5c044b1bb1ed9f3902b7e6e5.png width=818 height=549 srcset="/p/qt-core_02_container_and_algorithm/image/f977b34a5c044b1bb1ed9f3902b7e6e5_hu_d90e679978986967.png 480w, /p/qt-core_02_container_and_algorithm/image/f977b34a5c044b1bb1ed9f3902b7e6e5_hu_3806e7e177565f71.png 1024w" loading=lazy alt=在这里插入图片描述 class=gallery-image data-flex-grow=148 data-flex-basis=357px></p></blockquote><p>如果需要动态转换，参考<strong>在8位字符串和Unicode字符串之间转换</strong>章节</p><h2 id=其他>其他</h2><p>QList， QVector， QMap等等，这些去看一下成员函数，就知道如何使用了。</p><h3 id=qvariant>QVariant</h3><p>Qt 的容器类，我个人认为最重点的就是QString和QVariant。</p><p>QVariant类类似于C++的联合（union）数据类型，它不仅能够保存很多Qt类型的值，包括QColor、QBrush、QFont、QPen、QRect、QString和QSize等，也能够存放Qt的容器类型的值。Qt的很多功能都是建立在QVariant基础上的，如Qt的对象属性及数据库功能等。</p><p>之后再写</p></section><footer class=article-footer><section class=article-tags><a href=/tags/qt-core/>Qt Core</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/qt-core_03_event_mechanism/><div class=article-details><h2 class=article-title>【Qt Core 03】事件机制</h2></div></a></article><article><a href=/p/qt-gui_01_qt_drawing_framework/><div class=article-details><h2 class=article-title>【Qt GUI 01】Qt 绘图框架</h2></div></a></article><article><a href=/p/qt-mvc/><div class=article-details><h2 class=article-title>【Qt MVC】model-view-delegate</h2></div></a></article><article><a href=/p/qt-widgets_layout_management/><div class=article-details><h2 class=article-title>【Qt Widgets】Qt 布局管理</h2></div></a></article><article><a href=/p/qt-series/><div class=article-details><h2 class=article-title>Qt 开发系列</h2></div></a></article></div></div></aside><script src=https://utteranc.es/client.js repo=sfw003/sfwblogtalks issue-term=title crossorigin=anonymous async></script><style>.utterances{max-width:unset}</style><script>let utterancesLoaded=!1;function setUtterancesTheme(e){let t=document.querySelector(".utterances iframe");t&&t.contentWindow.postMessage({type:"set-theme",theme:`github-${e}`},"https://utteranc.es")}addEventListener("message",e=>{if(e.origin!=="https://utteranc.es")return;utterancesLoaded=!0,setUtterancesTheme(document.documentElement.dataset.scheme)}),window.addEventListener("onColorSchemeChange",e=>{if(!utterancesLoaded)return;setUtterancesTheme(e.detail)})</script><footer class=site-footer><section class=copyright>&copy;
2025 石某人</section><section class=powerby>本站所有文章均为原创，转载请注明出处。<br>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>